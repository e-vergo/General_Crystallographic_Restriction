<!DOCTYPE html>
<html lang="en">
<head>
<script>
  MathJax = { 
    tex: {
		    inlineMath: [['$','$'], ['\\(','\\)']]
	} }
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<meta name="generator" content="plasTeX" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Appendix</title>
<link rel="prev" href="sect0005.html" title="The Crystallographic Restriction Theorem" />
<link rel="up" href="index.html" title="Crystallographic Restriction Theorem" />
<link rel="stylesheet" href="styles/theme-blue.css" />
<link rel="stylesheet" href="styles/showmore.css" />
<link rel="stylesheet" href="styles/blueprint.css" />
<link rel="stylesheet" href="styles/amsthm.css" />
<link rel="stylesheet" href="styles/style.css" />
</head>

<body>
<header>
<svg  id="toc-toggle" class="icon icon-list-numbered "><use xlink:href="symbol-defs.svg#icon-list-numbered"></use></svg>
<h1 id="doc_title"><a href="index.html">Crystallographic Restriction Theorem</a></h1>
</header>

<div class="wrapper">
<nav class="toc">
<ul class="sub-toc-0">
<li class="">
  <a href="sect0001.html"><span class="toc_ref">1</span> <span class="toc_entry">Introduction</span></a>
 </li>
<li class="">
  <a href="sect0002.html"><span class="toc_ref">2</span> <span class="toc_entry">The Psi Function</span></a>
 </li>
<li class="">
  <a href="sect0003.html"><span class="toc_ref">3</span> <span class="toc_entry">Integer Matrix Orders</span></a>
 </li>
<li class="">
  <a href="sect0004.html"><span class="toc_ref">4</span> <span class="toc_entry">Companion Matrices</span></a>
 </li>
<li class="">
  <a href="sect0005.html"><span class="toc_ref">5</span> <span class="toc_entry">The Crystallographic Restriction Theorem</span></a>
 </li>
<li class=" active current">
  <a href="sect0006.html"><span class="toc_ref">A</span> <span class="toc_entry">Appendix</span></a>
 </li>
<li ><a href="dep_graph_document.html">Dependency graph</a></li>
</ul>
</nav>

<div class="content">
<div class="content-wrapper">


<div class="main-text">
<h1 id="a0000000007">A Appendix</h1>
<p>This appendix collects technical lemmas used throughout the proof. These are general-purpose results about finite sets, coprime products, Euler’s totient function, and matrix orders that support the main arguments. </p>
<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:sum-le-prod">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">A.0.1</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0006.html#lem:sum-le-prod">#</a>
    
    <a class="icon proof" href="sect0006.html#a0000000063"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Finset.sum_le_prod_of_all_ge_two" class="lean_decl">Finset.sum_le_prod_of_all_ge_two</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       For a finite set where all values \(\geq 2\), the sum is at most the product. </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000063">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By induction on the size of the finite set. Base case: empty sum is \(0 \leq 1\) (empty product). Inductive step: if \(\sum _{x \in s} f(x) \leq \prod _{x \in s} f(x)\) and \(f(a) \geq 2\), then \(\sum _{x \in s \cup \{ a\} } f(x) = f(a) + \sum _s f \leq f(a) \cdot \prod _s f \leq \prod _{s \cup \{ a\} } f\) using \(1 + y \leq 2y\) for \(y \geq 1\) and \(f(a) \geq 2\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Finset.sum_le_prod_of_all_ge_two" data-signature="Finset.sum_le_prod_of_all_ge_two.{u_1} {α : Type u_1} [DecidableEq α] (s : Finset α) (f : α → ℕ)
  (hf : ∀ x ∈ s, 2 ≤ f x) : ∑ x ∈ s, f x ≤ ∏ x ∈ s, f x" data-docs="For a finset where all values of `f` are at least 2, the sum is bounded above by the product.

This is useful in combinatorial arguments where one wants to show that a sum of terms
(each at least 2) cannot exceed their product. The key insight is that for `a, b ≥ 2`,
we have `a + b ≤ a * b`, which extends by induction to finite products.

For upstreaming to Mathlib, this should be placed in `Mathlib.Algebra.Order.BigOperators.Group.Finset`. " title="Finset.sum_le_prod_of_all_ge_two.{u_1} {α : Type u_1} [DecidableEq α] (s : Finset α) (f : α → ℕ)
  (hf : ∀ x ∈ s, 2 ≤ f x) : ∑ x ∈ s, f x ≤ ∏ x ∈ s, f x
For a finset where all values of `f` are at least 2, the sum is bounded above by the product....">sum_le_prod_of_all_ge_two</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="Type u_1" title="Type u_1">α</span> : <span class="lean-sort" data-docs="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable
`&gt; 0` for each variable in the sequence. " title="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable">Type*</span><span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="DecidableEq" data-signature="DecidableEq.{u} (α : Sort u) : Sort (max 1 u)" data-docs="Propositional equality is `Decidable` for all elements of a type.

In other words, an instance of `DecidableEq α` is a means of deciding the proposition `a = b` is
for all `a b : α`.
" title="DecidableEq.{u} (α : Sort u) : Sort (max 1 u)
Propositional equality is `Decidable` for all elements of a type....">DecidableEq</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">α</span><span class="lean-bracket-1">]</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Finset α" title="Finset α">s</span> : <span class="lean-const" data-name="Finset" data-signature="Finset.{u_4} (α : Type u_4) : Type u_4" data-docs="`Finset α` is the type of finite sets of elements of `α`. It is implemented
as a multiset (a list up to permutation) which has no duplicate elements. " title="Finset.{u_4} (α : Type u_4) : Type u_4
`Finset α` is the type of finite sets of elements of `α`. It is implemented...">Finset</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">α</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> : <span class="lean-var" data-type="Type u_1" title="Type u_1">α</span> <span class="lean-operator">→</span> ℕ<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="∀ x ∈ s, 2 ≤ f x" title="∀ x ∈ s, 2 ≤ f x">hf</span> : <span class="lean-operator">∀</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">s</span>, <span class="lean-expr" data-type="ℕ" title="ℕ">2</span> <span class="lean-operator">≤</span> <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">x</span><span class="lean-bracket-1">)</span> :
    <span class="lean-operator">∑</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">s</span>, <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-operator">≤</span> <span class="lean-operator">∏</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">s</span>, <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">x</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="Assuming `x` is a variable in the local context with an inductive type,
`induction x` applies induction on `x` to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on `x`,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,
`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,
and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.
Here the names `a` and `ih₁` are chosen automatically and are not accessible.
You can use `with` to provide the variables names for each constructor.
- `induction e`, where `e` is an expression instead of a variable,
  generalizes `e` in the goal, and then performs induction on the resulting variable.
- `induction e using r` allows the user to specify the principle of induction that should be used.
  Here `r` should be a term whose result type must be of the form `C t`,
  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables
- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,
  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.
  In other words, the net effect is that each inductive hypothesis is generalized.
- Given `x : Nat`, `induction x with | zero =&gt; tac₁ | succ x&#x27; ih =&gt; tac₂`
  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.
" title="Assuming `x` is a variable in the local context with an inductive type,">induction</span> <span class="lean-var" data-type="Finset α" title="Finset α">s</span> <span class="lean-keyword">using</span> <span class="lean-const" data-name="Finset.induction" data-signature="Finset.induction.{u_3} {α : Type u_3} {motive : Finset α → Prop} [DecidableEq α] (empty : motive ∅)
  (insert : ∀ (a : α) (s : Finset α), a ∉ s → motive s → motive (insert a s)) (s : Finset α) : motive s" title="Finset.induction.{u_3} {α : Type u_3} {motive : Finset α → Prop} [DecidableEq α] (empty : motive ∅)
  (insert : ∀ (a : α) (s : Finset α), a ∉ s → motive s → motive (insert a s)) (s : Finset α) : motive s">Finset.induction</span> <span class="lean-keyword" data-docs="After `with`, there is an optional tactic that runs on all branches, and
then a list of alternatives.
" title="After `with`, there is an optional tactic that runs on all branches, and">with</span>
  | <span class="lean-const" data-name="Finset.empty" data-signature="Finset.empty.{u_1} {α : Type u_1} : Finset α" data-docs="The empty finset " title="Finset.empty.{u_1} {α : Type u_1} : Finset α
The empty finset ">empty</span> =&gt; <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions.-
- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.
- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idᵢ`.
- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If
  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis
  `hᵢ` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span>
  | @insert <span class="lean-var" data-type="α" title="α">a</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span> <span class="lean-var" data-type="a ∉ s&#x27;" title="a ∉ s&#x27;">ha</span> <span class="lean-var" data-type="(∀ x ∈ s&#x27;, 2 ≤ f x) → ∑ x ∈ s&#x27;, f x ≤ ∏ x ∈ s&#x27;, f x" title="(∀ x ∈ s&#x27;, 2 ≤ f x) → ∑ x ∈ s&#x27;, f x ≤ ∏ x ∈ s&#x27;, f x">IH</span> =&gt;
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Finset.sum_insert" data-signature="Finset.sum_insert.{u_1, u_4} {ι : Type u_1} {M : Type u_4} {s : Finset ι} {a : ι} [AddCommMonoid M] {f : ι → M}
  [DecidableEq ι] : a ∉ s → ∑ x ∈ insert a s, f x = f a + ∑ x ∈ s, f x" title="Finset.sum_insert.{u_1, u_4} {ι : Type u_1} {M : Type u_4} {s : Finset ι} {a : ι} [AddCommMonoid M] {f : ι → M}
  [DecidableEq ι] : a ∉ s → ∑ x ∈ insert a s, f x = f a + ∑ x ∈ s, f x">Finset.sum_insert</span> <span class="lean-var" data-type="a ∉ s&#x27;" title="a ∉ s&#x27;">ha</span>, <span class="lean-const" data-name="Finset.prod_insert" data-signature="Finset.prod_insert.{u_1, u_4} {ι : Type u_1} {M : Type u_4} {s : Finset ι} {a : ι} [CommMonoid M] {f : ι → M}
  [DecidableEq ι] : a ∉ s → ∏ x ∈ insert a s, f x = f a * ∏ x ∈ s, f x" title="Finset.prod_insert.{u_1, u_4} {ι : Type u_1} {M : Type u_4} {s : Finset ι} {a : ι} [CommMonoid M] {f : ι → M}
  [DecidableEq ι] : a ∉ s → ∏ x ∈ insert a s, f x = f a * ∏ x ∈ s, f x">Finset.prod_insert</span> <span class="lean-var" data-type="a ∉ s&#x27;" title="a ∉ s&#x27;">ha</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="2 ≤ f a" title="2 ≤ f a">h2_a</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">2</span> <span class="lean-operator">≤</span> <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">a</span> := <span class="lean-var" data-type="∀ x ∈ insert a s&#x27;, 2 ≤ f x" title="∀ x ∈ insert a s&#x27;, 2 ≤ f x">hf</span> <span class="lean-var" data-type="α" title="α">a</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_insert_self" data-signature="Finset.mem_insert_self.{u_1} {α : Type u_1} [DecidableEq α] (a : α) (s : Finset α) : a ∈ insert a s" title="Finset.mem_insert_self.{u_1} {α : Type u_1} [DecidableEq α] (a : α) (s : Finset α) : a ∈ insert a s">Finset.mem_insert_self</span> <span class="lean-var" data-type="α" title="α">a</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span><span class="lean-bracket-1">)</span>
    <span class="lean-keyword" data-docs="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.
" title="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `">by_cases</span> <span class="lean-var" data-type="s&#x27; = ∅" title="s&#x27; = ∅">hs_empty</span> : <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span> = <span class="lean-operator">∅</span>
    <span class="lean-operator">·</span> <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions.-
- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.
- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idᵢ`.
- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If
  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis
  `hᵢ` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="s&#x27; = ∅" title="s&#x27; = ∅">hs_empty</span><span class="lean-bracket-1">]</span>
    <span class="lean-operator">·</span> <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="s&#x27;.Nonempty" title="s&#x27;.Nonempty">hs_nonempty</span> : <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span>.<span class="lean-const" data-name="Finset.Nonempty" data-signature="Finset.Nonempty.{u_1} {α : Type u_1} (s : Finset α) : Prop" data-docs="The property `s.Nonempty` expresses the fact that the finset `s` is not empty. It should be used
in theorem assumptions instead of `∃ x, x ∈ s` or `s ≠ ∅` as it gives access to a nice API thanks
to the dot notation. " title="Finset.Nonempty.{u_1} {α : Type u_1} (s : Finset α) : Prop
The property `s.Nonempty` expresses the fact that the finset `s` is not empty. It should be used...">Nonempty</span> := <span class="lean-const" data-name="Finset.nonempty_of_ne_empty" data-signature="Finset.nonempty_of_ne_empty.{u_1} {α : Type u_1} {s : Finset α} (h : s ≠ ∅) : s.Nonempty" title="Finset.nonempty_of_ne_empty.{u_1} {α : Type u_1} {s : Finset α} (h : s ≠ ∅) : s.Nonempty">Finset.nonempty_of_ne_empty</span> <span class="lean-var" data-type="¬s&#x27; = ∅" title="¬s&#x27; = ∅">hs_empty</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="∀ x ∈ s&#x27;, 2 ≤ f x" title="∀ x ∈ s&#x27;, 2 ≤ f x">hs&#x27;_ge2</span> : <span class="lean-operator">∀</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span>, <span class="lean-expr" data-type="ℕ" title="ℕ">2</span> <span class="lean-operator">≤</span> <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">x</span> := <span class="lean-keyword">fun</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-var" data-type="x ∈ s&#x27;" title="x ∈ s&#x27;">hx</span> =&gt; <span class="lean-var" data-type="∀ x ∈ insert a s&#x27;, 2 ≤ f x" title="∀ x ∈ insert a s&#x27;, 2 ≤ f x">hf</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_insert_of_mem" data-signature="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s" title="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s">Finset.mem_insert_of_mem</span> <span class="lean-var" data-type="x ∈ s&#x27;" title="x ∈ s&#x27;">hx</span><span class="lean-bracket-1">)</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="2 ≤ ∏ x ∈ s&#x27;, f x" title="2 ≤ ∏ x ∈ s&#x27;, f x">h2_prod</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">2</span> <span class="lean-operator">≤</span> <span class="lean-operator">∏</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span>, <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">x</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
        <span class="lean-keyword" data-docs="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for
a description of supported patterns.

```lean
obtain ⟨patt⟩ : type := proof
```
is equivalent to
```lean
have h : type := proof
rcases h with ⟨patt⟩
```

If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.

If `type` is omitted, `:= proof` is required.
" title="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for">obtain</span> <span class="lean-bracket-1">⟨</span><span class="lean-var" data-type="α" title="α">b</span>, <span class="lean-var" data-type="b ∈ s&#x27;" title="b ∈ s&#x27;">hb</span><span class="lean-bracket-1">⟩</span> := <span class="lean-var" data-type="s&#x27;.Nonempty" title="s&#x27;.Nonempty">hs_nonempty</span>
        <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="∀ x ∈ s&#x27;, 1 ≤ f x" title="∀ x ∈ s&#x27;, 1 ≤ f x">h1</span> : <span class="lean-operator">∀</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span>, <span class="lean-expr" data-type="ℕ" title="ℕ">1</span> <span class="lean-operator">≤</span> <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">x</span> := <span class="lean-keyword">fun</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-var" data-type="x ∈ s&#x27;" title="x ∈ s&#x27;">hx</span> =&gt; <span class="lean-const" data-name="Nat.one_le_of_lt" data-signature="Nat.one_le_of_lt {a b : ℕ} (h : a &lt; b) : 1 ≤ b" title="Nat.one_le_of_lt {a b : ℕ} (h : a &lt; b) : 1 ≤ b">Nat.one_le_of_lt</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="∀ x ∈ s&#x27;, 2 ≤ f x" title="∀ x ∈ s&#x27;, 2 ≤ f x">hs&#x27;_ge2</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-var" data-type="x ∈ s&#x27;" title="x ∈ s&#x27;">hx</span><span class="lean-bracket-1">)</span>
        <span class="lean-keyword" data-docs="Step-wise reasoning over transitive relations.
```
calc
  a = b := pab
  b = c := pbc
  ...
  y = z := pyz
```
proves `a = z` from the given step-wise proofs. `=` can be replaced with any
relation implementing the typeclass `Trans`. Instead of repeating the right-
hand sides, subsequent left-hand sides can be replaced with `_`.
```
calc
  a = b := pab
  _ = c := pbc
  ...
  _ = z := pyz
```
It is also possible to write the *first* relation as `&lt;lhs&gt;\n  _ = &lt;rhs&gt; :=
&lt;proof&gt;`. This is useful for aligning relation symbols, especially on longer:
identifiers:
```
calc abc
  _ = bce := pabce
  _ = cef := pbcef
  ...
  _ = xyz := pwxyz
```

`calc` works as a term, as a tactic or as a `conv` tactic.

See [Theorem Proving in Lean 4][tpil4] for more information.

[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs
" title="Step-wise reasoning over transitive relations.">calc</span> <span class="lean-operator">∏</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span>, <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-operator">≥</span> <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">b</span> := <span class="lean-const" data-name="Finset.single_le_prod&#x27;" data-signature="Finset.single_le_prod&#x27;.{u_1, u_5} {ι : Type u_1} {N : Type u_5} [CommMonoid N] [PartialOrder N] {f : ι → N}
  {s : Finset ι} [MulLeftMono N] (hf : ∀ i ∈ s, 1 ≤ f i) {a : ι} (h : a ∈ s) : f a ≤ ∏ x ∈ s, f x" title="Finset.single_le_prod&#x27;.{u_1, u_5} {ι : Type u_1} {N : Type u_5} [CommMonoid N] [PartialOrder N] {f : ι → N}
  {s : Finset ι} [MulLeftMono N] (hf : ∀ i ∈ s, 1 ≤ f i) {a : ι} (h : a ∈ s) : f a ≤ ∏ x ∈ s, f x">Finset.single_le_prod&#x27;</span> <span class="lean-var" data-type="∀ x ∈ s&#x27;, 1 ≤ f x" title="∀ x ∈ s&#x27;, 1 ≤ f x">h1</span> <span class="lean-var" data-type="b ∈ s&#x27;" title="b ∈ s&#x27;">hb</span>
          _ <span class="lean-operator">≥</span> <span class="lean-expr" data-type="ℕ" title="ℕ">2</span> := <span class="lean-var" data-type="∀ x ∈ s&#x27;, 2 ≤ f x" title="∀ x ∈ s&#x27;, 2 ≤ f x">hs&#x27;_ge2</span> <span class="lean-var" data-type="α" title="α">b</span> <span class="lean-var" data-type="b ∈ s&#x27;" title="b ∈ s&#x27;">hb</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="∑ x ∈ s&#x27;, f x ≤ ∏ x ∈ s&#x27;, f x" title="∑ x ∈ s&#x27;, f x ≤ ∏ x ∈ s&#x27;, f x">IH&#x27;</span> := <span class="lean-var" data-type="(∀ x ∈ s&#x27;, 2 ≤ f x) → ∑ x ∈ s&#x27;, f x ≤ ∏ x ∈ s&#x27;, f x" title="(∀ x ∈ s&#x27;, 2 ≤ f x) → ∑ x ∈ s&#x27;, f x ≤ ∏ x ∈ s&#x27;, f x">IH</span> <span class="lean-var" data-type="∀ x ∈ s&#x27;, 2 ≤ f x" title="∀ x ∈ s&#x27;, 2 ≤ f x">hs&#x27;_ge2</span>
      <span class="lean-keyword" data-docs="Step-wise reasoning over transitive relations.
```
calc
  a = b := pab
  b = c := pbc
  ...
  y = z := pyz
```
proves `a = z` from the given step-wise proofs. `=` can be replaced with any
relation implementing the typeclass `Trans`. Instead of repeating the right-
hand sides, subsequent left-hand sides can be replaced with `_`.
```
calc
  a = b := pab
  _ = c := pbc
  ...
  _ = z := pyz
```
It is also possible to write the *first* relation as `&lt;lhs&gt;\n  _ = &lt;rhs&gt; :=
&lt;proof&gt;`. This is useful for aligning relation symbols, especially on longer:
identifiers:
```
calc abc
  _ = bce := pabce
  _ = cef := pbcef
  ...
  _ = xyz := pwxyz
```

`calc` works as a term, as a tactic or as a `conv` tactic.

See [Theorem Proving in Lean 4][tpil4] for more information.

[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs
" title="Step-wise reasoning over transitive relations.">calc</span> <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">a</span> + <span class="lean-operator">∑</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span>, <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">x</span>
          <span class="lean-operator">≤</span> <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">a</span> + <span class="lean-operator">∏</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span>, <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">x</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span>
        _ <span class="lean-operator">≤</span> <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">a</span> * <span class="lean-operator">∏</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span>, <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">x</span> := <span class="lean-const" data-name="Nat.add_le_mul" data-signature="Nat.add_le_mul {a : ℕ} (ha : 2 ≤ a) {b : ℕ} : 2 ≤ b → a + b ≤ a * b" title="Nat.add_le_mul {a : ℕ} (ha : 2 ≤ a) {b : ℕ} : 2 ≤ b → a + b ≤ a * b">Nat.add_le_mul</span> <span class="lean-var" data-type="2 ≤ f a" title="2 ≤ f a">h2_a</span> <span class="lean-var" data-type="2 ≤ ∏ x ∈ s&#x27;, f x" title="2 ≤ ∏ x ∈ s&#x27;, f x">h2_prod</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/Lemmas.lean#L41-L74" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:sum-le-prod');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:lcm-factorization-le-sup">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">A.0.2</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0006.html#lem:lcm-factorization-le-sup">#</a>
    
    <a class="icon proof" href="sect0006.html#a0000000064"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Finset.lcm_factorization_le_sup" class="lean_decl">Finset.lcm_factorization_le_sup</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       The factorization of \(\mathrm{lcm}(S)\) at prime \(q\) is bounded by \(\sup _{x \in S} v_q(x)\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000064">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>The \(q\)-adic valuation of \(\mathrm{lcm}(S)\) is the maximum of \(q\)-adic valuations over elements of \(S\). This follows from the definition of lcm via factorization: \(v_q(\mathrm{lcm}(S)) = \sup _{x \in S} v_q(x)\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Finset.lcm_factorization_le_sup" data-signature="Finset.lcm_factorization_le_sup.{u_1} {α : Type u_1} [DecidableEq α] (S : Finset α) (f : α → ℕ) (q : ℕ)
  (hS_ne_zero : ∀ x ∈ S, f x ≠ 0) : (S.lcm f).factorization q ≤ S.sup fun x =&gt; (f x).factorization q" data-docs="The factorization of a finset lcm at any prime is at most the supremum. " title="Finset.lcm_factorization_le_sup.{u_1} {α : Type u_1} [DecidableEq α] (S : Finset α) (f : α → ℕ) (q : ℕ)
  (hS_ne_zero : ∀ x ∈ S, f x ≠ 0) : (S.lcm f).factorization q ≤ S.sup fun x =&gt; (f x).factorization q
The factorization of a finset lcm at any prime is at most the supremum. ">lcm_factorization_le_sup</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="Type u_1" title="Type u_1">α</span> : <span class="lean-sort" data-docs="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable
`&gt; 0` for each variable in the sequence. " title="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable">Type*</span><span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="DecidableEq" data-signature="DecidableEq.{u} (α : Sort u) : Sort (max 1 u)" data-docs="Propositional equality is `Decidable` for all elements of a type.

In other words, an instance of `DecidableEq α` is a means of deciding the proposition `a = b` is
for all `a b : α`.
" title="DecidableEq.{u} (α : Sort u) : Sort (max 1 u)
Propositional equality is `Decidable` for all elements of a type....">DecidableEq</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">α</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Finset α" title="Finset α">S</span> : <span class="lean-const" data-name="Finset" data-signature="Finset.{u_4} (α : Type u_4) : Type u_4" data-docs="`Finset α` is the type of finite sets of elements of `α`. It is implemented
as a multiset (a list up to permutation) which has no duplicate elements. " title="Finset.{u_4} (α : Type u_4) : Type u_4
`Finset α` is the type of finite sets of elements of `α`. It is implemented...">Finset</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">α</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> : <span class="lean-var" data-type="Type u_1" title="Type u_1">α</span> <span class="lean-operator">→</span> ℕ<span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="ℕ" title="ℕ">q</span> : ℕ<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="∀ x ∈ S, f x ≠ 0" title="∀ x ∈ S, f x ≠ 0">hS_ne_zero</span> : <span class="lean-operator">∀</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">S</span>, <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-operator">≠</span> <span class="lean-expr" data-type="ℕ" title="ℕ">0</span><span class="lean-bracket-1">)</span> :
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Finset α" title="Finset α">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α] (s : Finset β)
  (f : β → α) : α" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α] (s : Finset β)
  (f : β → α) : α
Least common multiple of a finite set ">lcm</span> <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Nat.factorization" data-signature="Nat.factorization (n : ℕ) : ℕ →₀ ℕ" data-docs="`n.factorization` is the finitely supported function `ℕ →₀ ℕ`
mapping each prime factor of `n` to its multiplicity in `n`. " title="Nat.factorization (n : ℕ) : ℕ →₀ ℕ
`n.factorization` is the finitely supported function `ℕ →₀ ℕ`...">factorization</span> <span class="lean-var" data-type="ℕ" title="ℕ">q</span> <span class="lean-operator">≤</span> <span class="lean-var" data-type="Finset α" title="Finset α">S</span>.<span class="lean-const" data-name="Finset.sup" data-signature="Finset.sup.{u_2, u_3} {α : Type u_2} {β : Type u_3} [SemilatticeSup α] [OrderBot α] (s : Finset β) (f : β → α) : α" data-docs="Supremum of a finite set: `sup {a, b, c} f = f a ⊔ f b ⊔ f c` " title="Finset.sup.{u_2, u_3} {α : Type u_2} {β : Type u_3} [SemilatticeSup α] [OrderBot α] (s : Finset β) (f : β → α) : α
Supremum of a finite set: `sup {a, b, c} f = f a ⊔ f b ⊔ f c` ">sup</span> <span class="lean-bracket-1">(</span><span class="lean-keyword">fun</span> <span class="lean-var" data-type="α" title="α">x</span> =&gt; <span class="lean-bracket-2">(</span><span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">x</span><span class="lean-bracket-2">)</span>.<span class="lean-const" data-name="Nat.factorization" data-signature="Nat.factorization (n : ℕ) : ℕ →₀ ℕ" data-docs="`n.factorization` is the finitely supported function `ℕ →₀ ℕ`
mapping each prime factor of `n` to its multiplicity in `n`. " title="Nat.factorization (n : ℕ) : ℕ →₀ ℕ
`n.factorization` is the finitely supported function `ℕ →₀ ℕ`...">factorization</span> <span class="lean-var" data-type="ℕ" title="ℕ">q</span><span class="lean-bracket-1">)</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="Assuming `x` is a variable in the local context with an inductive type,
`induction x` applies induction on `x` to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on `x`,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,
`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,
and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.
Here the names `a` and `ih₁` are chosen automatically and are not accessible.
You can use `with` to provide the variables names for each constructor.
- `induction e`, where `e` is an expression instead of a variable,
  generalizes `e` in the goal, and then performs induction on the resulting variable.
- `induction e using r` allows the user to specify the principle of induction that should be used.
  Here `r` should be a term whose result type must be of the form `C t`,
  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables
- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,
  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.
  In other words, the net effect is that each inductive hypothesis is generalized.
- Given `x : Nat`, `induction x with | zero =&gt; tac₁ | succ x&#x27; ih =&gt; tac₂`
  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.
" title="Assuming `x` is a variable in the local context with an inductive type,">induction</span> <span class="lean-var" data-type="Finset α" title="Finset α">S</span> <span class="lean-keyword">using</span> <span class="lean-const" data-name="Finset.induction" data-signature="Finset.induction.{u_3} {α : Type u_3} {motive : Finset α → Prop} [DecidableEq α] (empty : motive ∅)
  (insert : ∀ (a : α) (s : Finset α), a ∉ s → motive s → motive (insert a s)) (s : Finset α) : motive s" title="Finset.induction.{u_3} {α : Type u_3} {motive : Finset α → Prop} [DecidableEq α] (empty : motive ∅)
  (insert : ∀ (a : α) (s : Finset α), a ∉ s → motive s → motive (insert a s)) (s : Finset α) : motive s">Finset.induction</span> <span class="lean-keyword" data-docs="After `with`, there is an optional tactic that runs on all branches, and
then a list of alternatives.
" title="After `with`, there is an optional tactic that runs on all branches, and">with</span>
  | <span class="lean-const" data-name="Finset.empty" data-signature="Finset.empty.{u_1} {α : Type u_1} : Finset α" data-docs="The empty finset " title="Finset.empty.{u_1} {α : Type u_1} : Finset α
The empty finset ">empty</span> =&gt;
    <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions.-
- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.
- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idᵢ`.
- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If
  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis
  `hᵢ` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Finset.lcm_empty" data-signature="Finset.lcm_empty.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α]
  {f : β → α} : ∅.lcm f = 1" title="Finset.lcm_empty.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α]
  {f : β → α} : ∅.lcm f = 1">Finset.lcm_empty</span>, <span class="lean-const" data-name="Nat.factorization_one" data-signature="Nat.factorization_one : Nat.factorization 1 = 0" title="Nat.factorization_one : Nat.factorization 1 = 0">Nat.factorization_one</span>, <span class="lean-const" data-name="Finsupp.coe_zero" data-signature="Finsupp.coe_zero.{u_1, u_4} {α : Type u_1} {M : Type u_4} [Zero M] : ⇑0 = 0" title="Finsupp.coe_zero.{u_1, u_4} {α : Type u_1} {M : Type u_4} [Zero M] : ⇑0 = 0">Finsupp.coe_zero</span>, <span class="lean-const" data-name="Pi.zero_apply" data-signature="Pi.zero_apply.{u_1, u_5} {ι : Type u_1} {M : ι → Type u_5} [(i : ι) → Zero (M i)] (i : ι) : 0 i = 0" title="Pi.zero_apply.{u_1, u_5} {ι : Type u_1} {M : ι → Type u_5} [(i : ι) → Zero (M i)] (i : ι) : 0 i = 0">Pi.zero_apply</span>,
      <span class="lean-const" data-name="Finset.sup_empty" data-signature="Finset.sup_empty.{u_2, u_3} {α : Type u_2} {β : Type u_3} [SemilatticeSup α] [OrderBot α] {f : β → α} : ∅.sup f = ⊥" title="Finset.sup_empty.{u_2, u_3} {α : Type u_2} {β : Type u_3} [SemilatticeSup α] [OrderBot α] {f : β → α} : ∅.sup f = ⊥">Finset.sup_empty</span>, <span class="lean-const" data-name="bot_eq_zero" data-signature="bot_eq_zero.{u} {α : Type u} [AddZeroClass α] [PartialOrder α] [CanonicallyOrderedAdd α] [OrderBot α] : ⊥ = 0" title="bot_eq_zero.{u} {α : Type u} [AddZeroClass α] [PartialOrder α] [CanonicallyOrderedAdd α] [OrderBot α] : ⊥ = 0">bot_eq_zero</span>, <span class="lean-const" data-name="le_refl" data-signature="le_refl.{u_1} {α : Type u_1} [Preorder α] (a : α) : a ≤ a" data-docs="The relation `≤` on a preorder is reflexive. " title="le_refl.{u_1} {α : Type u_1} [Preorder α] (a : α) : a ≤ a
The relation `≤` on a preorder is reflexive. ">le_refl</span><span class="lean-bracket-1">]</span>
  | @insert <span class="lean-var" data-type="α" title="α">a</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span> <span class="lean-var" data-type="a ∉ s&#x27;" title="a ∉ s&#x27;">ha</span> <span class="lean-var" data-type="(∀ x ∈ s&#x27;, f x ≠ 0) → (s&#x27;.lcm f).factorization q ≤ s&#x27;.sup fun x =&gt; (f x).factorization q" title="(∀ x ∈ s&#x27;, f x ≠ 0) → (s&#x27;.lcm f).factorization q ≤ s&#x27;.sup fun x =&gt; (f x).factorization q">IH</span> =&gt;
    <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions.-
- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.
- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idᵢ`.
- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If
  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis
  `hᵢ` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Finset.lcm_insert" data-signature="Finset.lcm_insert.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α]
  {s : Finset β} {f : β → α} [DecidableEq β] {b : β} : (insert b s).lcm f = GCDMonoid.lcm (f b) (s.lcm f)" title="Finset.lcm_insert.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α]
  {s : Finset β} {f : β → α} [DecidableEq β] {b : β} : (insert b s).lcm f = GCDMonoid.lcm (f b) (s.lcm f)">Finset.lcm_insert</span>, <span class="lean-const" data-name="Finset.sup_insert" data-signature="Finset.sup_insert.{u_2, u_3} {α : Type u_2} {β : Type u_3} [SemilatticeSup α] [OrderBot α] {s : Finset β} {f : β → α}
  [DecidableEq β] {b : β} : (insert b s).sup f = f b ⊔ s.sup f" title="Finset.sup_insert.{u_2, u_3} {α : Type u_2} {β : Type u_3} [SemilatticeSup α] [OrderBot α] {s : Finset β} {f : β → α}
  [DecidableEq β] {b : β} : (insert b s).sup f = f b ⊔ s.sup f">Finset.sup_insert</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.
" title="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `">by_cases</span> <span class="lean-var" data-type="s&#x27; = ∅" title="s&#x27; = ∅">hs&#x27;_empty</span> : <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span> = <span class="lean-operator">∅</span>
    <span class="lean-operator">·</span> <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions.-
- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.
- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idᵢ`.
- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If
  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis
  `hᵢ` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="s&#x27; = ∅" title="s&#x27; = ∅">hs&#x27;_empty</span><span class="lean-bracket-1">]</span>
    <span class="lean-operator">·</span> <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="s&#x27;.lcm f ≠ 0" title="s&#x27;.lcm f ≠ 0">hs&#x27;_ne_zero</span> : <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α] (s : Finset β)
  (f : β → α) : α" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α] (s : Finset β)
  (f : β → α) : α
Least common multiple of a finite set ">lcm</span> <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-operator">≠</span> <span class="lean-expr" data-type="ℕ" title="ℕ">0</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
        <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="ne_eq" data-signature="ne_eq.{u_1} {α : Sort u_1} (a b : α) : (a ≠ b) = ¬a = b" title="ne_eq.{u_1} {α : Sort u_1} (a b : α) : (a ≠ b) = ¬a = b">ne_eq</span>, <span class="lean-const" data-name="Finset.lcm_eq_zero_iff" data-signature="Finset.lcm_eq_zero_iff.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α]
  {s : Finset β} {f : β → α} [Nontrivial α] : s.lcm f = 0 ↔ ∃ x ∈ s, f x = 0" title="Finset.lcm_eq_zero_iff.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α]
  {s : Finset β} {f : β → α} [Nontrivial α] : s.lcm f = 0 ↔ ∃ x ∈ s, f x = 0">Finset.lcm_eq_zero_iff</span><span class="lean-bracket-1">]</span>
        <span class="lean-keyword" data-docs="Push negations into the conclusion or a hypothesis.
For instance, a hypothesis `h : ¬ ∀ x, ∃ y, x ≤ y` will be transformed by `push_neg at h` into
`h : ∃ x, ∀ y, y &lt; x`. Binder names are preserved.

`push_neg` is a special case of the more general `push` tactic, namely `push Not`.
The `push` tactic can be extended using the `@[push]` attribute. `push` has special-casing
built in for `push Not`, so that it can preserve binder names, and so that `¬ (p ∧ q)` can be
transformed to either `p → ¬ q` (default) or `¬ p ∨ ¬ q` (`push_neg +distrib`).

Tactics that introduce a negation usually have a version that automatically calls `push_neg` on
that negation. These include `by_cases!`, `contrapose!` and `by_contra!`.

Another example: given a hypothesis
```lean
h : ¬ ∀ ε &gt; 0, ∃ δ &gt; 0, ∀ x, |x - x₀| ≤ δ → |f x - y₀| ≤ ε
```
writing `push_neg at h` will turn `h` into
```lean
h : ∃ ε &gt; 0, ∀ δ &gt; 0, ∃ x, |x - x₀| ≤ δ ∧ ε &lt; |f x - y₀|
```
Note that binder names are preserved by this tactic, contrary to what would happen with `simp`
using the relevant lemmas. One can use this tactic at the goal using `push_neg`,
at every hypothesis and the goal using `push_neg at *` or at selected hypotheses and the goal
using say `push_neg at h h&#x27; ⊢`, as usual.
" title="Push negations into the conclusion or a hypothesis.">push_neg</span>
        <span class="lean-keyword" data-docs="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal&#x27;s target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`. It is equivalent to `intro _`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, given a type ascription, or matched against a pattern:
  ```lean
  -- ... ⊢ α × β → ...
  intro (a, b)
  -- ..., a : α, b : β ⊢ ...
  ```
* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side
  is a variable.
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
" title="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.">intro</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-var" data-type="x ∈ s&#x27;" title="x ∈ s&#x27;">hx</span>
        <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-var" data-type="∀ x ∈ insert a s&#x27;, f x ≠ 0" title="∀ x ∈ insert a s&#x27;, f x ≠ 0">hS_ne_zero</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_insert_of_mem" data-signature="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s" title="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s">Finset.mem_insert_of_mem</span> <span class="lean-var" data-type="x ∈ s&#x27;" title="x ∈ s&#x27;">hx</span><span class="lean-bracket-1">)</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="f a ≠ 0" title="f a ≠ 0">ha_ne_zero</span> : <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">a</span> <span class="lean-operator">≠</span> <span class="lean-expr" data-type="ℕ" title="ℕ">0</span> := <span class="lean-var" data-type="∀ x ∈ insert a s&#x27;, f x ≠ 0" title="∀ x ∈ insert a s&#x27;, f x ≠ 0">hS_ne_zero</span> <span class="lean-var" data-type="α" title="α">a</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_insert_self" data-signature="Finset.mem_insert_self.{u_1} {α : Type u_1} [DecidableEq α] (a : α) (s : Finset α) : a ∈ insert a s" title="Finset.mem_insert_self.{u_1} {α : Type u_1} [DecidableEq α] (a : α) (s : Finset α) : a ∈ insert a s">Finset.mem_insert_self</span> <span class="lean-var" data-type="α" title="α">a</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span><span class="lean-bracket-1">)</span>
      <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="lcm_eq_nat_lcm" data-signature="lcm_eq_nat_lcm (m n : ℕ) : GCDMonoid.lcm m n = m.lcm n" title="lcm_eq_nat_lcm (m n : ℕ) : GCDMonoid.lcm m n = m.lcm n">lcm_eq_nat_lcm</span>, <span class="lean-const" data-name="Nat.factorization_lcm" data-signature="Nat.factorization_lcm {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) : (a.lcm b).factorization = a.factorization ⊔ b.factorization" title="Nat.factorization_lcm {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) : (a.lcm b).factorization = a.factorization ⊔ b.factorization">Nat.factorization_lcm</span> <span class="lean-var" data-type="f a ≠ 0" title="f a ≠ 0">ha_ne_zero</span> <span class="lean-var" data-type="s&#x27;.lcm f ≠ 0" title="s&#x27;.lcm f ≠ 0">hs&#x27;_ne_zero</span><span class="lean-bracket-1">]</span>
      <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions.-
- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.
- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idᵢ`.
- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If
  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis
  `hᵢ` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Finsupp.sup_apply" data-signature="Finsupp.sup_apply.{u_1, u_2} {ι : Type u_1} {M : Type u_2} [Zero M] [SemilatticeSup M] (f g : ι →₀ M) (i : ι) :
  (f ⊔ g) i = f i ⊔ g i" title="Finsupp.sup_apply.{u_1, u_2} {ι : Type u_1} {M : Type u_2} [Zero M] [SemilatticeSup M] (f g : ι →₀ M) (i : ι) :
  (f ⊔ g) i = f i ⊔ g i">Finsupp.sup_apply</span>, <span class="lean-const" data-name="sup_le_iff" data-signature="sup_le_iff.{u} {α : Type u} [SemilatticeSup α] {a b c : α} : a ⊔ b ≤ c ↔ a ≤ c ∧ b ≤ c" title="sup_le_iff.{u} {α : Type u} [SemilatticeSup α] {a b c : α} : a ⊔ b ≤ c ↔ a ≤ c ∧ b ≤ c">sup_le_iff</span><span class="lean-bracket-1">]</span>
      <span class="lean-keyword" data-docs="If the main goal&#x27;s target type is an inductive type, `constructor` solves it with
the first matching constructor, or else fails.
" title="If the main goal&#x27;s target type is an inductive type, `constructor` solves it with">constructor</span>
      <span class="lean-operator">·</span> <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="le_sup_left" data-signature="le_sup_left.{u} {α : Type u} [SemilatticeSup α] {a b : α} : a ≤ a ⊔ b" title="le_sup_left.{u} {α : Type u} [SemilatticeSup α] {a b : α} : a ≤ a ⊔ b">le_sup_left</span>
      <span class="lean-operator">·</span> <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(s&#x27;.lcm f).factorization q ≤ s&#x27;.sup fun x =&gt; (f x).factorization q" title="(s&#x27;.lcm f).factorization q ≤ s&#x27;.sup fun x =&gt; (f x).factorization q">hIH</span> := <span class="lean-var" data-type="(∀ x ∈ s&#x27;, f x ≠ 0) → (s&#x27;.lcm f).factorization q ≤ s&#x27;.sup fun x =&gt; (f x).factorization q" title="(∀ x ∈ s&#x27;, f x ≠ 0) → (s&#x27;.lcm f).factorization q ≤ s&#x27;.sup fun x =&gt; (f x).factorization q">IH</span> <span class="lean-bracket-1">(</span><span class="lean-keyword">fun</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-var" data-type="x ∈ s&#x27;" title="x ∈ s&#x27;">hx</span> =&gt; <span class="lean-var" data-type="∀ x ∈ insert a s&#x27;, f x ≠ 0" title="∀ x ∈ insert a s&#x27;, f x ≠ 0">hS_ne_zero</span> <span class="lean-var" data-type="α" title="α">x</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Finset.mem_insert_of_mem" data-signature="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s" title="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s">Finset.mem_insert_of_mem</span> <span class="lean-var" data-type="x ∈ s&#x27;" title="x ∈ s&#x27;">hx</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span>
        <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="le_trans" data-signature="le_trans.{u_1} {α : Type u_1} [Preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c" data-docs="The relation `≤` on a preorder is transitive. " title="le_trans.{u_1} {α : Type u_1} [Preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c
The relation `≤` on a preorder is transitive. ">le_trans</span> <span class="lean-var" data-type="(s&#x27;.lcm f).factorization q ≤ s&#x27;.sup fun x =&gt; (f x).factorization q" title="(s&#x27;.lcm f).factorization q ≤ s&#x27;.sup fun x =&gt; (f x).factorization q">hIH</span> <span class="lean-const" data-name="le_sup_right" data-signature="le_sup_right.{u} {α : Type u} [SemilatticeSup α] {a b : α} : b ≤ a ⊔ b" title="le_sup_right.{u} {α : Type u} [SemilatticeSup α] {a b : α} : b ≤ a ⊔ b">le_sup_right</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/Lemmas.lean#L78-L106" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:lcm-factorization-le-sup');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:primePow-mem-of-lcm-eq">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">A.0.3</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0006.html#lem:primePow-mem-of-lcm-eq">#</a>
    
    <a class="icon proof" href="sect0006.html#a0000000065"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Finset.prime_pow_mem_of_lcm_eq" class="lean_decl">Crystallographic.Finset.prime_pow_mem_of_lcm_eq</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       If \(\mathrm{lcm}(S) = p^k\) and all elements of \(S\) divide \(p^k\), then \(p^k \in S\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000065">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>Since \(\mathrm{lcm}(S) = p^k\) and all elements divide \(p^k\), each element has form \(p^j\) for some \(j \leq k\). Taking lcm over these powers gives \(p^{\max _j} = p^k\), so some element must have \(j = k\), meaning \(p^k \in S\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Crystallographic.Finset.prime_pow_mem_of_lcm_eq" data-signature="Crystallographic.Finset.prime_pow_mem_of_lcm_eq {p k : ℕ} (hp : Nat.Prime p) (hk : 0 &lt; k) (S : Finset ℕ)
  (hS_sub : ∀ d ∈ S, d ∣ p ^ k) (hS_lcm : S.lcm id = p ^ k) : p ^ k ∈ S" data-docs="For a prime power `p^k`, if a finset `S` of divisors of `p^k` has lcm equal to `p^k`,
then `p^k` must be an element of `S`.

The proof proceeds by contradiction: if `p^k ∉ S`, then every element of `S` is a proper
divisor of `p^k`, hence divides `p^(k-1)`. But then `lcm(S) ∣ p^(k-1) &lt; p^k`, contradicting
that `lcm(S) = p^k`. " title="Crystallographic.Finset.prime_pow_mem_of_lcm_eq {p k : ℕ} (hp : Nat.Prime p) (hk : 0 &lt; k) (S : Finset ℕ)
  (hS_sub : ∀ d ∈ S, d ∣ p ^ k) (hS_lcm : S.lcm id = p ^ k) : p ^ k ∈ S
For a prime power `p^k`, if a finset `S` of divisors of `p^k` has lcm equal to `p^k`,...">Finset.prime_pow_mem_of_lcm_eq</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="ℕ" title="ℕ">p</span> <span class="lean-var" data-type="ℕ" title="ℕ">k</span> : ℕ<span class="lean-bracket-1">}</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span> : <span class="lean-var" data-type="ℕ" title="ℕ">p</span>.<span class="lean-const" data-name="Nat.Prime" data-signature="Nat.Prime (p : ℕ) : Prop" data-docs="`Nat.Prime p` means that `p` is a prime number, that is, a natural number
at least 2 whose only divisors are `p` and `1`.
The theorem `Nat.prime_def` witnesses this description of a prime number. " title="Nat.Prime (p : ℕ) : Prop
`Nat.Prime p` means that `p` is a prime number, that is, a natural number...">Prime</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; k" title="0 &lt; k">hk</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">0</span> &lt; <span class="lean-var" data-type="ℕ" title="ℕ">k</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Finset ℕ" title="Finset ℕ">S</span> : <span class="lean-const" data-name="Finset" data-signature="Finset.{u_4} (α : Type u_4) : Type u_4" data-docs="`Finset α` is the type of finite sets of elements of `α`. It is implemented
as a multiset (a list up to permutation) which has no duplicate elements. " title="Finset.{u_4} (α : Type u_4) : Type u_4
`Finset α` is the type of finite sets of elements of `α`. It is implemented...">Finset</span> ℕ<span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="∀ d ∈ S, d ∣ p ^ k" title="∀ d ∈ S, d ∣ p ^ k">hS_sub</span> : <span class="lean-operator">∀</span> <span class="lean-var" data-type="ℕ" title="ℕ">d</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset ℕ" title="Finset ℕ">S</span>, <span class="lean-var" data-type="ℕ" title="ℕ">d</span> ∣ <span class="lean-var" data-type="ℕ" title="ℕ">p</span> ^ <span class="lean-var" data-type="ℕ" title="ℕ">k</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="S.lcm id = p ^ k" title="S.lcm id = p ^ k">hS_lcm</span> : <span class="lean-var" data-type="Finset ℕ" title="Finset ℕ">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α] (s : Finset β)
  (f : β → α) : α" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α] (s : Finset β)
  (f : β → α) : α
Least common multiple of a finite set ">lcm</span> <span class="lean-const" data-name="id" data-signature="id.{u} {α : Sort u} (a : α) : α" data-docs="The identity function. `id` takes an implicit argument `α : Sort u`
(a type in any universe), and an argument `a : α`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T&#x27;` is definitionally equal to `T`, then `@id T&#x27; e` typechecks, and Lean
knows that this expression has type `T&#x27;` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T&#x27;` may have different
typeclass instances on them. `show T&#x27; from e` is sugar for an `@id T&#x27; e`
expression.
" title="id.{u} {α : Sort u} (a : α) : α
The identity function. `id` takes an implicit argument `α : Sort u`...">id</span> = <span class="lean-var" data-type="ℕ" title="ℕ">p</span> ^ <span class="lean-var" data-type="ℕ" title="ℕ">k</span><span class="lean-bracket-1">)</span> :
    <span class="lean-var" data-type="ℕ" title="ℕ">p</span> ^ <span class="lean-var" data-type="ℕ" title="ℕ">k</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset ℕ" title="Finset ℕ">S</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="`by_contra h` proves `⊢ p` by contradiction,
introducing a hypothesis `h : ¬p` and proving `False`.
* If `p` is a negation `¬q`, `h : q` will be introduced instead of `¬¬q`.
* If `p` is decidable, it uses `Decidable.byContradiction` instead of `Classical.byContradiction`.
* If `h` is omitted, the introduced variable will be called `this`.
" title="`by_contra h` proves `⊢ p` by contradiction,">by_contra</span> <span class="lean-var" data-type="p ^ k ∉ S" title="p ^ k ∉ S">hm_not_in</span>
  <span class="lean-comment">-- All elements of S are proper divisors of p^k, so they divide p^</span><span class="lean-bracket-1">(</span>k-<span class="lean-number">1</span><span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="∀ d ∈ S, d &lt; p ^ k" title="∀ d ∈ S, d &lt; p ^ k">hall_lt</span> : <span class="lean-operator">∀</span> <span class="lean-var" data-type="ℕ" title="ℕ">d</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset ℕ" title="Finset ℕ">S</span>, <span class="lean-var" data-type="ℕ" title="ℕ">d</span> &lt; <span class="lean-var" data-type="ℕ" title="ℕ">p</span> ^ <span class="lean-var" data-type="ℕ" title="ℕ">k</span> := <span class="lean-keyword">fun</span> <span class="lean-var" data-type="ℕ" title="ℕ">d</span> <span class="lean-var" data-type="d ∈ S" title="d ∈ S">hd</span> =&gt;
    <span class="lean-const" data-name="Nat.lt_of_le_of_ne" data-signature="Nat.lt_of_le_of_ne {n m : ℕ} (h₁ : n ≤ m) (h₂ : ¬n = m) : n &lt; m" title="Nat.lt_of_le_of_ne {n m : ℕ} (h₁ : n ≤ m) (h₂ : ¬n = m) : n &lt; m">Nat.lt_of_le_of_ne</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Nat.le_of_dvd" data-signature="Nat.le_of_dvd {m n : ℕ} (h : 0 &lt; n) : m ∣ n → m ≤ n" title="Nat.le_of_dvd {m n : ℕ} (h : 0 &lt; n) : m ∣ n → m ≤ n">Nat.le_of_dvd</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Nat.pow_pos" data-signature="Nat.pow_pos {a n : ℕ} (h : 0 &lt; a) : 0 &lt; a ^ n" title="Nat.pow_pos {a n : ℕ} (h : 0 &lt; a) : 0 &lt; a ^ n">Nat.pow_pos</span> <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span>.<span class="lean-const" data-name="Nat.Prime.pos" data-signature="Nat.Prime.pos {p : ℕ} (pp : Nat.Prime p) : 0 &lt; p" title="Nat.Prime.pos {p : ℕ} (pp : Nat.Prime p) : 0 &lt; p">pos</span><span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-var" data-type="∀ d ∈ S, d ∣ p ^ k" title="∀ d ∈ S, d ∣ p ^ k">hS_sub</span> <span class="lean-var" data-type="ℕ" title="ℕ">d</span> <span class="lean-var" data-type="d ∈ S" title="d ∈ S">hd</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span>
      <span class="lean-bracket-1">(</span><span class="lean-keyword">fun</span> <span class="lean-var" data-type="d = p ^ k" title="d = p ^ k">heq</span> =&gt; <span class="lean-var" data-type="p ^ k ∉ S" title="p ^ k ∉ S">hm_not_in</span> <span class="lean-bracket-2">(</span><span class="lean-var" data-type="d = p ^ k" title="d = p ^ k">heq</span> ▸ <span class="lean-var" data-type="d ∈ S" title="d ∈ S">hd</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="∀ d ∈ S, d ∣ p ^ (k - 1)" title="∀ d ∈ S, d ∣ p ^ (k - 1)">hall_le</span> : <span class="lean-operator">∀</span> <span class="lean-var" data-type="ℕ" title="ℕ">d</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset ℕ" title="Finset ℕ">S</span>, <span class="lean-var" data-type="ℕ" title="ℕ">d</span> ∣ <span class="lean-var" data-type="ℕ" title="ℕ">p</span> ^ <span class="lean-bracket-1">(</span><span class="lean-var" data-type="ℕ" title="ℕ">k</span> - <span class="lean-expr" data-type="ℕ" title="ℕ">1</span><span class="lean-bracket-1">)</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
    <span class="lean-keyword" data-docs="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal&#x27;s target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`. It is equivalent to `intro _`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, given a type ascription, or matched against a pattern:
  ```lean
  -- ... ⊢ α × β → ...
  intro (a, b)
  -- ..., a : α, b : β ⊢ ...
  ```
* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side
  is a variable.
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
" title="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.">intro</span> <span class="lean-var" data-type="ℕ" title="ℕ">d</span> <span class="lean-var" data-type="d ∈ S" title="d ∈ S">hd</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="d ∣ p ^ k" title="d ∣ p ^ k">hdvd</span> := <span class="lean-var" data-type="∀ d ∈ S, d ∣ p ^ k" title="∀ d ∈ S, d ∣ p ^ k">hS_sub</span> <span class="lean-var" data-type="ℕ" title="ℕ">d</span> <span class="lean-var" data-type="d ∈ S" title="d ∈ S">hd</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="d &lt; p ^ k" title="d &lt; p ^ k">hd_lt</span> := <span class="lean-var" data-type="∀ d ∈ S, d &lt; p ^ k" title="∀ d ∈ S, d &lt; p ^ k">hall_lt</span> <span class="lean-var" data-type="ℕ" title="ℕ">d</span> <span class="lean-var" data-type="d ∈ S" title="d ∈ S">hd</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="Prime p" title="Prime p">hpr</span> : <span class="lean-const" data-name="Prime" data-signature="Prime.{u_1} {M : Type u_1} [CommMonoidWithZero M] (p : M) : Prop" data-docs="An element `p` of a commutative monoid with zero (e.g., a ring) is called *prime*,
if it&#x27;s not zero, not a unit, and `p ∣ a * b → p ∣ a ∨ p ∣ b` for all `a`, `b`. " title="Prime.{u_1} {M : Type u_1} [CommMonoidWithZero M] (p : M) : Prop
An element `p` of a commutative monoid with zero (e.g., a ring) is called *prime*,...">Prime</span> <span class="lean-var" data-type="ℕ" title="ℕ">p</span> := <span class="lean-const" data-name="Nat.Prime.prime" data-signature="Nat.Prime.prime {p : ℕ} : Nat.Prime p → Prime p" data-docs="**Alias** of the forward direction of `Nat.prime_iff`." title="Nat.Prime.prime {p : ℕ} : Nat.Prime p → Prime p
**Alias** of the forward direction of `Nat.prime_iff`.">Nat.Prime.prime</span> <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="dvd_prime_pow" data-signature="dvd_prime_pow.{u_1} {M : Type u_1} [CancelCommMonoidWithZero M] {p q : M} (hp : Prime p) (n : ℕ) :
  q ∣ p ^ n ↔ ∃ i ≤ n, Associated q (p ^ i)" title="dvd_prime_pow.{u_1} {M : Type u_1} [CancelCommMonoidWithZero M] {p q : M} (hp : Prime p) (n : ℕ) :
  q ∣ p ^ n ↔ ∃ i ≤ n, Associated q (p ^ i)">dvd_prime_pow</span> <span class="lean-var" data-type="Prime p" title="Prime p">hpr</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`
* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="d ∣ p ^ k" title="d ∣ p ^ k">hdvd</span>
    <span class="lean-keyword" data-docs="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for
a description of supported patterns.

```lean
obtain ⟨patt⟩ : type := proof
```
is equivalent to
```lean
have h : type := proof
rcases h with ⟨patt⟩
```

If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.

If `type` is omitted, `:= proof` is required.
" title="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for">obtain</span> <span class="lean-bracket-1">⟨</span><span class="lean-var" data-type="ℕ" title="ℕ">j</span>, _, <span class="lean-var" data-type="Associated d (p ^ j)" title="Associated d (p ^ j)">hassoc</span><span class="lean-bracket-1">⟩</span> := <span class="lean-var" data-type="∃ i ≤ k, Associated d (p ^ i)" title="∃ i ≤ k, Associated d (p ^ i)">hdvd</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="d = p ^ j" title="d = p ^ j">hd_eq</span> := <span class="lean-const" data-name="associated_iff_eq" data-signature="associated_iff_eq.{u_1} {M : Type u_1} [Monoid M] [Subsingleton Mˣ] {x y : M} : Associated x y ↔ x = y" title="associated_iff_eq.{u_1} {M : Type u_1} [Monoid M] [Subsingleton Mˣ] {x y : M} : Associated x y ↔ x = y">associated_iff_eq</span>.<span class="lean-const" data-name="Iff.mp" data-signature="Iff.mp {a b : Prop} (self : a ↔ b) : a → b" data-docs="Modus ponens for if and only if. If `a ↔ b` and `a`, then `b`. " title="Iff.mp {a b : Prop} (self : a ↔ b) : a → b
Modus ponens for if and only if. If `a ↔ b` and `a`, then `b`. ">mp</span> <span class="lean-var" data-type="Associated d (p ^ j)" title="Associated d (p ^ j)">hassoc</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="d = p ^ j" title="d = p ^ j">hd_eq</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`
* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="d &lt; p ^ k" title="d &lt; p ^ k">hd_lt</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="j &lt; k" title="j &lt; k">hj_lt</span> : <span class="lean-var" data-type="ℕ" title="ℕ">j</span> &lt; <span class="lean-var" data-type="ℕ" title="ℕ">k</span> := <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Nat.pow_lt_pow_iff_right" data-signature="Nat.pow_lt_pow_iff_right {a n m : ℕ} (h : 1 &lt; a) : a ^ n &lt; a ^ m ↔ n &lt; m" title="Nat.pow_lt_pow_iff_right {a n m : ℕ} (h : 1 &lt; a) : a ^ n &lt; a ^ m ↔ n &lt; m">Nat.pow_lt_pow_iff_right</span> <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span>.<span class="lean-const" data-name="Nat.Prime.one_lt" data-signature="Nat.Prime.one_lt {p : ℕ} : Nat.Prime p → 1 &lt; p" title="Nat.Prime.one_lt {p : ℕ} : Nat.Prime p → 1 &lt; p">one_lt</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Iff.mp" data-signature="Iff.mp {a b : Prop} (self : a ↔ b) : a → b" data-docs="Modus ponens for if and only if. If `a ↔ b` and `a`, then `b`. " title="Iff.mp {a b : Prop} (self : a ↔ b) : a → b
Modus ponens for if and only if. If `a ↔ b` and `a`, then `b`. ">mp</span> <span class="lean-var" data-type="p ^ j &lt; p ^ k" title="p ^ j &lt; p ^ k">hd_lt</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="j ≤ k - 1" title="j ≤ k - 1">hj_le</span> : <span class="lean-var" data-type="ℕ" title="ℕ">j</span> <span class="lean-operator">≤</span> <span class="lean-var" data-type="ℕ" title="ℕ">k</span> - <span class="lean-expr" data-type="ℕ" title="ℕ">1</span> := <span class="lean-const" data-name="Nat.lt_succ_iff" data-signature="Nat.lt_succ_iff {m n : ℕ} : m &lt; n.succ ↔ m ≤ n" title="Nat.lt_succ_iff {m n : ℕ} : m &lt; n.succ ↔ m ≤ n">Nat.lt_succ_iff</span>.<span class="lean-const" data-name="Iff.mp" data-signature="Iff.mp {a b : Prop} (self : a ↔ b) : a → b" data-docs="Modus ponens for if and only if. If `a ↔ b` and `a`, then `b`. " title="Iff.mp {a b : Prop} (self : a ↔ b) : a → b
Modus ponens for if and only if. If `a ↔ b` and `a`, then `b`. ">mp</span> <span class="lean-bracket-1">(</span><span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span><span class="lean-bracket-1">)</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="d = p ^ j" title="d = p ^ j">hd_eq</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Nat.pow_dvd_pow" data-signature="Nat.pow_dvd_pow {m n : ℕ} (a : ℕ) (h : m ≤ n) : a ^ m ∣ a ^ n" title="Nat.pow_dvd_pow {m n : ℕ} (a : ℕ) (h : m ≤ n) : a ^ m ∣ a ^ n">Nat.pow_dvd_pow</span> <span class="lean-var" data-type="ℕ" title="ℕ">p</span> <span class="lean-var" data-type="j ≤ k - 1" title="j ≤ k - 1">hj_le</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="S.lcm id ∣ p ^ (k - 1)" title="S.lcm id ∣ p ^ (k - 1)">hlcm_le</span> : <span class="lean-var" data-type="Finset ℕ" title="Finset ℕ">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α] (s : Finset β)
  (f : β → α) : α" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α] (s : Finset β)
  (f : β → α) : α
Least common multiple of a finite set ">lcm</span> <span class="lean-const" data-name="id" data-signature="id.{u} {α : Sort u} (a : α) : α" data-docs="The identity function. `id` takes an implicit argument `α : Sort u`
(a type in any universe), and an argument `a : α`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T&#x27;` is definitionally equal to `T`, then `@id T&#x27; e` typechecks, and Lean
knows that this expression has type `T&#x27;` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T&#x27;` may have different
typeclass instances on them. `show T&#x27; from e` is sugar for an `@id T&#x27; e`
expression.
" title="id.{u} {α : Sort u} (a : α) : α
The identity function. `id` takes an implicit argument `α : Sort u`...">id</span> ∣ <span class="lean-var" data-type="ℕ" title="ℕ">p</span> ^ <span class="lean-bracket-1">(</span><span class="lean-var" data-type="ℕ" title="ℕ">k</span> - <span class="lean-expr" data-type="ℕ" title="ℕ">1</span><span class="lean-bracket-1">)</span> := <span class="lean-const" data-name="Finset.lcm_dvd_iff" data-signature="Finset.lcm_dvd_iff.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α]
  {s : Finset β} {f : β → α} {a : α} : s.lcm f ∣ a ↔ ∀ b ∈ s, f b ∣ a" title="Finset.lcm_dvd_iff.{u_2, u_3} {α : Type u_2} {β : Type u_3} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α]
  {s : Finset β} {f : β → α} {a : α} : s.lcm f ∣ a ↔ ∀ b ∈ s, f b ∣ a">Finset.lcm_dvd_iff</span>.<span class="lean-const" data-name="Iff.mpr" data-signature="Iff.mpr {a b : Prop} (self : a ↔ b) : b → a" data-docs="Modus ponens for if and only if, reversed. If `a ↔ b` and `b`, then `a`. " title="Iff.mpr {a b : Prop} (self : a ↔ b) : b → a
Modus ponens for if and only if, reversed. If `a ↔ b` and `b`, then `a`. ">mpr</span> <span class="lean-bracket-1">(</span><span class="lean-keyword">fun</span> <span class="lean-var" data-type="ℕ" title="ℕ">d</span> <span class="lean-var" data-type="d ∈ S" title="d ∈ S">hd</span> =&gt; <span class="lean-var" data-type="∀ d ∈ S, d ∣ p ^ (k - 1)" title="∀ d ∈ S, d ∣ p ^ (k - 1)">hall_le</span> <span class="lean-var" data-type="ℕ" title="ℕ">d</span> <span class="lean-var" data-type="d ∈ S" title="d ∈ S">hd</span><span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="S.lcm id = p ^ k" title="S.lcm id = p ^ k">hS_lcm</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`
* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="S.lcm id ∣ p ^ (k - 1)" title="S.lcm id ∣ p ^ (k - 1)">hlcm_le</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="p ^ k ≤ p ^ (k - 1)" title="p ^ k ≤ p ^ (k - 1)">hle</span> : <span class="lean-var" data-type="ℕ" title="ℕ">p</span> ^ <span class="lean-var" data-type="ℕ" title="ℕ">k</span> <span class="lean-operator">≤</span> <span class="lean-var" data-type="ℕ" title="ℕ">p</span> ^ <span class="lean-bracket-1">(</span><span class="lean-var" data-type="ℕ" title="ℕ">k</span> - <span class="lean-expr" data-type="ℕ" title="ℕ">1</span><span class="lean-bracket-1">)</span> := <span class="lean-const" data-name="Nat.le_of_dvd" data-signature="Nat.le_of_dvd {m n : ℕ} (h : 0 &lt; n) : m ∣ n → m ≤ n" title="Nat.le_of_dvd {m n : ℕ} (h : 0 &lt; n) : m ∣ n → m ≤ n">Nat.le_of_dvd</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Nat.pow_pos" data-signature="Nat.pow_pos {a n : ℕ} (h : 0 &lt; a) : 0 &lt; a ^ n" title="Nat.pow_pos {a n : ℕ} (h : 0 &lt; a) : 0 &lt; a ^ n">Nat.pow_pos</span> <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span>.<span class="lean-const" data-name="Nat.Prime.pos" data-signature="Nat.Prime.pos {p : ℕ} (pp : Nat.Prime p) : 0 &lt; p" title="Nat.Prime.pos {p : ℕ} (pp : Nat.Prime p) : 0 &lt; p">pos</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="p ^ k ∣ p ^ (k - 1)" title="p ^ k ∣ p ^ (k - 1)">hlcm_le</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="p ^ (k - 1) &lt; p ^ k" title="p ^ (k - 1) &lt; p ^ k">hpow_strict</span> : <span class="lean-var" data-type="ℕ" title="ℕ">p</span> ^ <span class="lean-bracket-1">(</span><span class="lean-var" data-type="ℕ" title="ℕ">k</span> - <span class="lean-expr" data-type="ℕ" title="ℕ">1</span><span class="lean-bracket-1">)</span> &lt; <span class="lean-var" data-type="ℕ" title="ℕ">p</span> ^ <span class="lean-var" data-type="ℕ" title="ℕ">k</span> :=
    <span class="lean-const" data-name="Nat.pow_lt_pow_right" data-signature="Nat.pow_lt_pow_right {a m n : ℕ} (ha : 1 &lt; a) (h : m &lt; n) : a ^ m &lt; a ^ n" title="Nat.pow_lt_pow_right {a m n : ℕ} (ha : 1 &lt; a) (h : m &lt; n) : a ^ m &lt; a ^ n">Nat.pow_lt_pow_right</span> <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span>.<span class="lean-const" data-name="Nat.Prime.one_lt" data-signature="Nat.Prime.one_lt {p : ℕ} : Nat.Prime p → 1 &lt; p" title="Nat.Prime.one_lt {p : ℕ} : Nat.Prime p → 1 &lt; p">one_lt</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Nat.sub_lt" data-signature="Nat.sub_lt {n m : ℕ} : 0 &lt; n → 0 &lt; m → n - m &lt; n" title="Nat.sub_lt {n m : ℕ} : 0 &lt; n → 0 &lt; m → n - m &lt; n">Nat.sub_lt</span> <span class="lean-var" data-type="0 &lt; k" title="0 &lt; k">hk</span> <span class="lean-const" data-name="Nat.one_pos" data-signature="Nat.one_pos : 0 &lt; 1" data-docs="Alias for `Nat.zero_lt_one`. " title="Nat.one_pos : 0 &lt; 1
Alias for `Nat.zero_lt_one`. ">Nat.one_pos</span><span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/Lemmas.lean#L114-L151" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:primePow-mem-of-lcm-eq');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:totient-ge-two">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">A.0.4</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0006.html#lem:totient-ge-two">#</a>
    
    <a class="icon proof" href="sect0006.html#a0000000066"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.two_le_totient_of_two_lt" class="lean_decl">Crystallographic.two_le_totient_of_two_lt</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       For \(n {\gt} 2\), we have \(\varphi (n) \geq 2\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000066">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>Since \(n {\gt} 2\), we have \(n \neq 1\) and \(n \neq 2\). By the fact that \(\varphi (n) = 1\) if and only if \(n \in \{ 1, 2\} \), we conclude that \(\varphi (n) \neq 1\). Also \(\varphi (n) \neq 0\) since \(n {\gt} 0\). Therefore \(\varphi (n) \geq 2\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">theorem</span> <span class="lean-const lean-def" data-name="Crystallographic.two_le_totient_of_two_lt" data-signature="Crystallographic.two_le_totient_of_two_lt (n : ℕ) (hn : 2 &lt; n) : 2 ≤ n.totient" data-docs="Euler&#x27;s totient function is at least 2 for any n &gt; 2. " title="Crystallographic.two_le_totient_of_two_lt (n : ℕ) (hn : 2 &lt; n) : 2 ≤ n.totient
Euler&#x27;s totient function is at least 2 for any n &gt; 2. ">two_le_totient_of_two_lt</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="ℕ" title="ℕ">n</span> : ℕ<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="2 &lt; n" title="2 &lt; n">hn</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">2</span> &lt; <span class="lean-var" data-type="ℕ" title="ℕ">n</span><span class="lean-bracket-1">)</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">2</span> <span class="lean-operator">≤</span> <span class="lean-const" data-name="Nat.totient" data-signature="Nat.totient (n : ℕ) : ℕ" data-docs="Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are
coprime with `n`. " title="Nat.totient (n : ℕ) : ℕ
Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are...">Nat.totient</span> <span class="lean-var" data-type="ℕ" title="ℕ">n</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> := <span class="lean-const" data-name="Nat.totient_pos" data-signature="Nat.totient_pos {n : ℕ} : 0 &lt; n.totient ↔ 0 &lt; n" title="Nat.totient_pos {n : ℕ} : 0 &lt; n.totient ↔ 0 &lt; n">Nat.totient_pos</span>.<span class="lean-const" data-name="Iff.mpr" data-signature="Iff.mpr {a b : Prop} (self : a ↔ b) : b → a" data-docs="Modus ponens for if and only if, reversed. If `a ↔ b` and `b`, then `a`. " title="Iff.mpr {a b : Prop} (self : a ↔ b) : b → a
Modus ponens for if and only if, reversed. If `a ↔ b` and `b`, then `a`. ">mpr</span> <span class="lean-bracket-1">(</span><span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span> : <span class="lean-number">0</span> &lt; n<span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> := <span class="lean-const" data-name="Nat.totient_eq_one_iff" data-signature="Nat.totient_eq_one_iff {n : ℕ} : n.totient = 1 ↔ n = 1 ∨ n = 2" title="Nat.totient_eq_one_iff {n : ℕ} : n.totient = 1 ↔ n = 1 ∨ n = 2">Nat.totient_eq_one_iff</span>.<span class="lean-const" data-name="Iff.not" data-signature="Iff.not {a b : Prop} (h : a ↔ b) : ¬a ↔ ¬b" data-docs="**Alias** of `not_congr`." title="Iff.not {a b : Prop} (h : a ↔ b) : ¬a ↔ ¬b
**Alias** of `not_congr`.">not</span>.<span class="lean-const" data-name="Iff.mpr" data-signature="Iff.mpr {a b : Prop} (self : a ↔ b) : b → a" data-docs="Modus ponens for if and only if, reversed. If `a ↔ b` and `b`, then `a`. " title="Iff.mpr {a b : Prop} (self : a ↔ b) : b → a
Modus ponens for if and only if, reversed. If `a ↔ b` and `b`, then `a`. ">mpr</span> <span class="lean-bracket-1">(</span><span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span> : <span class="lean-operator">¬</span><span class="lean-bracket-2">(</span>n = <span class="lean-number">1</span> <span class="lean-operator">∨</span> n = <span class="lean-number">2</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/Lemmas.lean#L155-L165" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:totient-ge-two');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:prod-coprime-dvd">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">A.0.5</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0006.html#lem:prod-coprime-dvd">#</a>
    
    <a class="icon proof" href="sect0006.html#a0000000067"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Finset.prod_coprime_dvd" class="lean_decl">Finset.prod_coprime_dvd</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       If each \(f(a)\) divides \(d\) and the \(f(a)\) are pairwise coprime, then \(\prod _{a \in S} f(a)\) divides \(d\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000067">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By induction on the finite set. Empty case: \(1 \mid d\) trivially. Insert case: we have \(f(q) \mid d\) and \(\prod _{s'} f(r) \mid d\) by IH. Show \(f(q)\) is coprime to \(\prod _{s'} f(r)\) using ‘Nat.Coprime.prod_right‘, then apply ‘Nat.Coprime.mul_dvd_of_dvd_of_dvd‘. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">theorem</span> <span class="lean-const lean-def" data-name="Finset.prod_coprime_dvd" data-signature="Finset.prod_coprime_dvd.{u_1} {α : Type u_1} [DecidableEq α] (S : Finset α) (f : α → ℕ) (d : ℕ)
  (h_dvd : ∀ a ∈ S, f a ∣ d) (h_coprime : ∀ a₁ ∈ S, ∀ a₂ ∈ S, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)) : ∏ a ∈ S, f a ∣ d" data-docs="If each f(a) divides d and they&#x27;re pairwise coprime, then ∏ f(a) divides d. " title="Finset.prod_coprime_dvd.{u_1} {α : Type u_1} [DecidableEq α] (S : Finset α) (f : α → ℕ) (d : ℕ)
  (h_dvd : ∀ a ∈ S, f a ∣ d) (h_coprime : ∀ a₁ ∈ S, ∀ a₂ ∈ S, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)) : ∏ a ∈ S, f a ∣ d
If each f(a) divides d and they&#x27;re pairwise coprime, then ∏ f(a) divides d. ">prod_coprime_dvd</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="Type u_1" title="Type u_1">α</span> : <span class="lean-sort" data-docs="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable
`&gt; 0` for each variable in the sequence. " title="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable">Type*</span><span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="DecidableEq" data-signature="DecidableEq.{u} (α : Sort u) : Sort (max 1 u)" data-docs="Propositional equality is `Decidable` for all elements of a type.

In other words, an instance of `DecidableEq α` is a means of deciding the proposition `a = b` is
for all `a b : α`.
" title="DecidableEq.{u} (α : Sort u) : Sort (max 1 u)
Propositional equality is `Decidable` for all elements of a type....">DecidableEq</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">α</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Finset α" title="Finset α">S</span> : <span class="lean-const" data-name="Finset" data-signature="Finset.{u_4} (α : Type u_4) : Type u_4" data-docs="`Finset α` is the type of finite sets of elements of `α`. It is implemented
as a multiset (a list up to permutation) which has no duplicate elements. " title="Finset.{u_4} (α : Type u_4) : Type u_4
`Finset α` is the type of finite sets of elements of `α`. It is implemented...">Finset</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">α</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> : <span class="lean-var" data-type="Type u_1" title="Type u_1">α</span> <span class="lean-operator">→</span> ℕ<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="ℕ" title="ℕ">d</span> : ℕ<span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="∀ a ∈ S, f a ∣ d" title="∀ a ∈ S, f a ∣ d">h_dvd</span> : <span class="lean-operator">∀</span> <span class="lean-var" data-type="α" title="α">a</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">S</span>, <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">a</span> ∣ <span class="lean-var" data-type="ℕ" title="ℕ">d</span><span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="∀ a₁ ∈ S, ∀ a₂ ∈ S, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)" title="∀ a₁ ∈ S, ∀ a₂ ∈ S, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)">h_coprime</span> : <span class="lean-operator">∀</span> <span class="lean-var" data-type="α" title="α">a₁</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">S</span>, <span class="lean-operator">∀</span> <span class="lean-var" data-type="α" title="α">a₂</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">S</span>, <span class="lean-var" data-type="α" title="α">a₁</span> <span class="lean-operator">≠</span> <span class="lean-var" data-type="α" title="α">a₂</span> <span class="lean-operator">→</span> <span class="lean-bracket-2">(</span><span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">a₁</span><span class="lean-bracket-2">)</span>.<span class="lean-const" data-name="Nat.Coprime" data-signature="Nat.Coprime (m n : ℕ) : Prop" data-docs="`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. " title="Nat.Coprime (m n : ℕ) : Prop
`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. ">Coprime</span> <span class="lean-bracket-2">(</span><span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">a₂</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span> :
    <span class="lean-bracket-1">(</span><span class="lean-operator">∏</span> <span class="lean-var" data-type="α" title="α">a</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">S</span>, <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">a</span><span class="lean-bracket-1">)</span> ∣ <span class="lean-var" data-type="ℕ" title="ℕ">d</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="Assuming `x` is a variable in the local context with an inductive type,
`induction x` applies induction on `x` to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on `x`,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,
`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,
and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.
Here the names `a` and `ih₁` are chosen automatically and are not accessible.
You can use `with` to provide the variables names for each constructor.
- `induction e`, where `e` is an expression instead of a variable,
  generalizes `e` in the goal, and then performs induction on the resulting variable.
- `induction e using r` allows the user to specify the principle of induction that should be used.
  Here `r` should be a term whose result type must be of the form `C t`,
  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables
- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,
  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.
  In other words, the net effect is that each inductive hypothesis is generalized.
- Given `x : Nat`, `induction x with | zero =&gt; tac₁ | succ x&#x27; ih =&gt; tac₂`
  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.
" title="Assuming `x` is a variable in the local context with an inductive type,">induction</span> <span class="lean-var" data-type="Finset α" title="Finset α">S</span> <span class="lean-keyword">using</span> <span class="lean-const" data-name="Finset.induction" data-signature="Finset.induction.{u_3} {α : Type u_3} {motive : Finset α → Prop} [DecidableEq α] (empty : motive ∅)
  (insert : ∀ (a : α) (s : Finset α), a ∉ s → motive s → motive (insert a s)) (s : Finset α) : motive s" title="Finset.induction.{u_3} {α : Type u_3} {motive : Finset α → Prop} [DecidableEq α] (empty : motive ∅)
  (insert : ∀ (a : α) (s : Finset α), a ∉ s → motive s → motive (insert a s)) (s : Finset α) : motive s">Finset.induction</span> <span class="lean-keyword" data-docs="After `with`, there is an optional tactic that runs on all branches, and
then a list of alternatives.
" title="After `with`, there is an optional tactic that runs on all branches, and">with</span>
  | <span class="lean-const" data-name="Finset.empty" data-signature="Finset.empty.{u_1} {α : Type u_1} : Finset α" data-docs="The empty finset " title="Finset.empty.{u_1} {α : Type u_1} : Finset α
The empty finset ">empty</span> =&gt; <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions.-
- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.
- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idᵢ`.
- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If
  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis
  `hᵢ` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span>
  | @insert <span class="lean-var" data-type="α" title="α">q</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span> <span class="lean-var" data-type="q ∉ s&#x27;" title="q ∉ s&#x27;">hq_notin</span> <span class="lean-var" data-type="(∀ a ∈ s&#x27;, f a ∣ d) → (∀ a₁ ∈ s&#x27;, ∀ a₂ ∈ s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)) → ∏ a ∈ s&#x27;, f a ∣ d" title="(∀ a ∈ s&#x27;, f a ∣ d) → (∀ a₁ ∈ s&#x27;, ∀ a₂ ∈ s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)) → ∏ a ∈ s&#x27;, f a ∣ d">IH</span> =&gt;
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Finset.prod_insert" data-signature="Finset.prod_insert.{u_1, u_4} {ι : Type u_1} {M : Type u_4} {s : Finset ι} {a : ι} [CommMonoid M] {f : ι → M}
  [DecidableEq ι] : a ∉ s → ∏ x ∈ insert a s, f x = f a * ∏ x ∈ s, f x" title="Finset.prod_insert.{u_1, u_4} {ι : Type u_1} {M : Type u_4} {s : Finset ι} {a : ι} [CommMonoid M] {f : ι → M}
  [DecidableEq ι] : a ∉ s → ∏ x ∈ insert a s, f x = f a * ∏ x ∈ s, f x">Finset.prod_insert</span> <span class="lean-var" data-type="q ∉ s&#x27;" title="q ∉ s&#x27;">hq_notin</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="f q ∣ d" title="f q ∣ d">hq_dvd</span> : <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">q</span> ∣ <span class="lean-var" data-type="ℕ" title="ℕ">d</span> := <span class="lean-var" data-type="∀ a ∈ insert q s&#x27;, f a ∣ d" title="∀ a ∈ insert q s&#x27;, f a ∣ d">h_dvd</span> <span class="lean-var" data-type="α" title="α">q</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_insert_self" data-signature="Finset.mem_insert_self.{u_1} {α : Type u_1} [DecidableEq α] (a : α) (s : Finset α) : a ∈ insert a s" title="Finset.mem_insert_self.{u_1} {α : Type u_1} [DecidableEq α] (a : α) (s : Finset α) : a ∈ insert a s">Finset.mem_insert_self</span> <span class="lean-var" data-type="α" title="α">q</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span><span class="lean-bracket-1">)</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="∏ r ∈ s&#x27;, f r ∣ d" title="∏ r ∈ s&#x27;, f r ∣ d">hs&#x27;_dvd</span> : <span class="lean-bracket-1">(</span><span class="lean-operator">∏</span> <span class="lean-var" data-type="α" title="α">r</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span>, <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">r</span><span class="lean-bracket-1">)</span> ∣ <span class="lean-var" data-type="ℕ" title="ℕ">d</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
      <span class="lean-keyword" data-docs="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.
" title="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.">apply</span> <span class="lean-var" data-type="(∀ a ∈ s&#x27;, f a ∣ d) → (∀ a₁ ∈ s&#x27;, ∀ a₂ ∈ s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)) → ∏ a ∈ s&#x27;, f a ∣ d" title="(∀ a ∈ s&#x27;, f a ∣ d) → (∀ a₁ ∈ s&#x27;, ∀ a₂ ∈ s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)) → ∏ a ∈ s&#x27;, f a ∣ d">IH</span>
      <span class="lean-operator">·</span> <span class="lean-keyword" data-docs="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal&#x27;s target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`. It is equivalent to `intro _`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, given a type ascription, or matched against a pattern:
  ```lean
  -- ... ⊢ α × β → ...
  intro (a, b)
  -- ..., a : α, b : β ⊢ ...
  ```
* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side
  is a variable.
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
" title="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.">intro</span> <span class="lean-var" data-type="α" title="α">r</span> <span class="lean-var" data-type="r ∈ s&#x27;" title="r ∈ s&#x27;">hr</span>; <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-var" data-type="∀ a ∈ insert q s&#x27;, f a ∣ d" title="∀ a ∈ insert q s&#x27;, f a ∣ d">h_dvd</span> <span class="lean-var" data-type="α" title="α">r</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_insert_of_mem" data-signature="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s" title="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s">Finset.mem_insert_of_mem</span> <span class="lean-var" data-type="r ∈ s&#x27;" title="r ∈ s&#x27;">hr</span><span class="lean-bracket-1">)</span>
      <span class="lean-operator">·</span> <span class="lean-keyword" data-docs="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal&#x27;s target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`. It is equivalent to `intro _`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, given a type ascription, or matched against a pattern:
  ```lean
  -- ... ⊢ α × β → ...
  intro (a, b)
  -- ..., a : α, b : β ⊢ ...
  ```
* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side
  is a variable.
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
" title="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.">intro</span> <span class="lean-var" data-type="α" title="α">a₁</span> <span class="lean-var" data-type="a₁ ∈ s&#x27;" title="a₁ ∈ s&#x27;">ha₁</span> <span class="lean-var" data-type="α" title="α">a₂</span> <span class="lean-var" data-type="a₂ ∈ s&#x27;" title="a₂ ∈ s&#x27;">ha₂</span> <span class="lean-var" data-type="a₁ ≠ a₂" title="a₁ ≠ a₂">hne</span>
        <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-var" data-type="∀ a₁ ∈ insert q s&#x27;, ∀ a₂ ∈ insert q s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)" title="∀ a₁ ∈ insert q s&#x27;, ∀ a₂ ∈ insert q s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)">h_coprime</span> <span class="lean-var" data-type="α" title="α">a₁</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_insert_of_mem" data-signature="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s" title="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s">Finset.mem_insert_of_mem</span> <span class="lean-var" data-type="a₁ ∈ s&#x27;" title="a₁ ∈ s&#x27;">ha₁</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="α" title="α">a₂</span>
          <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_insert_of_mem" data-signature="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s" title="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s">Finset.mem_insert_of_mem</span> <span class="lean-var" data-type="a₂ ∈ s&#x27;" title="a₂ ∈ s&#x27;">ha₂</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="a₁ ≠ a₂" title="a₁ ≠ a₂">hne</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(f q).Coprime (∏ r ∈ s&#x27;, f r)" title="(f q).Coprime (∏ r ∈ s&#x27;, f r)">h_cop</span> : <span class="lean-bracket-1">(</span><span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">q</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Nat.Coprime" data-signature="Nat.Coprime (m n : ℕ) : Prop" data-docs="`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. " title="Nat.Coprime (m n : ℕ) : Prop
`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. ">Coprime</span> <span class="lean-bracket-1">(</span><span class="lean-operator">∏</span> <span class="lean-var" data-type="α" title="α">r</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span>, <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">r</span><span class="lean-bracket-1">)</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
      <span class="lean-keyword" data-docs="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.
" title="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.">apply</span> <span class="lean-const" data-name="Nat.Coprime.prod_right" data-signature="Nat.Coprime.prod_right.{u_1} {ι : Type u_1} {x : ℕ} {t : Finset ι} {s : ι → ℕ} :
  (∀ i ∈ t, x.Coprime (s i)) → x.Coprime (∏ i ∈ t, s i)" data-docs="See `IsCoprime.prod_right` for the corresponding lemma about `IsCoprime` " title="Nat.Coprime.prod_right.{u_1} {ι : Type u_1} {x : ℕ} {t : Finset ι} {s : ι → ℕ} :
  (∀ i ∈ t, x.Coprime (s i)) → x.Coprime (∏ i ∈ t, s i)
See `IsCoprime.prod_right` for the corresponding lemma about `IsCoprime` ">Nat.Coprime.prod_right</span>
      <span class="lean-keyword" data-docs="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal&#x27;s target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`. It is equivalent to `intro _`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, given a type ascription, or matched against a pattern:
  ```lean
  -- ... ⊢ α × β → ...
  intro (a, b)
  -- ..., a : α, b : β ⊢ ...
  ```
* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side
  is a variable.
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
" title="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.">intro</span> <span class="lean-var" data-type="α" title="α">r</span> <span class="lean-var" data-type="r ∈ s&#x27;" title="r ∈ s&#x27;">hr</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="q ≠ r" title="q ≠ r">hne</span> : <span class="lean-var" data-type="α" title="α">q</span> <span class="lean-operator">≠</span> <span class="lean-var" data-type="α" title="α">r</span> := <span class="lean-keyword">fun</span> <span class="lean-var" data-type="q = r" title="q = r">heq</span> =&gt; <span class="lean-var" data-type="q ∉ s&#x27;" title="q ∉ s&#x27;">hq_notin</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="q = r" title="q = r">heq</span> ▸ <span class="lean-var" data-type="r ∈ s&#x27;" title="r ∈ s&#x27;">hr</span><span class="lean-bracket-1">)</span>
      <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-var" data-type="∀ a₁ ∈ insert q s&#x27;, ∀ a₂ ∈ insert q s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)" title="∀ a₁ ∈ insert q s&#x27;, ∀ a₂ ∈ insert q s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)">h_coprime</span> <span class="lean-var" data-type="α" title="α">q</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_insert_self" data-signature="Finset.mem_insert_self.{u_1} {α : Type u_1} [DecidableEq α] (a : α) (s : Finset α) : a ∈ insert a s" title="Finset.mem_insert_self.{u_1} {α : Type u_1} [DecidableEq α] (a : α) (s : Finset α) : a ∈ insert a s">Finset.mem_insert_self</span> <span class="lean-var" data-type="α" title="α">q</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="α" title="α">r</span>
        <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_insert_of_mem" data-signature="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s" title="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s">Finset.mem_insert_of_mem</span> <span class="lean-var" data-type="r ∈ s&#x27;" title="r ∈ s&#x27;">hr</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="q ≠ r" title="q ≠ r">hne</span>
    <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-var" data-type="(f q).Coprime (∏ r ∈ s&#x27;, f r)" title="(f q).Coprime (∏ r ∈ s&#x27;, f r)">h_cop</span>.<span class="lean-const" data-name="Nat.Coprime.mul_dvd_of_dvd_of_dvd" data-signature="Nat.Coprime.mul_dvd_of_dvd_of_dvd {m n a : ℕ} (hmn : m.Coprime n) (hm : m ∣ a) (hn : n ∣ a) : m * n ∣ a" title="Nat.Coprime.mul_dvd_of_dvd_of_dvd {m n a : ℕ} (hmn : m.Coprime n) (hm : m ∣ a) (hn : n ∣ a) : m * n ∣ a">mul_dvd_of_dvd_of_dvd</span> <span class="lean-var" data-type="f q ∣ d" title="f q ∣ d">hq_dvd</span> <span class="lean-var" data-type="∏ r ∈ s&#x27;, f r ∣ d" title="∏ r ∈ s&#x27;, f r ∣ d">hs&#x27;_dvd</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/Lemmas.lean#L173-L202" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:prod-coprime-dvd');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:totient-prod-coprime">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">A.0.6</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0006.html#lem:totient-prod-coprime">#</a>
    
    <a class="icon proof" href="sect0006.html#a0000000068"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Nat.totient_finset_prod_of_coprime" class="lean_decl">Nat.totient_finset_prod_of_coprime</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       For pairwise coprime \(\{ f(a)\} _{a \in S}\), we have \(\varphi (\prod _{a \in S} f(a)) = \prod _{a \in S} \varphi (f(a))\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000068">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By induction on the finite set. Empty case: \(\varphi (1) = 1\) equals empty product. Insert case: use \(\varphi (ab) = \varphi (a)\varphi (b)\) for coprime \(a, b\) (‘Nat.totient_mul‘), where coprimality follows from ‘Nat.Coprime.prod_right‘. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">theorem</span> <span class="lean-const lean-def" data-name="Nat.totient_finset_prod_of_coprime" data-signature="Nat.totient_finset_prod_of_coprime.{u_1} {α : Type u_1} [DecidableEq α] (S : Finset α) (f : α → ℕ)
  (h_coprime : ∀ a₁ ∈ S, ∀ a₂ ∈ S, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)) : φ (∏ a ∈ S, f a) = ∏ a ∈ S, φ (f a)" data-docs="Euler&#x27;s totient function distributes over products of pairwise coprime values.

This generalizes `Nat.totient_mul` from binary products to arbitrary finite products.
The proof proceeds by induction: at each step, we use that the new element is coprime
to the product of the previous elements (via `Nat.Coprime.prod_right`), then apply
the binary `Nat.totient_mul`.

For upstreaming to Mathlib, this should be placed in `Mathlib.Data.Nat.Totient`. " title="Nat.totient_finset_prod_of_coprime.{u_1} {α : Type u_1} [DecidableEq α] (S : Finset α) (f : α → ℕ)
  (h_coprime : ∀ a₁ ∈ S, ∀ a₂ ∈ S, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)) : φ (∏ a ∈ S, f a) = ∏ a ∈ S, φ (f a)
Euler&#x27;s totient function distributes over products of pairwise coprime values....">totient_finset_prod_of_coprime</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="Type u_1" title="Type u_1">α</span> : <span class="lean-sort" data-docs="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable
`&gt; 0` for each variable in the sequence. " title="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable">Type*</span><span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="DecidableEq" data-signature="DecidableEq.{u} (α : Sort u) : Sort (max 1 u)" data-docs="Propositional equality is `Decidable` for all elements of a type.

In other words, an instance of `DecidableEq α` is a means of deciding the proposition `a = b` is
for all `a b : α`.
" title="DecidableEq.{u} (α : Sort u) : Sort (max 1 u)
Propositional equality is `Decidable` for all elements of a type....">DecidableEq</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">α</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Finset α" title="Finset α">S</span> : <span class="lean-const" data-name="Finset" data-signature="Finset.{u_4} (α : Type u_4) : Type u_4" data-docs="`Finset α` is the type of finite sets of elements of `α`. It is implemented
as a multiset (a list up to permutation) which has no duplicate elements. " title="Finset.{u_4} (α : Type u_4) : Type u_4
`Finset α` is the type of finite sets of elements of `α`. It is implemented...">Finset</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">α</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> : <span class="lean-var" data-type="Type u_1" title="Type u_1">α</span> <span class="lean-operator">→</span> ℕ<span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="∀ a₁ ∈ S, ∀ a₂ ∈ S, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)" title="∀ a₁ ∈ S, ∀ a₂ ∈ S, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)">h_coprime</span> : <span class="lean-operator">∀</span> <span class="lean-var" data-type="α" title="α">a₁</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">S</span>, <span class="lean-operator">∀</span> <span class="lean-var" data-type="α" title="α">a₂</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">S</span>, <span class="lean-var" data-type="α" title="α">a₁</span> <span class="lean-operator">≠</span> <span class="lean-var" data-type="α" title="α">a₂</span> <span class="lean-operator">→</span> <span class="lean-bracket-2">(</span><span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">a₁</span><span class="lean-bracket-2">)</span>.<span class="lean-const" data-name="Nat.Coprime" data-signature="Nat.Coprime (m n : ℕ) : Prop" data-docs="`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. " title="Nat.Coprime (m n : ℕ) : Prop
`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. ">Coprime</span> <span class="lean-bracket-2">(</span><span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">a₂</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span> :
    <span class="lean-const" data-name="Nat.totient" data-signature="Nat.totient (n : ℕ) : ℕ" data-docs="Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are
coprime with `n`. " title="Nat.totient (n : ℕ) : ℕ
Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are...">Nat.totient</span> <span class="lean-bracket-1">(</span><span class="lean-operator">∏</span> <span class="lean-var" data-type="α" title="α">a</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">S</span>, <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">a</span><span class="lean-bracket-1">)</span> = <span class="lean-operator">∏</span> <span class="lean-var" data-type="α" title="α">a</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">S</span>, <span class="lean-const" data-name="Nat.totient" data-signature="Nat.totient (n : ℕ) : ℕ" data-docs="Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are
coprime with `n`. " title="Nat.totient (n : ℕ) : ℕ
Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are...">Nat.totient</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">a</span><span class="lean-bracket-1">)</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="Assuming `x` is a variable in the local context with an inductive type,
`induction x` applies induction on `x` to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on `x`,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,
`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,
and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.
Here the names `a` and `ih₁` are chosen automatically and are not accessible.
You can use `with` to provide the variables names for each constructor.
- `induction e`, where `e` is an expression instead of a variable,
  generalizes `e` in the goal, and then performs induction on the resulting variable.
- `induction e using r` allows the user to specify the principle of induction that should be used.
  Here `r` should be a term whose result type must be of the form `C t`,
  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables
- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,
  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.
  In other words, the net effect is that each inductive hypothesis is generalized.
- Given `x : Nat`, `induction x with | zero =&gt; tac₁ | succ x&#x27; ih =&gt; tac₂`
  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.
" title="Assuming `x` is a variable in the local context with an inductive type,">induction</span> <span class="lean-var" data-type="Finset α" title="Finset α">S</span> <span class="lean-keyword">using</span> <span class="lean-const" data-name="Finset.induction" data-signature="Finset.induction.{u_3} {α : Type u_3} {motive : Finset α → Prop} [DecidableEq α] (empty : motive ∅)
  (insert : ∀ (a : α) (s : Finset α), a ∉ s → motive s → motive (insert a s)) (s : Finset α) : motive s" title="Finset.induction.{u_3} {α : Type u_3} {motive : Finset α → Prop} [DecidableEq α] (empty : motive ∅)
  (insert : ∀ (a : α) (s : Finset α), a ∉ s → motive s → motive (insert a s)) (s : Finset α) : motive s">Finset.induction</span> <span class="lean-keyword" data-docs="After `with`, there is an optional tactic that runs on all branches, and
then a list of alternatives.
" title="After `with`, there is an optional tactic that runs on all branches, and">with</span>
  | <span class="lean-const" data-name="Finset.empty" data-signature="Finset.empty.{u_1} {α : Type u_1} : Finset α" data-docs="The empty finset " title="Finset.empty.{u_1} {α : Type u_1} : Finset α
The empty finset ">empty</span> =&gt; <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions.-
- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.
- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idᵢ`.
- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If
  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis
  `hᵢ` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span>
  | @insert <span class="lean-var" data-type="α" title="α">q</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span> <span class="lean-var" data-type="q ∉ s&#x27;" title="q ∉ s&#x27;">hq_notin</span> <span class="lean-var" data-type="(∀ a₁ ∈ s&#x27;, ∀ a₂ ∈ s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)) → φ (∏ a ∈ s&#x27;, f a) = ∏ a ∈ s&#x27;, φ (f a)" title="(∀ a₁ ∈ s&#x27;, ∀ a₂ ∈ s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)) → φ (∏ a ∈ s&#x27;, f a) = ∏ a ∈ s&#x27;, φ (f a)">IH</span> =&gt;
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Finset.prod_insert" data-signature="Finset.prod_insert.{u_1, u_4} {ι : Type u_1} {M : Type u_4} {s : Finset ι} {a : ι} [CommMonoid M] {f : ι → M}
  [DecidableEq ι] : a ∉ s → ∏ x ∈ insert a s, f x = f a * ∏ x ∈ s, f x" title="Finset.prod_insert.{u_1, u_4} {ι : Type u_1} {M : Type u_4} {s : Finset ι} {a : ι} [CommMonoid M] {f : ι → M}
  [DecidableEq ι] : a ∉ s → ∏ x ∈ insert a s, f x = f a * ∏ x ∈ s, f x">Finset.prod_insert</span> <span class="lean-var" data-type="q ∉ s&#x27;" title="q ∉ s&#x27;">hq_notin</span>, <span class="lean-const" data-name="Finset.prod_insert" data-signature="Finset.prod_insert.{u_1, u_4} {ι : Type u_1} {M : Type u_4} {s : Finset ι} {a : ι} [CommMonoid M] {f : ι → M}
  [DecidableEq ι] : a ∉ s → ∏ x ∈ insert a s, f x = f a * ∏ x ∈ s, f x" title="Finset.prod_insert.{u_1, u_4} {ι : Type u_1} {M : Type u_4} {s : Finset ι} {a : ι} [CommMonoid M] {f : ι → M}
  [DecidableEq ι] : a ∉ s → ∏ x ∈ insert a s, f x = f a * ∏ x ∈ s, f x">Finset.prod_insert</span> <span class="lean-var" data-type="q ∉ s&#x27;" title="q ∉ s&#x27;">hq_notin</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(f q).Coprime (∏ r ∈ s&#x27;, f r)" title="(f q).Coprime (∏ r ∈ s&#x27;, f r)">h_cop_q_s</span> : <span class="lean-bracket-1">(</span><span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">q</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Nat.Coprime" data-signature="Nat.Coprime (m n : ℕ) : Prop" data-docs="`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. " title="Nat.Coprime (m n : ℕ) : Prop
`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. ">Coprime</span> <span class="lean-bracket-1">(</span><span class="lean-operator">∏</span> <span class="lean-var" data-type="α" title="α">r</span> <span class="lean-operator">∈</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span>, <span class="lean-var" data-type="α → ℕ" title="α → ℕ">f</span> <span class="lean-var" data-type="α" title="α">r</span><span class="lean-bracket-1">)</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
      <span class="lean-keyword" data-docs="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.
" title="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.">apply</span> <span class="lean-const" data-name="Nat.Coprime.prod_right" data-signature="Nat.Coprime.prod_right.{u_1} {ι : Type u_1} {x : ℕ} {t : Finset ι} {s : ι → ℕ} :
  (∀ i ∈ t, x.Coprime (s i)) → x.Coprime (∏ i ∈ t, s i)" data-docs="See `IsCoprime.prod_right` for the corresponding lemma about `IsCoprime` " title="Nat.Coprime.prod_right.{u_1} {ι : Type u_1} {x : ℕ} {t : Finset ι} {s : ι → ℕ} :
  (∀ i ∈ t, x.Coprime (s i)) → x.Coprime (∏ i ∈ t, s i)
See `IsCoprime.prod_right` for the corresponding lemma about `IsCoprime` ">Nat.Coprime.prod_right</span>
      <span class="lean-keyword" data-docs="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal&#x27;s target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`. It is equivalent to `intro _`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, given a type ascription, or matched against a pattern:
  ```lean
  -- ... ⊢ α × β → ...
  intro (a, b)
  -- ..., a : α, b : β ⊢ ...
  ```
* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side
  is a variable.
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
" title="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.">intro</span> <span class="lean-var" data-type="α" title="α">r</span> <span class="lean-var" data-type="r ∈ s&#x27;" title="r ∈ s&#x27;">hr</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="q ≠ r" title="q ≠ r">hne</span> : <span class="lean-var" data-type="α" title="α">q</span> <span class="lean-operator">≠</span> <span class="lean-var" data-type="α" title="α">r</span> := <span class="lean-keyword">fun</span> <span class="lean-var" data-type="q = r" title="q = r">heq</span> =&gt; <span class="lean-var" data-type="q ∉ s&#x27;" title="q ∉ s&#x27;">hq_notin</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="q = r" title="q = r">heq</span> ▸ <span class="lean-var" data-type="r ∈ s&#x27;" title="r ∈ s&#x27;">hr</span><span class="lean-bracket-1">)</span>
      <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-var" data-type="∀ a₁ ∈ insert q s&#x27;, ∀ a₂ ∈ insert q s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)" title="∀ a₁ ∈ insert q s&#x27;, ∀ a₂ ∈ insert q s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)">h_coprime</span> <span class="lean-var" data-type="α" title="α">q</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_insert_self" data-signature="Finset.mem_insert_self.{u_1} {α : Type u_1} [DecidableEq α] (a : α) (s : Finset α) : a ∈ insert a s" title="Finset.mem_insert_self.{u_1} {α : Type u_1} [DecidableEq α] (a : α) (s : Finset α) : a ∈ insert a s">Finset.mem_insert_self</span> <span class="lean-var" data-type="α" title="α">q</span> <span class="lean-var" data-type="Finset α" title="Finset α">s&#x27;</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="α" title="α">r</span>
        <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_insert_of_mem" data-signature="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s" title="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s">Finset.mem_insert_of_mem</span> <span class="lean-var" data-type="r ∈ s&#x27;" title="r ∈ s&#x27;">hr</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="q ≠ r" title="q ≠ r">hne</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Nat.totient_mul" data-signature="Nat.totient_mul {m n : ℕ} (h : m.Coprime n) : φ (m * n) = φ m * φ n" title="Nat.totient_mul {m n : ℕ} (h : m.Coprime n) : φ (m * n) = φ m * φ n">Nat.totient_mul</span> <span class="lean-var" data-type="(f q).Coprime (∏ r ∈ s&#x27;, f r)" title="(f q).Coprime (∏ r ∈ s&#x27;, f r)">h_cop_q_s</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ f as ≍ f bs`.
The optional parameter is the depth of the recursive applications.
This is useful when `congr` is too aggressive in breaking down the goal.
For example, given `⊢ f (g (x + y)) = f (g (y + x))`,
`congr` produces the goals `⊢ x = y` and `⊢ y = x`,
while `congr 2` produces the intended `⊢ x + y = y + x`.
" title="Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ f as ≍ f bs`.">congr</span> <span class="lean-number">1</span>
    <span class="lean-keyword" data-docs="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.
" title="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.">apply</span> <span class="lean-var" data-type="(∀ a₁ ∈ s&#x27;, ∀ a₂ ∈ s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)) → φ (∏ a ∈ s&#x27;, f a) = ∏ a ∈ s&#x27;, φ (f a)" title="(∀ a₁ ∈ s&#x27;, ∀ a₂ ∈ s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)) → φ (∏ a ∈ s&#x27;, f a) = ∏ a ∈ s&#x27;, φ (f a)">IH</span>
    <span class="lean-keyword" data-docs="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal&#x27;s target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`. It is equivalent to `intro _`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, given a type ascription, or matched against a pattern:
  ```lean
  -- ... ⊢ α × β → ...
  intro (a, b)
  -- ..., a : α, b : β ⊢ ...
  ```
* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side
  is a variable.
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
" title="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.">intro</span> <span class="lean-var" data-type="α" title="α">a₁</span> <span class="lean-var" data-type="a₁ ∈ s&#x27;" title="a₁ ∈ s&#x27;">ha₁</span> <span class="lean-var" data-type="α" title="α">a₂</span> <span class="lean-var" data-type="a₂ ∈ s&#x27;" title="a₂ ∈ s&#x27;">ha₂</span> <span class="lean-var" data-type="a₁ ≠ a₂" title="a₁ ≠ a₂">hne</span>
    <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-var" data-type="∀ a₁ ∈ insert q s&#x27;, ∀ a₂ ∈ insert q s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)" title="∀ a₁ ∈ insert q s&#x27;, ∀ a₂ ∈ insert q s&#x27;, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)">h_coprime</span> <span class="lean-var" data-type="α" title="α">a₁</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_insert_of_mem" data-signature="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s" title="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s">Finset.mem_insert_of_mem</span> <span class="lean-var" data-type="a₁ ∈ s&#x27;" title="a₁ ∈ s&#x27;">ha₁</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="α" title="α">a₂</span>
      <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_insert_of_mem" data-signature="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s" title="Finset.mem_insert_of_mem.{u_1} {α : Type u_1} [DecidableEq α] {s : Finset α} {a b : α} (h : a ∈ s) : a ∈ insert b s">Finset.mem_insert_of_mem</span> <span class="lean-var" data-type="a₂ ∈ s&#x27;" title="a₂ ∈ s&#x27;">ha₂</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="a₁ ≠ a₂" title="a₁ ≠ a₂">hne</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/Lemmas.lean#L210-L242" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:totient-prod-coprime');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:orderOf-neg-of-odd-order">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">A.0.7</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0006.html#lem:orderOf-neg-of-odd-order">#</a>
    
    <a class="icon proof" href="sect0006.html#a0000000069"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.orderOf_neg_of_odd_order" class="lean_decl">Crystallographic.orderOf_neg_of_odd_order</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       If \(A\) has odd order \(k\), then \(-A\) has order \(2k\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000069">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>We have \(-A = (-1) \cdot A\) where \(-1\) commutes with \(A\). In characteristic \(0\), the order of \(-1\) is \(2\). Since \(k\) is odd, \(\gcd (2, k) = 1\), so by the product formula for commuting elements with coprime orders, the order of \(-A\) equals the order of \(-1\) times the order of \(A\), which is \(2k\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">theorem</span> <span class="lean-const lean-def" data-name="Crystallographic.orderOf_neg_of_odd_order" data-signature="Crystallographic.orderOf_neg_of_odd_order {n : ℕ} [NeZero n] (k : ℕ) (hk_odd : Odd k) (A : Matrix (Fin n) (Fin n) ℤ)
  (hA_ord : orderOf A = k) : orderOf (-A) = 2 * k" data-docs="If A has odd order k in a matrix ring over Z, then -A has order 2*k.
This uses orderOf(-1) = 2 (in char 0), commutativity of -1 with A,
and gcd(2, k) = 1 for odd k. " title="Crystallographic.orderOf_neg_of_odd_order {n : ℕ} [NeZero n] (k : ℕ) (hk_odd : Odd k) (A : Matrix (Fin n) (Fin n) ℤ)
  (hA_ord : orderOf A = k) : orderOf (-A) = 2 * k
If A has odd order k in a matrix ring over Z, then -A has order 2*k....">orderOf_neg_of_odd_order</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="ℕ" title="ℕ">n</span> : ℕ<span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="NeZero" data-signature="NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop" data-docs="A type-class version of `n ≠ 0`.  " title="NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop
A type-class version of `n ≠ 0`.  ">NeZero</span> <span class="lean-var" data-type="ℕ" title="ℕ">n</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="ℕ" title="ℕ">k</span> : ℕ<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Odd k" title="Odd k">hk_odd</span> : <span class="lean-const" data-name="Odd" data-signature="Odd.{u_2} {α : Type u_2} [Semiring α] (a : α) : Prop" data-docs="An element `a` of a semiring is odd if there exists `k` such `a = 2*k + 1`. " title="Odd.{u_2} {α : Type u_2} [Semiring α] (a : α) : Prop
An element `a` of a semiring is odd if there exists `k` such `a = 2*k + 1`. ">Odd</span> <span class="lean-var" data-type="ℕ" title="ℕ">k</span><span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Matrix (Fin n) (Fin n) ℤ" title="Matrix (Fin n) (Fin n) ℤ">A</span> : <span class="lean-const" data-name="Matrix" data-signature="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (α : Type v) : Type (max u u&#x27; v)" data-docs="`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`
and whose columns are indexed by `n`. " title="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (α : Type v) : Type (max u u&#x27; v)
`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`...">Matrix</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : ℕ) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : ℕ) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="ℕ" title="ℕ">n</span><span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : ℕ) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : ℕ) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="ℕ" title="ℕ">n</span><span class="lean-bracket-2">)</span> ℤ<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="orderOf A = k" title="orderOf A = k">hA_ord</span> : <span class="lean-const" data-name="orderOf" data-signature="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : ℕ" data-docs="`orderOf x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists.
Otherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. " title="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : ℕ
`orderOf x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists....">orderOf</span> <span class="lean-var" data-type="Matrix (Fin n) (Fin n) ℤ" title="Matrix (Fin n) (Fin n) ℤ">A</span> = <span class="lean-var" data-type="ℕ" title="ℕ">k</span><span class="lean-bracket-1">)</span> :
    <span class="lean-const" data-name="orderOf" data-signature="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : ℕ" data-docs="`orderOf x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists.
Otherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. " title="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : ℕ
`orderOf x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists....">orderOf</span> <span class="lean-bracket-1">(</span>-<span class="lean-var" data-type="Matrix (Fin n) (Fin n) ℤ" title="Matrix (Fin n) (Fin n) ℤ">A</span><span class="lean-bracket-1">)</span> = <span class="lean-expr" data-type="ℕ" title="ℕ">2</span> * k := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-comment">-- Express -A as </span><span class="lean-bracket-1">(</span>-<span class="lean-number">1</span><span class="lean-bracket-1">)</span> * A
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="-A = -1 * A" title="-A = -1 * A">hneg_eq</span> : -<span class="lean-var" data-type="Matrix (Fin n) (Fin n) ℤ" title="Matrix (Fin n) (Fin n) ℤ">A</span> = <span class="lean-bracket-1">(</span>-<span class="lean-expr" data-type="Matrix (Fin n) (Fin n) ℤ" title="Matrix (Fin n) (Fin n) ℤ">1</span> : <span class="lean-const" data-name="Matrix" data-signature="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (α : Type v) : Type (max u u&#x27; v)" data-docs="`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`
and whose columns are indexed by `n`. " title="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (α : Type v) : Type (max u u&#x27; v)
`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`...">Matrix</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : ℕ) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : ℕ) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="ℕ" title="ℕ">n</span><span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : ℕ) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : ℕ) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="ℕ" title="ℕ">n</span><span class="lean-bracket-2">)</span> ℤ<span class="lean-bracket-1">)</span> * <span class="lean-var" data-type="Matrix (Fin n) (Fin n) ℤ" title="Matrix (Fin n) (Fin n) ℤ">A</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions.-
- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.
- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idᵢ`.
- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If
  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis
  `hᵢ` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span>
  <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="-A = -1 * A" title="-A = -1 * A">hneg_eq</span><span class="lean-bracket-1">]</span>
  <span class="lean-comment">-- -<span class="lean-number">1</span> and A commute</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="Commute (-1) A" title="Commute (-1) A">hcomm</span> : <span class="lean-const" data-name="Commute" data-signature="Commute.{u_3} {S : Type u_3} [Mul S] (a b : S) : Prop" data-docs="Two elements commute if `a * b = b * a`. " title="Commute.{u_3} {S : Type u_3} [Mul S] (a b : S) : Prop
Two elements commute if `a * b = b * a`. ">Commute</span> <span class="lean-bracket-1">(</span>-<span class="lean-expr" data-type="Matrix (Fin n) (Fin n) ℤ" title="Matrix (Fin n) (Fin n) ℤ">1</span> : <span class="lean-const" data-name="Matrix" data-signature="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (α : Type v) : Type (max u u&#x27; v)" data-docs="`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`
and whose columns are indexed by `n`. " title="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (α : Type v) : Type (max u u&#x27; v)
`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`...">Matrix</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : ℕ) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : ℕ) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="ℕ" title="ℕ">n</span><span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : ℕ) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : ℕ) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="ℕ" title="ℕ">n</span><span class="lean-bracket-2">)</span> ℤ<span class="lean-bracket-1">)</span> <span class="lean-var" data-type="Matrix (Fin n) (Fin n) ℤ" title="Matrix (Fin n) (Fin n) ℤ">A</span> := <span class="lean-const" data-name="Commute.neg_one_left" data-signature="Commute.neg_one_left.{u} {R : Type u} [MulOneClass R] [HasDistribNeg R] (a : R) : Commute (-1) a" title="Commute.neg_one_left.{u} {R : Type u} [MulOneClass R] [HasDistribNeg R] (a : R) : Commute (-1) a">Commute.neg_one_left</span> <span class="lean-var" data-type="Matrix (Fin n) (Fin n) ℤ" title="Matrix (Fin n) (Fin n) ℤ">A</span>
  <span class="lean-comment">-- orderOf</span><span class="lean-bracket-1">(</span>-<span class="lean-number">1</span><span class="lean-bracket-1">)</span> = <span class="lean-number">2</span> in char <span class="lean-number">0</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="orderOf (-1) = 2" title="orderOf (-1) = 2">hord_neg1</span> : <span class="lean-const" data-name="orderOf" data-signature="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : ℕ" data-docs="`orderOf x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists.
Otherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. " title="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : ℕ
`orderOf x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists....">orderOf</span> <span class="lean-bracket-1">(</span>-<span class="lean-expr" data-type="Matrix (Fin n) (Fin n) ℤ" title="Matrix (Fin n) (Fin n) ℤ">1</span> : <span class="lean-const" data-name="Matrix" data-signature="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (α : Type v) : Type (max u u&#x27; v)" data-docs="`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`
and whose columns are indexed by `n`. " title="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (α : Type v) : Type (max u u&#x27; v)
`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`...">Matrix</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : ℕ) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : ℕ) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="ℕ" title="ℕ">n</span><span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : ℕ) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : ℕ) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="ℕ" title="ℕ">n</span><span class="lean-bracket-2">)</span> ℤ<span class="lean-bracket-1">)</span> = <span class="lean-expr" data-type="ℕ" title="ℕ">2</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="orderOf_neg_one" data-signature="orderOf_neg_one.{u_1} {R : Type u_1} [Ring R] [Nontrivial R] : orderOf (-1) = if ringChar R = 2 then 1 else 2" title="orderOf_neg_one.{u_1} {R : Type u_1} [Ring R] [Nontrivial R] : orderOf (-1) = if ringChar R = 2 then 1 else 2">orderOf_neg_one</span>, <span class="lean-const" data-name="Crystallographic.ringChar_matrix_int" data-signature="Crystallographic.ringChar_matrix_int (N : ℕ) [NeZero N] : ringChar (Matrix (Fin N) (Fin N) ℤ) = 0" data-docs="The ring characteristic of integer matrices is 0 for N ≥ 1. " title="Crystallographic.ringChar_matrix_int (N : ℕ) [NeZero N] : ringChar (Matrix (Fin N) (Fin N) ℤ) = 0
The ring characteristic of integer matrices is 0 for N ≥ 1. ">ringChar_matrix_int</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions.-
- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.
- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idᵢ`.
- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If
  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis
  `hᵢ` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span>
  <span class="lean-comment">-- Coprimality: gcd</span><span class="lean-bracket-1">(</span><span class="lean-number">2</span>, k<span class="lean-bracket-1">)</span> = <span class="lean-number">1</span> since k is odd
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="Nat.Coprime 2 k" title="Nat.Coprime 2 k">hcop</span> : <span class="lean-const" data-name="Nat.Coprime" data-signature="Nat.Coprime (m n : ℕ) : Prop" data-docs="`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. " title="Nat.Coprime (m n : ℕ) : Prop
`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. ">Nat.Coprime</span> <span class="lean-expr" data-type="ℕ" title="ℕ">2</span> <span class="lean-var" data-type="ℕ" title="ℕ">k</span> := <span class="lean-const" data-name="Nat.Coprime.symm" data-signature="Nat.Coprime.symm {n m : ℕ} : n.Coprime m → m.Coprime n" title="Nat.Coprime.symm {n m : ℕ} : n.Coprime m → m.Coprime n">Nat.Coprime.symm</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Odd.coprime_two_right" data-signature="Odd.coprime_two_right {n : ℕ} : Odd n → n.Coprime 2" data-docs="**Alias** of the reverse direction of `Nat.coprime_two_right`." title="Odd.coprime_two_right {n : ℕ} : Odd n → n.Coprime 2
**Alias** of the reverse direction of `Nat.coprime_two_right`.">Odd.coprime_two_right</span> <span class="lean-var" data-type="Odd k" title="Odd k">hk_odd</span><span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(orderOf (-1)).Coprime (orderOf A)" title="(orderOf (-1)).Coprime (orderOf A)">hord_cop</span> : <span class="lean-const" data-name="Nat.Coprime" data-signature="Nat.Coprime (m n : ℕ) : Prop" data-docs="`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. " title="Nat.Coprime (m n : ℕ) : Prop
`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. ">Nat.Coprime</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="orderOf" data-signature="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : ℕ" data-docs="`orderOf x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists.
Otherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. " title="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : ℕ
`orderOf x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists....">orderOf</span> <span class="lean-bracket-2">(</span>-<span class="lean-expr" data-type="Matrix (Fin n) (Fin n) ℤ" title="Matrix (Fin n) (Fin n) ℤ">1</span> : <span class="lean-const" data-name="Matrix" data-signature="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (α : Type v) : Type (max u u&#x27; v)" data-docs="`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`
and whose columns are indexed by `n`. " title="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (α : Type v) : Type (max u u&#x27; v)
`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`...">Matrix</span> <span class="lean-bracket-3">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : ℕ) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : ℕ) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="ℕ" title="ℕ">n</span><span class="lean-bracket-3">)</span> <span class="lean-bracket-3">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : ℕ) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : ℕ) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="ℕ" title="ℕ">n</span><span class="lean-bracket-3">)</span> ℤ<span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="orderOf" data-signature="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : ℕ" data-docs="`orderOf x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists.
Otherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. " title="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : ℕ
`orderOf x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists....">orderOf</span> <span class="lean-var" data-type="Matrix (Fin n) (Fin n) ℤ" title="Matrix (Fin n) (Fin n) ℤ">A</span><span class="lean-bracket-1">)</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="orderOf (-1) = 2" title="orderOf (-1) = 2">hord_neg1</span>, <span class="lean-var" data-type="orderOf A = k" title="orderOf A = k">hA_ord</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-var" data-type="Nat.Coprime 2 k" title="Nat.Coprime 2 k">hcop</span>
  <span class="lean-comment">-- Apply the product formula</span>
  <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="Commute (-1) A" title="Commute (-1) A">hcomm</span>.<span class="lean-const" data-name="Commute.orderOf_mul_eq_mul_orderOf_of_coprime" data-signature="Commute.orderOf_mul_eq_mul_orderOf_of_coprime.{u_1} {G : Type u_1} [Monoid G] {x y : G} (h : Commute x y)
  (hco : (orderOf x).Coprime (orderOf y)) : orderOf (x * y) = orderOf x * orderOf y" title="Commute.orderOf_mul_eq_mul_orderOf_of_coprime.{u_1} {G : Type u_1} [Monoid G] {x y : G} (h : Commute x y)
  (hco : (orderOf x).Coprime (orderOf y)) : orderOf (x * y) = orderOf x * orderOf y">orderOf_mul_eq_mul_orderOf_of_coprime</span> <span class="lean-var" data-type="(orderOf (-1)).Coprime (orderOf A)" title="(orderOf (-1)).Coprime (orderOf A)">hord_cop</span><span class="lean-bracket-1">]</span>
  <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="orderOf (-1) = 2" title="orderOf (-1) = 2">hord_neg1</span>, <span class="lean-var" data-type="orderOf A = k" title="orderOf A = k">hA_ord</span><span class="lean-bracket-1">]</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/Lemmas.lean#L250-L278" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:orderOf-neg-of-odd-order');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>



</div> <!--main-text -->
</div> <!-- content-wrapper -->
</div> <!-- content -->
</div> <!-- wrapper -->

<nav class="prev_up_next">
  <svg  id="showmore-minus" class="icon icon-eye-minus showmore"><use xlink:href="symbol-defs.svg#icon-eye-minus"></use></svg>

  <svg  id="showmore-plus" class="icon icon-eye-plus showmore"><use xlink:href="symbol-defs.svg#icon-eye-plus"></use></svg>

  <a href="sect0005.html" title="The Crystallographic Restriction Theorem"><svg  class="icon icon-arrow-left "><use xlink:href="symbol-defs.svg#icon-arrow-left"></use></svg>
</a>
  <a href="index.html" title="Crystallographic Restriction Theorem"><svg  class="icon icon-arrow-up "><use xlink:href="symbol-defs.svg#icon-arrow-up"></use></svg>
</a>
</nav>

<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/plastex.js"></script>
<script type="text/javascript" src="js/svgxuse.js"></script>
<script type="text/javascript" src="js/js.cookie.min.js"></script>
<script type="text/javascript" src="js/showmore.js"></script>
</body>
</html>