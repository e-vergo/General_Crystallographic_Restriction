<!DOCTYPE html>
<html lang="en">
<head>
<script>
  MathJax = { 
    tex: {
		    inlineMath: [['$','$'], ['\\(','\\)']]
	} }
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<meta name="generator" content="plasTeX" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Appendix</title>
<link rel="prev" href="sect0005.html" title="The Crystallographic Restriction Theorem" />
<link rel="up" href="index.html" title="Crystallographic Restriction Theorem" />
<link rel="stylesheet" href="styles/theme-blue.css" />
<link rel="stylesheet" href="styles/showmore.css" />
<link rel="stylesheet" href="styles/blueprint.css" />
<link rel="stylesheet" href="styles/amsthm.css" />
<link rel="stylesheet" href="styles/style.css" />
</head>

<body>
<header>
<svg  id="toc-toggle" class="icon icon-list-numbered "><use xlink:href="symbol-defs.svg#icon-list-numbered"></use></svg>
<h1 id="doc_title"><a href="index.html">Crystallographic Restriction Theorem</a></h1>
</header>

<div class="wrapper">
<nav class="toc">
<ul class="sub-toc-0">
<li class="">
  <a href="sect0001.html"><span class="toc_ref">1</span> <span class="toc_entry">Introduction</span></a>
 </li>
<li class="">
  <a href="sect0002.html"><span class="toc_ref">2</span> <span class="toc_entry">The Psi Function</span></a>
 </li>
<li class="">
  <a href="sect0003.html"><span class="toc_ref">3</span> <span class="toc_entry">Integer Matrix Orders</span></a>
 </li>
<li class="">
  <a href="sect0004.html"><span class="toc_ref">4</span> <span class="toc_entry">Companion Matrices</span></a>
 </li>
<li class="">
  <a href="sect0005.html"><span class="toc_ref">5</span> <span class="toc_entry">The Crystallographic Restriction Theorem</span></a>
 </li>
<li class=" active current">
  <a href="sect0006.html"><span class="toc_ref">A</span> <span class="toc_entry">Appendix</span></a>
 </li>
<li ><a href="dep_graph_document.html">Dependency graph</a></li>
</ul>
</nav>

<div class="content">
<div class="content-wrapper">


<div class="main-text">
<h1 id="a0000000007">A Appendix</h1>
<p>This appendix collects technical lemmas used throughout the proof. These are general-purpose results about finite sets, coprime products, Euler’s totient function, and matrix orders that support the main arguments. </p>
<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:sum-le-prod">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">A.0.1</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0006.html#lem:sum-le-prod">#</a>
    
    <a class="icon proof" href="sect0006.html#a0000000063"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Finset.sum_le_prod_of_all_ge_two" class="lean_decl">Finset.sum_le_prod_of_all_ge_two</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   For a finite set where all values \(\geq 2\), the sum is at most the product. </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000063">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By induction on the size of the finite set. Base case: empty sum is \(0 \leq 1\) (empty product). Inductive step: if \(\sum _{x \in s} f(x) \leq \prod _{x \in s} f(x)\) and \(f(a) \geq 2\), then \(\sum _{x \in s \cup \{ a\} } f(x) = f(a) + \sum _s f \leq f(a) \cdot \prod _s f \leq \prod _{s \cup \{ a\} } f\) using \(1 + y \leq 2y\) for \(y \geq 1\) and \(f(a) \geq 2\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma sum_le_prod_of_all_ge_two {α : Type*} [DecidableEq α]
    (s : Finset α) (f : α → ℕ) (hf : ∀ x ∈ s, 2 ≤ f x) :
    ∑ x ∈ s, f x ≤ ∏ x ∈ s, f x := by</span></code><code class="lean-proof-body"><span class="lean-plain">induction s using Finset.induction with
  | empty =&gt; simp
  | @insert a s&#x27; ha IH =&gt;
    rw [Finset.sum_insert ha, Finset.prod_insert ha]
    have h2_a : 2 ≤ f a := hf a (Finset.mem_insert_self a s&#x27;)
    by_cases hs_empty : s&#x27; = ∅
    · simp [hs_empty]
    · have hs_nonempty : s&#x27;.Nonempty := Finset.nonempty_of_ne_empty hs_empty
      have hs&#x27;_ge2 : ∀ x ∈ s&#x27;, 2 ≤ f x := fun x hx =&gt; hf x (Finset.mem_insert_of_mem hx)
      have h2_prod : 2 ≤ ∏ x ∈ s&#x27;, f x := by
        obtain ⟨b, hb⟩ := hs_nonempty
        have h1 : ∀ x ∈ s&#x27;, 1 ≤ f x := fun x hx =&gt; Nat.one_le_of_lt (hs&#x27;_ge2 x hx)
        calc ∏ x ∈ s&#x27;, f x ≥ f b := Finset.single_le_prod&#x27; h1 hb
          _ ≥ 2 := hs&#x27;_ge2 b hb
      have IH&#x27; := IH hs&#x27;_ge2
      calc f a + ∑ x ∈ s&#x27;, f x
          ≤ f a + ∏ x ∈ s&#x27;, f x := by omega
        _ ≤ f a * ∏ x ∈ s&#x27;, f x := Nat.add_le_mul h2_a h2_prod</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/Lemmas.lean#L41-L74" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:sum-le-prod');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:lcm-factorization-le-sup">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">A.0.2</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0006.html#lem:lcm-factorization-le-sup">#</a>
    
    <a class="icon proof" href="sect0006.html#a0000000064"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Finset.lcm_factorization_le_sup" class="lean_decl">Finset.lcm_factorization_le_sup</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   The factorization of \(\mathrm{lcm}(S)\) at prime \(q\) is bounded by \(\sup _{x \in S} v_q(x)\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000064">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>The \(q\)-adic valuation of \(\mathrm{lcm}(S)\) is the maximum of \(q\)-adic valuations over elements of \(S\). This follows from the definition of lcm via factorization: \(v_q(\mathrm{lcm}(S)) = \sup _{x \in S} v_q(x)\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma lcm_factorization_le_sup {α : Type*} [DecidableEq α] (S : Finset α) (f : α → ℕ)
    (q : ℕ) (hS_ne_zero : ∀ x ∈ S, f x ≠ 0) :
    (S.lcm f).factorization q ≤ S.sup (fun x =&gt; (f x).factorization q) := by</span></code><code class="lean-proof-body"><span class="lean-plain">induction S using Finset.induction with
  | empty =&gt;
    simp only [Finset.lcm_empty, Nat.factorization_one, Finsupp.coe_zero, Pi.zero_apply,
      Finset.sup_empty, bot_eq_zero, le_refl]
  | @insert a s&#x27; ha IH =&gt;
    simp only [Finset.lcm_insert, Finset.sup_insert]
    by_cases hs&#x27;_empty : s&#x27; = ∅
    · simp [hs&#x27;_empty]
    · have hs&#x27;_ne_zero : s&#x27;.lcm f ≠ 0 := by
        rw [ne_eq, Finset.lcm_eq_zero_iff]
        push_neg
        intro x hx
        exact hS_ne_zero x (Finset.mem_insert_of_mem hx)
      have ha_ne_zero : f a ≠ 0 := hS_ne_zero a (Finset.mem_insert_self a s&#x27;)
      rw [lcm_eq_nat_lcm, Nat.factorization_lcm ha_ne_zero hs&#x27;_ne_zero]
      simp only [Finsupp.sup_apply, sup_le_iff]
      constructor
      · exact le_sup_left
      · have hIH := IH (fun x hx =&gt; hS_ne_zero x (Finset.mem_insert_of_mem hx))
        exact le_trans hIH le_sup_right</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/Lemmas.lean#L78-L106" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:lcm-factorization-le-sup');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:primePow-mem-of-lcm-eq">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">A.0.3</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0006.html#lem:primePow-mem-of-lcm-eq">#</a>
    
    <a class="icon proof" href="sect0006.html#a0000000065"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Finset.prime_pow_mem_of_lcm_eq" class="lean_decl">Crystallographic.Finset.prime_pow_mem_of_lcm_eq</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   If \(\mathrm{lcm}(S) = p^k\) and all elements of \(S\) divide \(p^k\), then \(p^k \in S\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000065">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>Since \(\mathrm{lcm}(S) = p^k\) and all elements divide \(p^k\), each element has form \(p^j\) for some \(j \leq k\). Taking lcm over these powers gives \(p^{\max _j} = p^k\), so some element must have \(j = k\), meaning \(p^k \in S\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma Finset.prime_pow_mem_of_lcm_eq {p k : ℕ} (hp : p.Prime) (hk : 0 &lt; k) (S : Finset ℕ)
    (hS_sub : ∀ d ∈ S, d ∣ p ^ k) (hS_lcm : S.lcm id = p ^ k) :
    p ^ k ∈ S := by</span></code><code class="lean-proof-body"><span class="lean-plain">by_contra hm_not_in
  -- All elements of S are proper divisors of p^k, so they divide p^(k-1)
  have hall_lt : ∀ d ∈ S, d &lt; p ^ k := fun d hd =&gt;
    Nat.lt_of_le_of_ne (Nat.le_of_dvd (Nat.pow_pos hp.pos) (hS_sub d hd))
      (fun heq =&gt; hm_not_in (heq ▸ hd))
  have hall_le : ∀ d ∈ S, d ∣ p ^ (k - 1) := by
    intro d hd
    have hdvd := hS_sub d hd
    have hd_lt := hall_lt d hd
    have hpr : Prime p := Nat.Prime.prime hp
    rw [dvd_prime_pow hpr] at hdvd
    obtain ⟨j, _, hassoc⟩ := hdvd
    have hd_eq := associated_iff_eq.mp hassoc
    rw [hd_eq] at hd_lt
    have hj_lt : j &lt; k := (Nat.pow_lt_pow_iff_right hp.one_lt).mp hd_lt
    have hj_le : j ≤ k - 1 := Nat.lt_succ_iff.mp (by omega)
    rw [hd_eq]
    exact Nat.pow_dvd_pow p hj_le
  have hlcm_le : S.lcm id ∣ p ^ (k - 1) := Finset.lcm_dvd_iff.mpr (fun d hd =&gt; hall_le d hd)
  rw [hS_lcm] at hlcm_le
  have hle : p ^ k ≤ p ^ (k - 1) := Nat.le_of_dvd (Nat.pow_pos hp.pos) hlcm_le
  have hpow_strict : p ^ (k - 1) &lt; p ^ k :=
    Nat.pow_lt_pow_right hp.one_lt (Nat.sub_lt hk Nat.one_pos)
  omega</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/Lemmas.lean#L114-L151" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:primePow-mem-of-lcm-eq');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:totient-ge-two">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">A.0.4</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0006.html#lem:totient-ge-two">#</a>
    
    <a class="icon proof" href="sect0006.html#a0000000066"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.two_le_totient_of_two_lt" class="lean_decl">Crystallographic.two_le_totient_of_two_lt</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>      For \(n {\gt} 2\), we have \(\varphi (n) \geq 2\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000066">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>Since \(n {\gt} 2\), we have \(n \neq 1\) and \(n \neq 2\). By the fact that \(\varphi (n) = 1\) if and only if \(n \in \{ 1, 2\} \), we conclude that \(\varphi (n) \neq 1\). Also \(\varphi (n) \neq 0\) since \(n {\gt} 0\). Therefore \(\varphi (n) \geq 2\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>ℕ</code>","1":"<code>2 &lt; n</code>","2":"<code>Nat.totient (n : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">Euler's totient function. This counts the number of naturals strictly less than `n` which are\ncoprime with `n`. </code>","3":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-7417">theorem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">two_le_totient_of_two_lt</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.831" data-verso-hover="0">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.873" data-verso-hover="1">hn</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.831" data-verso-hover="0">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.totient" data-verso-hover="2">Nat.totient</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.831" data-verso-hover="0">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-7498" data-verso-hover="3">by</span></code><code class="lean-proof-body"><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-7503" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.totient_pos.mpr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-7532" data-verso-hover="1">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-7535" data-verso-hover="2">omega</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-7552" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.totient_eq_one_iff.not.mpr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-7592" data-verso-hover="1">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-7595" data-verso-hover="2">omega</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-7626" data-verso-hover="2">omega</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/Lemmas.lean#L155-L165" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:totient-ge-two');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:prod-coprime-dvd">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">A.0.5</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0006.html#lem:prod-coprime-dvd">#</a>
    
    <a class="icon proof" href="sect0006.html#a0000000067"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Finset.prod_coprime_dvd" class="lean_decl">Finset.prod_coprime_dvd</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>      If each \(f(a)\) divides \(d\) and the \(f(a)\) are pairwise coprime, then \(\prod _{a \in S} f(a)\) divides \(d\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000067">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By induction on the finite set. Empty case: \(1 \mid d\) trivially. Insert case: we have \(f(q) \mid d\) and \(\prod _{s'} f(r) \mid d\) by IH. Show \(f(q)\) is coprime to \(\prod _{s'} f(r)\) using ‘Nat.Coprime.prod_right‘, then apply ‘Nat.Coprime.mul_dvd_of_dvd_of_dvd‘. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>Type u_1</code>","1":"<code class=\"docstring\">The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable\n`&gt; 0` for each variable in the sequence. </code>","10":"<code>Nat.Coprime (m n : ℕ) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. </code>","11":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>","2":"<code>DecidableEq.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">Propositional equality is `Decidable` for all elements of a type.\n\nIn other words, an instance of `DecidableEq α` is a means of deciding the proposition `a = b` is\nfor all `a b : α`.\n</code>","3":"<code>Finset α</code>","4":"<code>Finset.{u_4} (α : Type u_4) : Type u_4</code><span class=\"sep\"></span><code class=\"docstring\">`Finset α` is the type of finite sets of elements of `α`. It is implemented\nas a multiset (a list up to permutation) which has no duplicate elements. </code>","5":"<code>α → ℕ</code>","6":"<code>ℕ</code>","7":"<code>∀ a ∈ S, f a ∣ d</code>","8":"<code>α</code>","9":"<code>∀ a₁ ∈ S, ∀ a₂ ∈ S, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)</code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-8253">theorem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">prod_coprime_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.914" data-verso-hover="0">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-2022587232982003368" data-verso-hover="1">Type*</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-DecidableEq" data-verso-hover="2">DecidableEq</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.914" data-verso-hover="0">α</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.926" data-verso-hover="3">S</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Finset" data-verso-hover="4">Finset</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.914" data-verso-hover="0">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.930" data-verso-hover="5">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.914" data-verso-hover="0">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.932" data-verso-hover="6">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1020" data-verso-hover="7">h_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.936" data-verso-hover="8">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.926" data-verso-hover="3">S</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.930" data-verso-hover="5">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.936" data-verso-hover="8">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.932" data-verso-hover="6">d</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1186" data-verso-hover="9">h_coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1026" data-verso-hover="8">a₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.926" data-verso-hover="3">S</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1104" data-verso-hover="8">a₂</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.926" data-verso-hover="3">S</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1026" data-verso-hover="8">a₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1104" data-verso-hover="8">a₂</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.930" data-verso-hover="5">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1026" data-verso-hover="8">a₁</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.Coprime" data-verso-hover="10">Coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.930" data-verso-hover="5">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1104" data-verso-hover="8">a₂</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∏</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1251" data-verso-hover="8">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.926" data-verso-hover="3">S</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.930" data-verso-hover="5">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1251" data-verso-hover="8">a</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.932" data-verso-hover="6">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-8516" data-verso-hover="11">by</span></code><code class="lean-proof-body"><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-8521" data-verso-hover="0">induction</span><span class="inter-text"> </span><span class="unknown token" data-binding="">S</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-8533">using</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Finset.induction</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.inductionAlts-8556" data-verso-hover="1">with</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">empty</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-8574" data-verso-hover="2">simp</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">@</span><span class="unknown token" data-binding="">insert</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">s'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_notin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">IH</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-8615" data-verso-hover="3">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">Finset.prod_insert</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_notin</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-8652" data-verso-hover="4">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="unknown token" data-binding="">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Finset.mem_insert_self</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">s'</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-8721" data-verso-hover="4">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hs'_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∏</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="unknown token" data-binding="">s'</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="unknown token" data-binding="">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-8765" data-verso-hover="5">by</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-8774" data-verso-hover="6">apply</span><span class="inter-text"> </span><span class="unknown token" data-binding="">IH</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-8792" data-verso-hover="7">intro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hr</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-8804" data-verso-hover="8">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Finset.mem_insert_of_mem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hr</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-8857" data-verso-hover="7">intro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ha₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a₂</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ha₂</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hne</span><span class="inter-text">
        </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-8897" data-verso-hover="8">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Finset.mem_insert_of_mem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ha₁</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a₂</span><span class="inter-text">
          </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Finset.mem_insert_of_mem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ha₂</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hne</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-9007" data-verso-hover="4">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_cop</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">Coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∏</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="unknown token" data-binding="">s'</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-9057" data-verso-hover="5">by</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-9066" data-verso-hover="6">apply</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.Coprime.prod_right</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-9101" data-verso-hover="7">intro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hr</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-9118" data-verso-hover="4">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hne</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-9140">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">heq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_notin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">heq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">▸</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hr</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-9179" data-verso-hover="8">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Finset.mem_insert_self</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">s'</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Finset.mem_insert_of_mem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hr</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hne</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-9275" data-verso-hover="8">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_cop.mul_dvd_of_dvd_of_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hs'_dvd</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/Lemmas.lean#L173-L202" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:prod-coprime-dvd');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:totient-prod-coprime">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">A.0.6</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0006.html#lem:totient-prod-coprime">#</a>
    
    <a class="icon proof" href="sect0006.html#a0000000068"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Nat.totient_finset_prod_of_coprime" class="lean_decl">Nat.totient_finset_prod_of_coprime</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>      For pairwise coprime \(\{ f(a)\} _{a \in S}\), we have \(\varphi (\prod _{a \in S} f(a)) = \prod _{a \in S} \varphi (f(a))\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000068">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By induction on the finite set. Empty case: \(\varphi (1) = 1\) equals empty product. Insert case: use \(\varphi (ab) = \varphi (a)\varphi (b)\) for coprime \(a, b\) (‘Nat.totient_mul‘), where coprimality follows from ‘Nat.Coprime.prod_right‘. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>Type u_1</code>","1":"<code class=\"docstring\">The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable\n`&gt; 0` for each variable in the sequence. </code>","10":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>","2":"<code>DecidableEq.{u} (α : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">Propositional equality is `Decidable` for all elements of a type.\n\nIn other words, an instance of `DecidableEq α` is a means of deciding the proposition `a = b` is\nfor all `a b : α`.\n</code>","3":"<code>Finset α</code>","4":"<code>Finset.{u_4} (α : Type u_4) : Type u_4</code><span class=\"sep\"></span><code class=\"docstring\">`Finset α` is the type of finite sets of elements of `α`. It is implemented\nas a multiset (a list up to permutation) which has no duplicate elements. </code>","5":"<code>α → ℕ</code>","6":"<code>∀ a₁ ∈ S, ∀ a₂ ∈ S, a₁ ≠ a₂ → (f a₁).Coprime (f a₂)</code>","7":"<code>α</code>","8":"<code>Nat.Coprime (m n : ℕ) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. </code>","9":"<code>Nat.totient (n : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">Euler's totient function. This counts the number of naturals strictly less than `n` which are\ncoprime with `n`. </code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-10279">theorem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">totient_finset_prod_of_coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.1265" data-verso-hover="0">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-2022587232982003368" data-verso-hover="1">Type*</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-DecidableEq" data-verso-hover="2">DecidableEq</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1265" data-verso-hover="0">α</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1277" data-verso-hover="3">S</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Finset" data-verso-hover="4">Finset</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1265" data-verso-hover="0">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1281" data-verso-hover="5">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1265" data-verso-hover="0">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1445" data-verso-hover="6">h_coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1285" data-verso-hover="7">a₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1277" data-verso-hover="3">S</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∀</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1363" data-verso-hover="7">a₂</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1277" data-verso-hover="3">S</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1285" data-verso-hover="7">a₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1363" data-verso-hover="7">a₂</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1281" data-verso-hover="5">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1285" data-verso-hover="7">a₁</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.Coprime" data-verso-hover="8">Coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1281" data-verso-hover="5">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1363" data-verso-hover="7">a₂</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="const token" data-binding="const-Nat.totient" data-verso-hover="9">Nat.totient</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∏</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1505" data-verso-hover="7">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1277" data-verso-hover="3">S</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1281" data-verso-hover="5">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1505" data-verso-hover="7">a</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∏</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1526" data-verso-hover="7">a</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1277" data-verso-hover="3">S</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.totient" data-verso-hover="9">Nat.totient</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1281" data-verso-hover="5">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1526" data-verso-hover="7">a</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-10548" data-verso-hover="10">by</span></code><code class="lean-proof-body"><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-10553" data-verso-hover="0">induction</span><span class="inter-text"> </span><span class="unknown token" data-binding="">S</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-10565">using</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Finset.induction</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.inductionAlts-10588" data-verso-hover="1">with</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">empty</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-10606" data-verso-hover="2">simp</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">@</span><span class="unknown token" data-binding="">insert</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">s'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_notin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">IH</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-10647" data-verso-hover="3">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">Finset.prod_insert</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_notin</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Finset.prod_insert</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_notin</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-10713" data-verso-hover="4">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_cop_q_s</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">Coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">∏</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="unknown token" data-binding="">s'</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-10767" data-verso-hover="5">by</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-10776" data-verso-hover="6">apply</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.Coprime.prod_right</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-10811" data-verso-hover="7">intro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hr</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-10828" data-verso-hover="4">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hne</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-10850">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">heq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_notin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">heq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">▸</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hr</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-10889" data-verso-hover="8">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Finset.mem_insert_self</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">s'</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">r</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Finset.mem_insert_of_mem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hr</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hne</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-10985" data-verso-hover="3">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">Nat.totient_mul</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_cop_q_s</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.congr-11020" data-verso-hover="9">congr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-11032" data-verso-hover="6">apply</span><span class="inter-text"> </span><span class="unknown token" data-binding="">IH</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-11045" data-verso-hover="7">intro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ha₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a₂</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ha₂</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hne</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-11081" data-verso-hover="8">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a₁</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Finset.mem_insert_of_mem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ha₁</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">a₂</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Finset.mem_insert_of_mem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ha₂</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hne</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/Lemmas.lean#L210-L242" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:totient-prod-coprime');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:orderOf-neg-of-odd-order">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">A.0.7</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0006.html#lem:orderOf-neg-of-odd-order">#</a>
    
    <a class="icon proof" href="sect0006.html#a0000000069"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.orderOf_neg_of_odd_order" class="lean_decl">Crystallographic.orderOf_neg_of_odd_order</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>      If \(A\) has odd order \(k\), then \(-A\) has order \(2k\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000069">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>We have \(-A = (-1) \cdot A\) where \(-1\) commutes with \(A\). In characteristic \(0\), the order of \(-1\) is \(2\). Since \(k\) is odd, \(\gcd (2, k) = 1\), so by the product formula for commuting elements with coprime orders, the order of \(-A\) equals the order of \(-1\) times the order of \(A\), which is \(2k\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>ℕ</code>","1":"<code>NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A type-class version of `n ≠ 0`.  </code>","2":"<code>Odd k</code>","3":"<code>Odd.{u_2} {α : Type u_2} [Semiring α] (a : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">An element `a` of a semiring is odd if there exists `k` such `a = 2*k + 1`. </code>","4":"<code>Matrix (Fin n) (Fin n) ℤ</code>","5":"<code>Matrix.{u, u', v} (m : Type u) (n : Type u') (α : Type v) : Type (max u u' v)</code><span class=\"sep\"></span><code class=\"docstring\">`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`\nand whose columns are indexed by `n`. </code>","6":"<code>Fin (n : ℕ) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Natural numbers less than some upper bound.\n\nIn particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the\ncanonical type with `n` elements.\n</code>","7":"<code>orderOf A = k</code>","8":"<code>orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`orderOf x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists.\nOtherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. </code>","9":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-11872">theorem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">orderOf_neg_of_odd_order</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.1532" data-verso-hover="0">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-NeZero" data-verso-hover="1">NeZero</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1532" data-verso-hover="0">n</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1625" data-verso-hover="0">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1666" data-verso-hover="2">hk_odd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Odd" data-verso-hover="3">Odd</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1625" data-verso-hover="0">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1671" data-verso-hover="4">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Matrix" data-verso-hover="5">Matrix</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Fin" data-verso-hover="6">Fin</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1532" data-verso-hover="0">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Fin" data-verso-hover="6">Fin</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1532" data-verso-hover="0">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1728" data-verso-hover="7">hA_ord</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-orderOf" data-verso-hover="8">orderOf</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1671" data-verso-hover="4">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1625" data-verso-hover="0">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="const token" data-binding="const-orderOf" data-verso-hover="8">orderOf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">-</span><span class="var token" data-binding="var-_uniq.1671" data-verso-hover="4">A</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1625" data-verso-hover="0">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-12045" data-verso-hover="9">by</span></code><code class="lean-proof-body"><span class="inter-text">
  -- Express -A as (-1) * A
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-12078" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hneg_eq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Matrix</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Fin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Fin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-12139" data-verso-hover="1">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-12142" data-verso-hover="2">simp</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-12149" data-verso-hover="3">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hneg_eq</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  -- -1 and A commute
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-12186" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hcomm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Commute</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Matrix</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Fin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Fin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Commute.neg_one_left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A</span><span class="inter-text">
  -- orderOf(-1) = 2 in char 0
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-12302" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hord_neg1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">orderOf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Matrix</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Fin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Fin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-12368" data-verso-hover="1">by</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-12375" data-verso-hover="3">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">orderOf_neg_one</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ringChar_matrix_int</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-12421" data-verso-hover="2">simp</span><span class="inter-text">
  -- Coprimality: gcd(2, k) = 1 since k is odd
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-12475" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hcop</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.Coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.Coprime.symm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Odd.coprime_two_right</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hk_odd</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-12556" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hord_cop</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.Coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">orderOf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Matrix</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Fin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Fin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">orderOf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-12643" data-verso-hover="1">by</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-12650" data-verso-hover="3">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hord_neg1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_ord</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-12677" data-verso-hover="4">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hcop</span><span class="inter-text">
  -- Apply the product formula
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-12721" data-verso-hover="3">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hcomm.orderOf_mul_eq_mul_orderOf_of_coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hord_cop</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-12781" data-verso-hover="3">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hord_neg1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_ord</span><span class="unknown token" data-binding="">]</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/Lemmas.lean#L250-L278" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:orderOf-neg-of-odd-order');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>



</div> <!--main-text -->
</div> <!-- content-wrapper -->
</div> <!-- content -->
</div> <!-- wrapper -->

<nav class="prev_up_next">
  <svg  id="showmore-minus" class="icon icon-eye-minus showmore"><use xlink:href="symbol-defs.svg#icon-eye-minus"></use></svg>

  <svg  id="showmore-plus" class="icon icon-eye-plus showmore"><use xlink:href="symbol-defs.svg#icon-eye-plus"></use></svg>

  <a href="sect0005.html" title="The Crystallographic Restriction Theorem"><svg  class="icon icon-arrow-left "><use xlink:href="symbol-defs.svg#icon-arrow-left"></use></svg>
</a>
  <a href="index.html" title="Crystallographic Restriction Theorem"><svg  class="icon icon-arrow-up "><use xlink:href="symbol-defs.svg#icon-arrow-up"></use></svg>
</a>
</nav>

<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/plastex.js"></script>
<script type="text/javascript" src="js/svgxuse.js"></script>
<script type="text/javascript" src="js/js.cookie.min.js"></script>
<script type="text/javascript" src="js/showmore.js"></script>
</body>
</html>