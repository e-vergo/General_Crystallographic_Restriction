<!DOCTYPE html>
<html lang="en">
<head>
<script>
  MathJax = { 
    tex: {
		    inlineMath: [['$','$'], ['\\(','\\)']]
	} }
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<meta name="generator" content="plasTeX" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Companion Matrices</title>
<link rel="next" href="sect0005.html" title="The Crystallographic Restriction Theorem" />
<link rel="prev" href="sect0003.html" title="Integer Matrix Orders" />
<link rel="up" href="index.html" title="Crystallographic Restriction Theorem" />
<link rel="stylesheet" href="styles/theme-blue.css" />
<link rel="stylesheet" href="styles/showmore.css" />
<link rel="stylesheet" href="styles/blueprint.css" />
<link rel="stylesheet" href="styles/amsthm.css" />
<link rel="stylesheet" href="styles/style.css" />
</head>

<body>
<header>
<svg  id="toc-toggle" class="icon icon-list-numbered "><use xlink:href="symbol-defs.svg#icon-list-numbered"></use></svg>
<h1 id="doc_title"><a href="index.html">Crystallographic Restriction Theorem</a></h1>
</header>

<div class="wrapper">
<nav class="toc">
<ul class="sub-toc-0">
<li class="">
  <a href="sect0001.html"><span class="toc_ref">1</span> <span class="toc_entry">Introduction</span></a>
 </li>
<li class="">
  <a href="sect0002.html"><span class="toc_ref">2</span> <span class="toc_entry">The Psi Function</span></a>
 </li>
<li class="">
  <a href="sect0003.html"><span class="toc_ref">3</span> <span class="toc_entry">Integer Matrix Orders</span></a>
 </li>
<li class=" active current">
  <a href="sect0004.html"><span class="toc_ref">4</span> <span class="toc_entry">Companion Matrices</span></a>
 </li>
<li class="">
  <a href="sect0005.html"><span class="toc_ref">5</span> <span class="toc_entry">The Crystallographic Restriction Theorem</span></a>
 </li>
<li class="">
  <a href="sect0006.html"><span class="toc_ref">A</span> <span class="toc_entry">Appendix</span></a>
 </li>
<li ><a href="dep_graph_document.html">Dependency graph</a></li>
</ul>
</nav>

<div class="content">
<div class="content-wrapper">


<div class="main-text">
<h1 id="a0000000005">4 Companion Matrices</h1>
<p>Companion matrices provide a key construction for achieving orders via cyclotomic polynomials. </p>
<div class="definition_thmwrapper sbs-container theorem-style-definition" id="companion-def">
  <div class="sbs-latex-column">
    <div class="definition_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">4.0.1</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#companion-def">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.companion" class="lean_decl">Crystallographic.companion</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="definition_thmcontent">
    <p>      The companion matrix \(C(p)\) of a monic polynomial \(p = X^n + a_{n-1}X^{n-1} + \cdots + a_0\) is the \(n \times n\) matrix with \(1\)s on the subdiagonal and \(-a_i\) in the last column: </p>
<div class="displaymath" id="a0000000036">
  \[ C(p) = \begin{pmatrix}  0 

&  0 

&  \cdots 

&  -a_0 

\\ 1 

&  0 

&  \cdots 

&  -a_1 

\\ \vdots 

&  \ddots 

& &  \vdots 

\\ 0 

&  \cdots 

&  1 

&  -a_{n-1} 

\end{pmatrix} \]
</div>
<p> This construction produces a matrix whose characteristic polynomial equals \(p\), providing a canonical matrix realization for any monic polynomial. </p>

    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">def</span> <span class="lean-const lean-def" data-name="Crystallographic.companion" data-signature="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R" data-docs="The companion matrix of a monic polynomial p of degree n.

For p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:
```
[0  0  0  ...  0  -a_0    ]
[1  0  0  ...  0  -a_1    ]
[0  1  0  ...  0  -a_2    ]
[        ...              ]
[0  0  0  ...  1  -a_{n-1}]
```

The matrix has 1s on the subdiagonal and the negatives of the polynomial
coefficients in the last column.
" title="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R
The companion matrix of a monic polynomial p of degree n....">companion</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="R[X]" title="R[X]">p</span> : <span class="lean-var" data-type="Type u_1" title="Type u_1">R</span><span class="lean-bracket-2">[</span>X<span class="lean-bracket-2">]</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="p.Monic" title="p.Monic">_hp</span> : <span class="lean-var" data-type="R[X]" title="R[X]">p</span>.<span class="lean-const" data-name="Polynomial.Monic" data-signature="Polynomial.Monic.{u} {R : Type u} [Semiring R] (p : R[X]) : Prop" data-docs="a polynomial is `Monic` if its leading coefficient is 1 " title="Polynomial.Monic.{u} {R : Type u} [Semiring R] (p : R[X]) : Prop
a polynomial is `Monic` if its leading coefficient is 1 ">Monic</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">_hn</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">0</span> &lt; <span class="lean-var" data-type="R[X]" title="R[X]">p</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ" data-docs="`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ
`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. ">natDegree</span><span class="lean-bracket-1">)</span> :
    <span class="lean-const" data-name="Matrix" data-signature="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (α : Type v) : Type (max u u&#x27; v)" data-docs="`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`
and whose columns are indexed by `n`. " title="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (α : Type v) : Type (max u u&#x27; v)
`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`...">Matrix</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : ℕ) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : ℕ) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ" data-docs="`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ
`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. ">natDegree</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : ℕ) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : ℕ) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ" data-docs="`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ
`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. ">natDegree</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">R</span> :=
  <span class="lean-const" data-name="Matrix.of" data-signature="Matrix.of.{v, u_2, u_3} {m : Type u_2} {n : Type u_3} {α : Type v} : (m → n → α) ≃ Matrix m n α" data-docs="Cast a function into a matrix.

The two sides of the equivalence are definitionally equal types. We want to use an explicit cast
to distinguish the types because `Matrix` has different instances to pi types (such as `Pi.mul`,
which performs elementwise multiplication, vs `Matrix.mul`).

If you are defining a matrix, in terms of its entries, use `of (fun i j ↦ _)`. The
purpose of this approach is to ensure that terms of the form `(fun i j ↦ _) * (fun i j ↦ _)` do not
appear, as the type of `*` can be misleading.
" title="Matrix.of.{v, u_2, u_3} {m : Type u_2} {n : Type u_3} {α : Type v} : (m → n → α) ≃ Matrix m n α
Cast a function into a matrix....">Matrix.of</span> <span class="lean-keyword">fun</span> <span class="lean-var" data-type="Fin p.natDegree" title="Fin p.natDegree">i</span> <span class="lean-var" data-type="Fin p.natDegree" title="Fin p.natDegree">j</span> =&gt;
    <span class="lean-keyword" data-docs="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a &quot;dependent if-then-else&quot; `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
" title="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to">if</span> <span class="lean-var" data-type="Fin p.natDegree" title="Fin p.natDegree">j</span>.<span class="lean-const" data-name="Fin.val" data-signature="Fin.val {n : ℕ} (self : Fin n) : ℕ" data-docs="The number that is strictly less than `n`.

`Fin.val` is a coercion, so any `Fin n` can be used in a position where a `Nat` is expected.
" title="Fin.val {n : ℕ} (self : Fin n) : ℕ
The number that is strictly less than `n`....">val</span> + <span class="lean-expr" data-type="ℕ" title="ℕ">1</span> = <span class="lean-var" data-type="Fin p.natDegree" title="Fin p.natDegree">i</span>.<span class="lean-const" data-name="Fin.val" data-signature="Fin.val {n : ℕ} (self : Fin n) : ℕ" data-docs="The number that is strictly less than `n`.

`Fin.val` is a coercion, so any `Fin n` can be used in a position where a `Nat` is expected.
" title="Fin.val {n : ℕ} (self : Fin n) : ℕ
The number that is strictly less than `n`....">val</span> <span class="lean-keyword" data-docs="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a &quot;dependent if-then-else&quot; `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
" title="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to">then</span> <span class="lean-expr" data-type="R" title="R">1</span>
    <span class="lean-keyword" data-docs="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a &quot;dependent if-then-else&quot; `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
" title="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to">else</span> <span class="lean-keyword" data-docs="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a &quot;dependent if-then-else&quot; `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
" title="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to">if</span> <span class="lean-var" data-type="Fin p.natDegree" title="Fin p.natDegree">j</span>.<span class="lean-const" data-name="Fin.val" data-signature="Fin.val {n : ℕ} (self : Fin n) : ℕ" data-docs="The number that is strictly less than `n`.

`Fin.val` is a coercion, so any `Fin n` can be used in a position where a `Nat` is expected.
" title="Fin.val {n : ℕ} (self : Fin n) : ℕ
The number that is strictly less than `n`....">val</span> + <span class="lean-expr" data-type="ℕ" title="ℕ">1</span> = <span class="lean-var" data-type="R[X]" title="R[X]">p</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ" data-docs="`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ
`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. ">natDegree</span> <span class="lean-keyword" data-docs="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a &quot;dependent if-then-else&quot; `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
" title="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to">then</span> -<span class="lean-var" data-type="R[X]" title="R[X]">p</span>.<span class="lean-const" data-name="Polynomial.coeff" data-signature="Polynomial.coeff.{u} {R : Type u} [Semiring R] : R[X] → ℕ → R" data-docs="`coeff p n` (often denoted `p.coeff n`) is the coefficient of `X^n` in `p`. " title="Polynomial.coeff.{u} {R : Type u} [Semiring R] : R[X] → ℕ → R
`coeff p n` (often denoted `p.coeff n`) is the coefficient of `X^n` in `p`. ">coeff</span> <span class="lean-var" data-type="Fin p.natDegree" title="Fin p.natDegree">i</span>.<span class="lean-const" data-name="Fin.val" data-signature="Fin.val {n : ℕ} (self : Fin n) : ℕ" data-docs="The number that is strictly less than `n`.

`Fin.val` is a coercion, so any `Fin n` can be used in a position where a `Nat` is expected.
" title="Fin.val {n : ℕ} (self : Fin n) : ℕ
The number that is strictly less than `n`....">val</span>
    <span class="lean-keyword" data-docs="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a &quot;dependent if-then-else&quot; `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
" title="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to">else</span> <span class="lean-expr" data-type="R" title="R">0</span></code><code class="lean-proof-body"><span class="lean-plain">(p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
    Matrix (Fin p.natDegree) (Fin p.natDegree) R :=
  Matrix.of fun i j =&gt;
    if j.val + 1 = i.val then 1
    else if j.val + 1 = p.natDegree then -p.coeff i.val
    else 0</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Basic.lean#L46-L74" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>

<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:companion-charpoly">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">4.0.1</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#thm:companion-charpoly">#</a>
    
    <a class="icon proof" href="sect0004.html#a0000000037"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0004.html#companion-def">Definition 4.0.1</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.companion_charpoly" class="lean_decl">Crystallographic.companion_charpoly</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>        The characteristic polynomial of the companion matrix \(C(p)\) equals \(p\): \(\chi _{C(p)} = p\). The proof proceeds by induction on the degree, using cofactor expansion along the first column. The key insight is that the minor structure reduces to smaller companion matrices, and the base case (degree 1) follows by direct computation.  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000037">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By induction on the degree \(n\). For the base case \(n = 1\), direct computation gives \(\det (XI - C) = X + a_0\). For \(n {\gt} 1\), expand along the first column: the \((1,1)\) minor is the companion matrix of lower degree, and the \((2,1)\) minor contributes the constant term. The recurrence matches the polynomial coefficients. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">theorem</span> <span class="lean-const lean-def" data-name="Crystallographic.companion_charpoly" data-signature="Crystallographic.companion_charpoly.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic) (hn : 0 &lt; p.natDegree) :
  (companion p hp hn).charpoly = p" data-docs="The characteristic polynomial of the companion matrix equals the original polynomial.

This is the fundamental property of companion matrices: they are constructed precisely
so that their characteristic polynomial matches the given monic polynomial.

The proof proceeds by strong induction on the degree n. For degree 1, direct computation
shows both sides equal X + C(a_0). For degree n+1, Laplace expansion along the first
column gives a recurrence matching the polynomial structure.
" title="Crystallographic.companion_charpoly.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic) (hn : 0 &lt; p.natDegree) :
  (companion p hp hn).charpoly = p
The characteristic polynomial of the companion matrix equals the original polynomial....">companion_charpoly</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="R[X]" title="R[X]">p</span> : <span class="lean-var" data-type="Type u_1" title="Type u_1">R</span><span class="lean-bracket-2">[</span>X<span class="lean-bracket-2">]</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> : <span class="lean-var" data-type="R[X]" title="R[X]">p</span>.<span class="lean-const" data-name="Polynomial.Monic" data-signature="Polynomial.Monic.{u} {R : Type u} [Semiring R] (p : R[X]) : Prop" data-docs="a polynomial is `Monic` if its leading coefficient is 1 " title="Polynomial.Monic.{u} {R : Type u} [Semiring R] (p : R[X]) : Prop
a polynomial is `Monic` if its leading coefficient is 1 ">Monic</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">0</span> &lt; <span class="lean-var" data-type="R[X]" title="R[X]">p</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ" data-docs="`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ
`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. ">natDegree</span><span class="lean-bracket-1">)</span> :
    <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.companion" data-signature="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R" data-docs="The companion matrix of a monic polynomial p of degree n.

For p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:
```
[0  0  0  ...  0  -a_0    ]
[1  0  0  ...  0  -a_1    ]
[0  1  0  ...  0  -a_2    ]
[        ...              ]
[0  0  0  ...  1  -a_{n-1}]
```

The matrix has 1s on the subdiagonal and the negatives of the polynomial
coefficients in the last column.
" title="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R
The companion matrix of a monic polynomial p of degree n....">companion</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Matrix.charpoly" data-signature="Matrix.charpoly.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  R[X]" data-docs="The characteristic polynomial of a matrix `M` is given by $\det (t I - M)$. " title="Matrix.charpoly.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  R[X]
The characteristic polynomial of a matrix `M` is given by $\det (t I - M)$. ">charpoly</span> = <span class="lean-var" data-type="R[X]" title="R[X]">p</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for
a description of supported patterns.

```lean
obtain ⟨patt⟩ : type := proof
```
is equivalent to
```lean
have h : type := proof
rcases h with ⟨patt⟩
```

If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.

If `type` is omitted, `:= proof` is required.
" title="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for">obtain</span> <span class="lean-bracket-1">⟨</span><span class="lean-var" data-type="ℕ" title="ℕ">n</span>, <span class="lean-var" data-type="p.natDegree = n + 1" title="p.natDegree = n + 1">hn_eq</span><span class="lean-bracket-1">⟩</span> : <span class="lean-operator">∃</span> <span class="lean-var" data-type="ℕ" title="ℕ">n</span>, <span class="lean-var" data-type="R[X]" title="R[X]">p</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ" data-docs="`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ
`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. ">natDegree</span> = <span class="lean-var" data-type="ℕ" title="ℕ">n</span> + <span class="lean-expr" data-type="ℕ" title="ℕ">1</span> := <span class="lean-const" data-name="Nat.exists_eq_succ_of_ne_zero" data-signature="Nat.exists_eq_succ_of_ne_zero {n : ℕ} : n ≠ 0 → ∃ k, n = k.succ" title="Nat.exists_eq_succ_of_ne_zero {n : ℕ} : n ≠ 0 → ∃ k, n = k.succ">Nat.exists_eq_succ_of_ne_zero</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span>.<span class="lean-const" data-name="LT.lt.ne&#x27;" data-signature="LT.lt.ne&#x27;.{u_1} {α : Type u_1} [Preorder α] {a b : α} (h : b &lt; a) : a ≠ b" title="LT.lt.ne&#x27;.{u_1} {α : Type u_1} [Preorder α] {a b : α} (h : b &lt; a) : a ≠ b">ne&#x27;</span>
  <span class="lean-keyword" data-docs="Assuming `x` is a variable in the local context with an inductive type,
`induction x` applies induction on `x` to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on `x`,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,
`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,
and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.
Here the names `a` and `ih₁` are chosen automatically and are not accessible.
You can use `with` to provide the variables names for each constructor.
- `induction e`, where `e` is an expression instead of a variable,
  generalizes `e` in the goal, and then performs induction on the resulting variable.
- `induction e using r` allows the user to specify the principle of induction that should be used.
  Here `r` should be a term whose result type must be of the form `C t`,
  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables
- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,
  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.
  In other words, the net effect is that each inductive hypothesis is generalized.
- Given `x : Nat`, `induction x with | zero =&gt; tac₁ | succ x&#x27; ih =&gt; tac₂`
  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.
" title="Assuming `x` is a variable in the local context with an inductive type,">induction</span> <span class="lean-var" data-type="ℕ" title="ℕ">n</span> <span class="lean-keyword">generalizing</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-keyword" data-docs="After `with`, there is an optional tactic that runs on all branches, and
then a list of alternatives.
" title="After `with`, there is an optional tactic that runs on all branches, and">with</span>
  | <span class="lean-const" data-name="Nat.zero" data-signature="Nat.zero : ℕ" data-docs="Zero, the smallest natural number.

Using `Nat.zero` explicitly should usually be avoided in favor of the literal `0`, which is the
[simp normal form](https://lean-lang.org/doc/reference/4.27.0-rc1/find/?domain=Verso.Genre.Manual.section&amp;name=simp-normal-forms).
" title="Nat.zero : ℕ
Zero, the smallest natural number....">zero</span> =&gt; <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Crystallographic.companion_charpoly_of_natDegree_one" data-signature="Crystallographic.companion_charpoly_of_natDegree_one.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) (hdeg : p.natDegree = 1) : (companion p hp hn).charpoly = p" data-docs="For a monic polynomial of degree 1, the characteristic polynomial of its companion
matrix equals the polynomial. Both sides equal `X + C(p.coeff 0)`. " title="Crystallographic.companion_charpoly_of_natDegree_one.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) (hdeg : p.natDegree = 1) : (companion p hp hn).charpoly = p
For a monic polynomial of degree 1, the characteristic polynomial of its companion...">companion_charpoly_of_natDegree_one</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span> <span class="lean-var" data-type="p.natDegree = 0 + 1" title="p.natDegree = 0 + 1">hn_eq</span>
  | <span class="lean-const" data-name="Nat.succ" data-signature="Nat.succ (n : ℕ) : ℕ" data-docs="The successor of a natural number `n`.

Using `Nat.succ n` should usually be avoided in favor of `n + 1`, which is the [simp normal
form](https://lean-lang.org/doc/reference/4.27.0-rc1/find/?domain=Verso.Genre.Manual.section&amp;name=simp-normal-forms).
" title="Nat.succ (n : ℕ) : ℕ
The successor of a natural number `n`....">succ</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> <span class="lean-var" data-type="∀ (p : R[X]) (hp : p.Monic) (hn : 0 &lt; p.natDegree), p.natDegree = m + 1 → (companion p hp hn).charpoly = p" title="∀ (p : R[X]) (hp : p.Monic) (hn : 0 &lt; p.natDegree), p.natDegree = m + 1 → (companion p hp hn).charpoly = p">IH</span> =&gt;
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="p.natDegree = m + 2" title="p.natDegree = m + 2">hdeg</span> : <span class="lean-var" data-type="R[X]" title="R[X]">p</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ" data-docs="`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ
`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. ">natDegree</span> = <span class="lean-var" data-type="ℕ" title="ℕ">m</span> + <span class="lean-expr" data-type="ℕ" title="ℕ">2</span> := <span class="lean-var" data-type="p.natDegree = m + 1 + 1" title="p.natDegree = m + 1 + 1">hn_eq</span>
    <span class="lean-keyword" data-docs="The `let` tactic is for adding definitions to the local context of the main goal.
The definition can be unfolded, unlike definitions introduced by `have`.

* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.
* `let x := e` uses the type of `e` for `t`.
* `let : t := e` and `let := e` use `this` for the name of the hypothesis.
* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that let only one applicable constructor.
  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the
  local variables `x : α`, `y : β`, and `z : γ`.
* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `let` term.

## Properties and relations

* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics
  such as `simp`, `dsimp`, `unfold`, and `subst`.
* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.
  The tactic might fail if the local context depends on the value of the variable.
* The `let` tactic is preferred for data (non-propositions).
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
" title="The `let` tactic is for adding definitions to the local context of the main goal.">let</span> <span class="lean-var" data-type="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]" title="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]">A</span> : <span class="lean-const" data-name="Matrix" data-signature="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (α : Type v) : Type (max u u&#x27; v)" data-docs="`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`
and whose columns are indexed by `n`. " title="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (α : Type v) : Type (max u u&#x27; v)
`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`...">Matrix</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : ℕ) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : ℕ) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-bracket-2">(</span><span class="lean-var" data-type="ℕ" title="ℕ">m</span> + <span class="lean-expr" data-type="ℕ" title="ℕ">2</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : ℕ) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : ℕ) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-bracket-2">(</span><span class="lean-var" data-type="ℕ" title="ℕ">m</span> + <span class="lean-expr" data-type="ℕ" title="ℕ">2</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">R</span><span class="lean-bracket-1">[</span>X<span class="lean-bracket-1">]</span> :=
      <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.companion" data-signature="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R" data-docs="The companion matrix of a monic polynomial p of degree n.

For p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:
```
[0  0  0  ...  0  -a_0    ]
[1  0  0  ...  0  -a_1    ]
[0  1  0  ...  0  -a_2    ]
[        ...              ]
[0  0  0  ...  1  -a_{n-1}]
```

The matrix has 1s on the subdiagonal and the negatives of the polynomial
coefficients in the last column.
" title="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R
The companion matrix of a monic polynomial p of degree n....">companion</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Matrix.charmatrix" data-signature="Matrix.charmatrix.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  Matrix n n R[X]" data-docs="The &quot;characteristic matrix&quot; of `M : Matrix n n R` is the matrix of polynomials $t I - M$.
The determinant of this matrix is the characteristic polynomial.
" title="Matrix.charmatrix.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  Matrix n n R[X]
The &quot;characteristic matrix&quot; of `M : Matrix n n R` is the matrix of polynomials $t I - M$....">charmatrix</span>.<span class="lean-const" data-name="Matrix.submatrix" data-signature="Matrix.submatrix.{v, u_1, u_2, u_3, u_4} {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type v}
  (A : Matrix m n α) (r : l → m) (c : o → n) : Matrix l o α" data-docs="Given maps `(r : l → m)` and `(c : o → n)` reindexing the rows and columns of
a matrix `M : Matrix m n α`, the matrix `M.submatrix r c : Matrix l o α` is defined
by `(M.submatrix r c) i j = M (r i) (c j)` for `(i,j) : l × o`.
Note that the total number of row and columns does not have to be preserved. " title="Matrix.submatrix.{v, u_1, u_2, u_3, u_4} {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type v}
  (A : Matrix m n α) (r : l → m) (c : o → n) : Matrix l o α
Given maps `(r : l → m)` and `(c : o → n)` reindexing the rows and columns of...">submatrix</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Fin.cast" data-signature="Fin.cast {n m : ℕ} (eq : n = m) (i : Fin n) : Fin m" data-docs="Uses a proof that two bounds are equal to allow a value bounded by one to be used with the other.

In other words, when `eq : n = m`, `Fin.cast eq i` converts `i : Fin n` into a `Fin m`.
" title="Fin.cast {n m : ℕ} (eq : n = m) (i : Fin n) : Fin m
Uses a proof that two bounds are equal to allow a value bounded by one to be used with the other....">Fin.cast</span> <span class="lean-var" data-type="p.natDegree = m + 2" title="p.natDegree = m + 2">hdeg</span>.<span class="lean-const" data-name="Eq.symm" data-signature="Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a" data-docs="Equality is symmetric: if `a = b` then `b = a`.

Because this is in the `Eq` namespace, if you have a variable `h : a = b`,
`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.

For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
" title="Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a
Equality is symmetric: if `a = b` then `b = a`....">symm</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Fin.cast" data-signature="Fin.cast {n m : ℕ} (eq : n = m) (i : Fin n) : Fin m" data-docs="Uses a proof that two bounds are equal to allow a value bounded by one to be used with the other.

In other words, when `eq : n = m`, `Fin.cast eq i` converts `i : Fin n` into a `Fin m`.
" title="Fin.cast {n m : ℕ} (eq : n = m) (i : Fin n) : Fin m
Uses a proof that two bounds are equal to allow a value bounded by one to be used with the other....">Fin.cast</span> <span class="lean-var" data-type="p.natDegree = m + 2" title="p.natDegree = m + 2">hdeg</span>.<span class="lean-const" data-name="Eq.symm" data-signature="Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a" data-docs="Equality is symmetric: if `a = b` then `b = a`.

Because this is in the `Eq` namespace, if you have a variable `h : a = b`,
`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.

For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
" title="Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a
Equality is symmetric: if `a = b` then `b = a`....">symm</span><span class="lean-bracket-1">)</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯)" title="A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯)">hA_def</span> : <span class="lean-var" data-type="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]" title="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]">A</span> = <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.companion" data-signature="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R" data-docs="The companion matrix of a monic polynomial p of degree n.

For p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:
```
[0  0  0  ...  0  -a_0    ]
[1  0  0  ...  0  -a_1    ]
[0  1  0  ...  0  -a_2    ]
[        ...              ]
[0  0  0  ...  1  -a_{n-1}]
```

The matrix has 1s on the subdiagonal and the negatives of the polynomial
coefficients in the last column.
" title="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R
The companion matrix of a monic polynomial p of degree n....">companion</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Matrix.charmatrix" data-signature="Matrix.charmatrix.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  Matrix n n R[X]" data-docs="The &quot;characteristic matrix&quot; of `M : Matrix n n R` is the matrix of polynomials $t I - M$.
The determinant of this matrix is the characteristic polynomial.
" title="Matrix.charmatrix.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  Matrix n n R[X]
The &quot;characteristic matrix&quot; of `M : Matrix n n R` is the matrix of polynomials $t I - M$....">charmatrix</span>.<span class="lean-const" data-name="Matrix.submatrix" data-signature="Matrix.submatrix.{v, u_1, u_2, u_3, u_4} {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type v}
  (A : Matrix m n α) (r : l → m) (c : o → n) : Matrix l o α" data-docs="Given maps `(r : l → m)` and `(c : o → n)` reindexing the rows and columns of
a matrix `M : Matrix m n α`, the matrix `M.submatrix r c : Matrix l o α` is defined
by `(M.submatrix r c) i j = M (r i) (c j)` for `(i,j) : l × o`.
Note that the total number of row and columns does not have to be preserved. " title="Matrix.submatrix.{v, u_1, u_2, u_3, u_4} {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type v}
  (A : Matrix m n α) (r : l → m) (c : o → n) : Matrix l o α
Given maps `(r : l → m)` and `(c : o → n)` reindexing the rows and columns of...">submatrix</span>
        <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Fin.cast" data-signature="Fin.cast {n m : ℕ} (eq : n = m) (i : Fin n) : Fin m" data-docs="Uses a proof that two bounds are equal to allow a value bounded by one to be used with the other.

In other words, when `eq : n = m`, `Fin.cast eq i` converts `i : Fin n` into a `Fin m`.
" title="Fin.cast {n m : ℕ} (eq : n = m) (i : Fin n) : Fin m
Uses a proof that two bounds are equal to allow a value bounded by one to be used with the other....">Fin.cast</span> <span class="lean-var" data-type="p.natDegree = m + 2" title="p.natDegree = m + 2">hdeg</span>.<span class="lean-const" data-name="Eq.symm" data-signature="Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a" data-docs="Equality is symmetric: if `a = b` then `b = a`.

Because this is in the `Eq` namespace, if you have a variable `h : a = b`,
`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.

For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
" title="Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a
Equality is symmetric: if `a = b` then `b = a`....">symm</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Fin.cast" data-signature="Fin.cast {n m : ℕ} (eq : n = m) (i : Fin n) : Fin m" data-docs="Uses a proof that two bounds are equal to allow a value bounded by one to be used with the other.

In other words, when `eq : n = m`, `Fin.cast eq i` converts `i : Fin n` into a `Fin m`.
" title="Fin.cast {n m : ℕ} (eq : n = m) (i : Fin n) : Fin m
Uses a proof that two bounds are equal to allow a value bounded by one to be used with the other....">Fin.cast</span> <span class="lean-var" data-type="p.natDegree = m + 2" title="p.natDegree = m + 2">hdeg</span>.<span class="lean-const" data-name="Eq.symm" data-signature="Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a" data-docs="Equality is symmetric: if `a = b` then `b = a`.

Because this is in the `Eq` namespace, if you have a variable `h : a = b`,
`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.

For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
" title="Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a
Equality is symmetric: if `a = b` then `b = a`....">symm</span><span class="lean-bracket-1">)</span> := <span class="lean-const" data-name="rfl" data-signature="rfl.{u} {α : Sort u} {a : α} : a = a" data-docs="`rfl : a = a` is the unique constructor of the equality type. This is the
same as `Eq.refl` except that it takes `a` implicitly instead of explicitly.

This is a more powerful theorem than it may appear at first, because although
the statement of the theorem is `a = a`, Lean will allow anything that is
definitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in
Lean by `rfl`, because both sides are the same up to definitional equality.
" title="rfl.{u} {α : Sort u} {a : α} : a = a
`rfl : a = a` is the unique constructor of the equality type. This is the...">rfl</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="A.det = (companion p hp hn).charmatrix.det" title="A.det = (companion p hp hn).charmatrix.det">hA_det</span> : <span class="lean-var" data-type="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]" title="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]">A</span>.<span class="lean-const" data-name="Matrix.det" data-signature="Matrix.det.{v, u_2} {n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] (M : Matrix n n R) : R" data-docs="The determinant of a matrix given by the Leibniz formula. " title="Matrix.det.{v, u_2} {n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] (M : Matrix n n R) : R
The determinant of a matrix given by the Leibniz formula. ">det</span> = <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.companion" data-signature="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R" data-docs="The companion matrix of a monic polynomial p of degree n.

For p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:
```
[0  0  0  ...  0  -a_0    ]
[1  0  0  ...  0  -a_1    ]
[0  1  0  ...  0  -a_2    ]
[        ...              ]
[0  0  0  ...  1  -a_{n-1}]
```

The matrix has 1s on the subdiagonal and the negatives of the polynomial
coefficients in the last column.
" title="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R
The companion matrix of a monic polynomial p of degree n....">companion</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Matrix.charmatrix" data-signature="Matrix.charmatrix.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  Matrix n n R[X]" data-docs="The &quot;characteristic matrix&quot; of `M : Matrix n n R` is the matrix of polynomials $t I - M$.
The determinant of this matrix is the characteristic polynomial.
" title="Matrix.charmatrix.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  Matrix n n R[X]
The &quot;characteristic matrix&quot; of `M : Matrix n n R` is the matrix of polynomials $t I - M$....">charmatrix</span>.<span class="lean-const" data-name="Matrix.det" data-signature="Matrix.det.{v, u_2} {n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] (M : Matrix n n R) : R" data-docs="The determinant of a matrix given by the Leibniz formula. " title="Matrix.det.{v, u_2} {n : Type u_2} [DecidableEq n] [Fintype n] {R : Type v} [CommRing R] (M : Matrix n n R) : R
The determinant of a matrix given by the Leibniz formula. ">det</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="A = (companion p hp hn).charmatrix.submatrix ⇑(finCongr ⋯) ⇑(finCongr ⋯)" title="A = (companion p hp hn).charmatrix.submatrix ⇑(finCongr ⋯) ⇑(finCongr ⋯)">heq</span> : <span class="lean-var" data-type="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]" title="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]">A</span> = <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.companion" data-signature="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R" data-docs="The companion matrix of a monic polynomial p of degree n.

For p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:
```
[0  0  0  ...  0  -a_0    ]
[1  0  0  ...  0  -a_1    ]
[0  1  0  ...  0  -a_2    ]
[        ...              ]
[0  0  0  ...  1  -a_{n-1}]
```

The matrix has 1s on the subdiagonal and the negatives of the polynomial
coefficients in the last column.
" title="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R
The companion matrix of a monic polynomial p of degree n....">companion</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Matrix.charmatrix" data-signature="Matrix.charmatrix.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  Matrix n n R[X]" data-docs="The &quot;characteristic matrix&quot; of `M : Matrix n n R` is the matrix of polynomials $t I - M$.
The determinant of this matrix is the characteristic polynomial.
" title="Matrix.charmatrix.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  Matrix n n R[X]
The &quot;characteristic matrix&quot; of `M : Matrix n n R` is the matrix of polynomials $t I - M$....">charmatrix</span>.<span class="lean-const" data-name="Matrix.submatrix" data-signature="Matrix.submatrix.{v, u_1, u_2, u_3, u_4} {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type v}
  (A : Matrix m n α) (r : l → m) (c : o → n) : Matrix l o α" data-docs="Given maps `(r : l → m)` and `(c : o → n)` reindexing the rows and columns of
a matrix `M : Matrix m n α`, the matrix `M.submatrix r c : Matrix l o α` is defined
by `(M.submatrix r c) i j = M (r i) (c j)` for `(i,j) : l × o`.
Note that the total number of row and columns does not have to be preserved. " title="Matrix.submatrix.{v, u_1, u_2, u_3, u_4} {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type v}
  (A : Matrix m n α) (r : l → m) (c : o → n) : Matrix l o α
Given maps `(r : l → m)` and `(c : o → n)` reindexing the rows and columns of...">submatrix</span>
          <span class="lean-bracket-1">(</span><span class="lean-const" data-name="finCongr" data-signature="finCongr {n m : ℕ} (eq : n = m) : Fin n ≃ Fin m" data-docs="The &#x27;identity&#x27; equivalence between `Fin m` and `Fin n` when `m = n`. " title="finCongr {n m : ℕ} (eq : n = m) : Fin n ≃ Fin m
The &#x27;identity&#x27; equivalence between `Fin m` and `Fin n` when `m = n`. ">finCongr</span> <span class="lean-var" data-type="p.natDegree = m + 2" title="p.natDegree = m + 2">hdeg</span>.<span class="lean-const" data-name="Eq.symm" data-signature="Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a" data-docs="Equality is symmetric: if `a = b` then `b = a`.

Because this is in the `Eq` namespace, if you have a variable `h : a = b`,
`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.

For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
" title="Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a
Equality is symmetric: if `a = b` then `b = a`....">symm</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="finCongr" data-signature="finCongr {n m : ℕ} (eq : n = m) : Fin n ≃ Fin m" data-docs="The &#x27;identity&#x27; equivalence between `Fin m` and `Fin n` when `m = n`. " title="finCongr {n m : ℕ} (eq : n = m) : Fin n ≃ Fin m
The &#x27;identity&#x27; equivalence between `Fin m` and `Fin n` when `m = n`. ">finCongr</span> <span class="lean-var" data-type="p.natDegree = m + 2" title="p.natDegree = m + 2">hdeg</span>.<span class="lean-const" data-name="Eq.symm" data-signature="Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a" data-docs="Equality is symmetric: if `a = b` then `b = a`.

Because this is in the `Eq` namespace, if you have a variable `h : a = b`,
`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.

For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
" title="Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a
Equality is symmetric: if `a = b` then `b = a`....">symm</span><span class="lean-bracket-1">)</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
        <span class="lean-keyword" data-docs="Applies extensionality lemmas that are registered with the `@[ext]` attribute.
* `ext pat*` applies extensionality theorems as much as possible,
  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.
  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.
* Without patterns,`ext` applies extensionality lemmas as much
  as possible but introduces anonymous hypotheses whenever needed.
* `ext pat* : n` applies ext theorems only up to depth `n`.

The `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.

Unused patterns will generate warning.
Patterns that don&#x27;t match the variables will typically result in the introduction of anonymous hypotheses.
" title="Applies extensionality lemmas that are registered with the `@[ext]` attribute.">ext</span> <span class="lean-var" data-type="Fin (m + 2)" title="Fin (m + 2)">i</span> <span class="lean-var" data-type="Fin (m + 2)" title="Fin (m + 2)">j</span>; <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions.-
- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.
- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idᵢ`.
- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If
  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis
  `hᵢ` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Matrix.submatrix_apply" data-signature="Matrix.submatrix_apply.{v, u_1, u_2, u_3, u_4} {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type v}
  (A : Matrix m n α) (r : l → m) (c : o → n) (i : l) (j : o) : A.submatrix r c i j = A (r i) (c j)" title="Matrix.submatrix_apply.{v, u_1, u_2, u_3, u_4} {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type v}
  (A : Matrix m n α) (r : l → m) (c : o → n) (i : l) (j : o) : A.submatrix r c i j = A (r i) (c j)">Matrix.submatrix_apply</span><span class="lean-bracket-1">]</span>; <span class="lean-keyword" data-docs="This tactic applies to a goal whose target has the form `x ~ x`,
where `~` is equality, heterogeneous equality or any relation that
has a reflexivity lemma tagged with the attribute @[refl].
" title="This tactic applies to a goal whose target has the form `x ~ x`,">rfl</span>
      <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="A = (companion p hp hn).charmatrix.submatrix ⇑(finCongr ⋯) ⇑(finCongr ⋯)" title="A = (companion p hp hn).charmatrix.submatrix ⇑(finCongr ⋯) ⇑(finCongr ⋯)">heq</span>, <span class="lean-const" data-name="Matrix.det_submatrix_equiv_self" data-signature="Matrix.det_submatrix_equiv_self.{v, u_1, u_2} {m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m]
  [Fintype m] {R : Type v} [CommRing R] (e : n ≃ m) (A : Matrix m m R) : (A.submatrix ⇑e ⇑e).det = A.det" data-docs="Permuting rows and columns with the same equivalence does not change the determinant. " title="Matrix.det_submatrix_equiv_self.{v, u_1, u_2} {m : Type u_1} {n : Type u_2} [DecidableEq n] [Fintype n] [DecidableEq m]
  [Fintype m] {R : Type v} [CommRing R] (e : n ≃ m) (A : Matrix m m R) : (A.submatrix ⇑e ⇑e).det = A.det
Permuting rows and columns with the same equivalence does not change the determinant. ">Matrix.det_submatrix_equiv_self</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Matrix.charpoly" data-signature="Matrix.charpoly.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  R[X]" data-docs="The characteristic polynomial of a matrix `M` is given by $\det (t I - M)$. " title="Matrix.charpoly.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  R[X]
The characteristic polynomial of a matrix `M` is given by $\det (t I - M)$. ">Matrix.charpoly</span>, <span class="lean-operator">←</span> <span class="lean-var" data-type="A.det = (companion p hp hn).charmatrix.det" title="A.det = (companion p hp hn).charmatrix.det">hA_det</span>, <span class="lean-const" data-name="Matrix.det_succ_column_zero" data-signature="Matrix.det_succ_column_zero.{v} {R : Type v} [CommRing R] {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) R) :
  A.det = ∑ i, (-1) ^ ↑i * A i 0 * (A.submatrix i.succAbove Fin.succ).det" data-docs="Laplacian expansion of the determinant of an `n+1 × n+1` matrix along column 0. " title="Matrix.det_succ_column_zero.{v} {R : Type v} [CommRing R] {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) R) :
  A.det = ∑ i, (-1) ^ ↑i * A i 0 * (A.submatrix i.succAbove Fin.succ).det
Laplacian expansion of the determinant of an `n+1 × n+1` matrix along column 0. ">Matrix.det_succ_column_zero</span><span class="lean-bracket-1">]</span>
    <span class="lean-comment">-- Get column structure and apply Laplace simplification</span>
    <span class="lean-keyword" data-docs="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for
a description of supported patterns.

```lean
obtain ⟨patt⟩ : type := proof
```
is equivalent to
```lean
have h : type := proof
rcases h with ⟨patt⟩
```

If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.

If `type` is omitted, `:= proof` is required.
" title="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for">obtain</span> <span class="lean-bracket-1">⟨</span><span class="lean-var" data-type="A 0 0 = X" title="A 0 0 = X">hA00</span>, <span class="lean-var" data-type="A 1 0 = -1" title="A 1 0 = -1">hA10</span>, <span class="lean-var" data-type="∀ (i : Fin (m + 2)), 2 ≤ ↑i → A i 0 = 0" title="∀ (i : Fin (m + 2)), 2 ≤ ↑i → A i 0 = 0">hA_other</span><span class="lean-bracket-1">⟩</span> := <span class="lean-const" data-name="Crystallographic.companion_charmatrix_col_zero" data-signature="Crystallographic.companion_charmatrix_col_zero.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdeg : p.natDegree = m + 2) (A : Matrix (Fin (m + 2)) (Fin (m + 2)) R[X])
  (hA_def : A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯)) :
  A 0 0 = X ∧ A 1 0 = -1 ∧ ∀ (i : Fin (m + 2)), 2 ≤ ↑i → A i 0 = 0" data-docs="The first column of the charmatrix of a companion matrix has `X` at position `(0,0)`,
`-1` at position `(1,0)`, and `0` at all positions `(i,0)` for `i &gt;= 2`. " title="Crystallographic.companion_charmatrix_col_zero.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdeg : p.natDegree = m + 2) (A : Matrix (Fin (m + 2)) (Fin (m + 2)) R[X])
  (hA_def : A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯)) :
  A 0 0 = X ∧ A 1 0 = -1 ∧ ∀ (i : Fin (m + 2)), 2 ≤ ↑i → A i 0 = 0
The first column of the charmatrix of a companion matrix has `X` at position `(0,0)`,...">companion_charmatrix_col_zero</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> <span class="lean-var" data-type="p.natDegree = m + 2" title="p.natDegree = m + 2">hdeg</span> <span class="lean-var" data-type="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]" title="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]">A</span> <span class="lean-var" data-type="A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯)" title="A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯)">hA_def</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Crystallographic.companion_charmatrix_laplace_col_zero" data-signature="Crystallographic.companion_charmatrix_laplace_col_zero.{u_1} {R : Type u_1} [CommRing R] (m : ℕ)
  (A : Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]) (hA00 : A 0 0 = X) (hA10 : A 1 0 = -1)
  (hA_other : ∀ (i : Fin (m + 2)), 2 ≤ ↑i → A i 0 = 0) :
  ∑ i, (-1) ^ ↑i * A i 0 * (A.submatrix i.succAbove Fin.succ).det =
    X * (A.submatrix (Fin.succAbove 0) Fin.succ).det + (A.submatrix (Fin.succAbove 1) Fin.succ).det" data-docs="The Laplace expansion of a matrix along column 0 reduces to two terms when only
entries at rows 0 and 1 are nonzero. This applies to the charmatrix of companion matrices
because entries `A i 0 = 0` for all `i &gt;= 2`. " title="Crystallographic.companion_charmatrix_laplace_col_zero.{u_1} {R : Type u_1} [CommRing R] (m : ℕ)
  (A : Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]) (hA00 : A 0 0 = X) (hA10 : A 1 0 = -1)
  (hA_other : ∀ (i : Fin (m + 2)), 2 ≤ ↑i → A i 0 = 0) :
  ∑ i, (-1) ^ ↑i * A i 0 * (A.submatrix i.succAbove Fin.succ).det =
    X * (A.submatrix (Fin.succAbove 0) Fin.succ).det + (A.submatrix (Fin.succAbove 1) Fin.succ).det
The Laplace expansion of a matrix along column 0 reduces to two terms when only...">companion_charmatrix_laplace_col_zero</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> <span class="lean-var" data-type="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]" title="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]">A</span> <span class="lean-var" data-type="A 0 0 = X" title="A 0 0 = X">hA00</span> <span class="lean-var" data-type="A 1 0 = -1" title="A 1 0 = -1">hA10</span> <span class="lean-var" data-type="∀ (i : Fin (m + 2)), 2 ≤ ↑i → A i 0 = 0" title="∀ (i : Fin (m + 2)), 2 ≤ ↑i → A i 0 = 0">hA_other</span>, <span class="lean-operator">←</span> <span class="lean-const" data-name="Polynomial.X_mul_divX_add" data-signature="Polynomial.X_mul_divX_add.{u} {R : Type u} [Semiring R] (p : R[X]) : X * p.divX + C (p.coeff 0) = p" title="Polynomial.X_mul_divX_add.{u} {R : Type u} [Semiring R] (p : R[X]) : X * p.divX + C (p.coeff 0) = p">Polynomial.X_mul_divX_add</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span>,
      <span class="lean-const" data-name="Crystallographic.companion_charmatrix_minor00_det" data-signature="Crystallographic.companion_charmatrix_minor00_det.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdeg : p.natDegree = m + 2) (A : Matrix (Fin (m + 2)) (Fin (m + 2)) R[X])
  (hA_def : A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯))
  (IH :
    ∀ (q : R[X]) (hq : q.Monic) (hq_pos : 0 &lt; q.natDegree),
      q.natDegree = m + 1 → (companion q hq hq_pos).charpoly = q) :
  (A.submatrix (Fin.succAbove 0) Fin.succ).det = p.divX" data-docs="The determinant of the (0,0)-minor of the charmatrix equals `p.divX`.
This follows because the minor equals the charmatrix of companion(p.divX), and we
apply the induction hypothesis for the characteristic polynomial theorem. " title="Crystallographic.companion_charmatrix_minor00_det.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdeg : p.natDegree = m + 2) (A : Matrix (Fin (m + 2)) (Fin (m + 2)) R[X])
  (hA_def : A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯))
  (IH :
    ∀ (q : R[X]) (hq : q.Monic) (hq_pos : 0 &lt; q.natDegree),
      q.natDegree = m + 1 → (companion q hq hq_pos).charpoly = q) :
  (A.submatrix (Fin.succAbove 0) Fin.succ).det = p.divX
The determinant of the (0,0)-minor of the charmatrix equals `p.divX`....">companion_charmatrix_minor00_det</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> <span class="lean-var" data-type="p.natDegree = m + 2" title="p.natDegree = m + 2">hdeg</span> <span class="lean-var" data-type="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]" title="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]">A</span> <span class="lean-var" data-type="A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯)" title="A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯)">hA_def</span> <span class="lean-var" data-type="∀ (p : R[X]) (hp : p.Monic) (hn : 0 &lt; p.natDegree), p.natDegree = m + 1 → (companion p hp hn).charpoly = p" title="∀ (p : R[X]) (hp : p.Monic) (hn : 0 &lt; p.natDegree), p.natDegree = m + 1 → (companion p hp hn).charpoly = p">IH</span>,
      <span class="lean-const" data-name="Crystallographic.companion_charmatrix_minor10_det" data-signature="Crystallographic.companion_charmatrix_minor10_det.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdeg : p.natDegree = m + 2) (A : Matrix (Fin (m + 2)) (Fin (m + 2)) R[X])
  (hA_def : A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯)) :
  (A.submatrix (Fin.succAbove 1) Fin.succ).det = C (p.coeff 0)" data-docs="The determinant of the (1,0)-minor of the charmatrix equals `C(p.coeff 0)`.
This follows from Laplace expansion along row 0, where only the last column entry is nonzero. " title="Crystallographic.companion_charmatrix_minor10_det.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdeg : p.natDegree = m + 2) (A : Matrix (Fin (m + 2)) (Fin (m + 2)) R[X])
  (hA_def : A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯)) :
  (A.submatrix (Fin.succAbove 1) Fin.succ).det = C (p.coeff 0)
The determinant of the (1,0)-minor of the charmatrix equals `C(p.coeff 0)`....">companion_charmatrix_minor10_det</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> <span class="lean-var" data-type="p.natDegree = m + 2" title="p.natDegree = m + 2">hdeg</span> <span class="lean-var" data-type="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]" title="Matrix (Fin (m + 2)) (Fin (m + 2)) R[X]">A</span> <span class="lean-var" data-type="A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯)" title="A = (companion p hp hn).charmatrix.submatrix (Fin.cast ⋯) (Fin.cast ⋯)">hA_def</span><span class="lean-bracket-1">]</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Basic.lean#L501-L542" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:companion-charpoly');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:companion-aeval-zero">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">4.0.2</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#lem:companion-aeval-zero">#</a>
    
    <a class="icon proof" href="sect0004.html#a0000000038"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0004.html#thm:companion-charpoly">Theorem 4.0.1</a></li>
          
          <li><a href="sect0004.html#thm:companion-charpoly">Theorem 4.0.1</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.companion_aeval_eq_zero" class="lean_decl">Crystallographic.companion_aeval_eq_zero</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>        \(p(C(p)) = 0\) (Cayley-Hamilton). By the Cayley-Hamilton theorem, every matrix satisfies its characteristic polynomial. Since the characteristic polynomial of \(C(p)\) is exactly \(p\) (by <span class="ttfamily">companion_charpoly</span>), we have \(p(C(p)) = 0\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000038">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p> By Cayley-Hamilton, every matrix satisfies its characteristic polynomial. Since \(\chi _{C(p)} = p\) by the companion characteristic polynomial theorem, we have \(p(C(p)) = 0\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">theorem</span> <span class="lean-const lean-def" data-name="Crystallographic.companion_aeval_eq_zero" data-signature="Crystallographic.companion_aeval_eq_zero.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) : (aeval (companion p hp hn)) p = 0" title="Crystallographic.companion_aeval_eq_zero.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) : (aeval (companion p hp hn)) p = 0">companion_aeval_eq_zero</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="R[X]" title="R[X]">p</span> : <span class="lean-var" data-type="Type u_1" title="Type u_1">R</span><span class="lean-bracket-2">[</span>X<span class="lean-bracket-2">]</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> : <span class="lean-var" data-type="R[X]" title="R[X]">p</span>.<span class="lean-const" data-name="Polynomial.Monic" data-signature="Polynomial.Monic.{u} {R : Type u} [Semiring R] (p : R[X]) : Prop" data-docs="a polynomial is `Monic` if its leading coefficient is 1 " title="Polynomial.Monic.{u} {R : Type u} [Semiring R] (p : R[X]) : Prop
a polynomial is `Monic` if its leading coefficient is 1 ">Monic</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">0</span> &lt; <span class="lean-var" data-type="R[X]" title="R[X]">p</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ" data-docs="`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ
`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. ">natDegree</span><span class="lean-bracket-1">)</span> :
    <span class="lean-const" data-name="Polynomial.aeval" data-signature="Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A" data-docs="Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is
the unique `R`-algebra homomorphism from `R[X]` to `A` sending `X` to `x`.

This is a stronger variant of the linear map `Polynomial.leval`. " title="Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A
Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is...">aeval</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.companion" data-signature="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R" data-docs="The companion matrix of a monic polynomial p of degree n.

For p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:
```
[0  0  0  ...  0  -a_0    ]
[1  0  0  ...  0  -a_1    ]
[0  1  0  ...  0  -a_2    ]
[        ...              ]
[0  0  0  ...  1  -a_{n-1}]
```

The matrix has 1s on the subdiagonal and the negatives of the polynomial
coefficients in the last column.
" title="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R
The companion matrix of a monic polynomial p of degree n....">companion</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> = <span class="lean-expr" data-type="Matrix (Fin p.natDegree) (Fin p.natDegree) R" title="Matrix (Fin p.natDegree) (Fin p.natDegree) R">0</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(aeval (companion p hp hn)) (companion p hp hn).charpoly = 0" title="(aeval (companion p hp hn)) (companion p hp hn).charpoly = 0">h</span> := <span class="lean-const" data-name="Matrix.aeval_self_charpoly" data-signature="Matrix.aeval_self_charpoly.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n]
  (M : Matrix n n R) : (aeval M) M.charpoly = 0" data-docs="The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix,
applied to the matrix itself, is zero.

This holds over any commutative ring.

See `LinearMap.aeval_self_charpoly` for the equivalent statement about endomorphisms.
" title="Matrix.aeval_self_charpoly.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n]
  (M : Matrix n n R) : (aeval M) M.charpoly = 0
The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix,...">aeval_self_charpoly</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.companion" data-signature="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R" data-docs="The companion matrix of a monic polynomial p of degree n.

For p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:
```
[0  0  0  ...  0  -a_0    ]
[1  0  0  ...  0  -a_1    ]
[0  1  0  ...  0  -a_2    ]
[        ...              ]
[0  0  0  ...  1  -a_{n-1}]
```

The matrix has 1s on the subdiagonal and the negatives of the polynomial
coefficients in the last column.
" title="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R
The companion matrix of a monic polynomial p of degree n....">companion</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span><span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="`rwa` is short-hand for `rw; assumption`. " title="`rwa` is short-hand for `rw; assumption`. ">rwa</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Crystallographic.companion_charpoly" data-signature="Crystallographic.companion_charpoly.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic) (hn : 0 &lt; p.natDegree) :
  (companion p hp hn).charpoly = p" data-docs="The characteristic polynomial of the companion matrix equals the original polynomial.

This is the fundamental property of companion matrices: they are constructed precisely
so that their characteristic polynomial matches the given monic polynomial.

The proof proceeds by strong induction on the degree n. For degree 1, direct computation
shows both sides equal X + C(a_0). For degree n+1, Laplace expansion along the first
column gives a recurrence matching the polynomial structure.
" title="Crystallographic.companion_charpoly.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic) (hn : 0 &lt; p.natDegree) :
  (companion p hp hn).charpoly = p
The characteristic polynomial of the companion matrix equals the original polynomial....">companion_charpoly</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`
* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="(aeval (companion p hp hn)) (companion p hp hn).charpoly = 0" title="(aeval (companion p hp hn)) (companion p hp hn).charpoly = 0">h</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Basic.lean#L546-L557" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:companion-aeval-zero');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:companion-pow-dvd">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">4.0.3</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#thm:companion-pow-dvd">#</a>
    
    <a class="icon proof" href="sect0004.html#a0000000039"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0004.html#lem:companion-aeval-zero">Theorem 4.0.2</a></li>
          
          <li><a href="sect0004.html#lem:companion-aeval-zero">Theorem 4.0.2</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.companion_pow_eq_one_of_dvd" class="lean_decl">Crystallographic.companion_pow_eq_one_of_dvd</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>        If \(p \mid X^m - 1\), then \(C(p)^m = I\). If \(p \mid X^m - 1\), write \(X^m - 1 = p \cdot q\) for some \(q\). Since \(p(C(p)) = 0\), evaluating at \(C(p)\) gives \((X^m - 1)(C(p)) = p(C(p)) \cdot q(C(p)) = 0\), so \(C(p)^m - I = 0\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000039">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p> If \(p \mid X^m - 1\), write \(X^m - 1 = p \cdot q\) for some polynomial \(q\). Evaluating at \(C(p)\): \((X^m - 1)(C(p)) = p(C(p)) \cdot q(C(p)) = 0 \cdot q(C(p)) = 0\), so \(C(p)^m = I\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">theorem</span> <span class="lean-const lean-def" data-name="Crystallographic.companion_pow_eq_one_of_dvd" data-signature="Crystallographic.companion_pow_eq_one_of_dvd.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdvd : p ∣ X ^ m - 1) : companion p hp hn ^ m = 1" title="Crystallographic.companion_pow_eq_one_of_dvd.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdvd : p ∣ X ^ m - 1) : companion p hp hn ^ m = 1">companion_pow_eq_one_of_dvd</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="R[X]" title="R[X]">p</span> : <span class="lean-var" data-type="Type u_1" title="Type u_1">R</span><span class="lean-bracket-2">[</span>X<span class="lean-bracket-2">]</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> : <span class="lean-var" data-type="R[X]" title="R[X]">p</span>.<span class="lean-const" data-name="Polynomial.Monic" data-signature="Polynomial.Monic.{u} {R : Type u} [Semiring R] (p : R[X]) : Prop" data-docs="a polynomial is `Monic` if its leading coefficient is 1 " title="Polynomial.Monic.{u} {R : Type u} [Semiring R] (p : R[X]) : Prop
a polynomial is `Monic` if its leading coefficient is 1 ">Monic</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">0</span> &lt; <span class="lean-var" data-type="R[X]" title="R[X]">p</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ" data-docs="`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ
`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. ">natDegree</span><span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="ℕ" title="ℕ">m</span> : ℕ<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="p ∣ X ^ m - 1" title="p ∣ X ^ m - 1">hdvd</span> : <span class="lean-var" data-type="R[X]" title="R[X]">p</span> ∣ <span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-var" data-type="ℕ" title="ℕ">m</span> - <span class="lean-expr" data-type="R[X]" title="R[X]">1</span><span class="lean-bracket-1">)</span> :
    <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.companion" data-signature="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R" data-docs="The companion matrix of a monic polynomial p of degree n.

For p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:
```
[0  0  0  ...  0  -a_0    ]
[1  0  0  ...  0  -a_1    ]
[0  1  0  ...  0  -a_2    ]
[        ...              ]
[0  0  0  ...  1  -a_{n-1}]
```

The matrix has 1s on the subdiagonal and the negatives of the polynomial
coefficients in the last column.
" title="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R
The companion matrix of a monic polynomial p of degree n....">companion</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span><span class="lean-bracket-1">)</span> ^ <span class="lean-var" data-type="ℕ" title="ℕ">m</span> = <span class="lean-expr" data-type="Matrix (Fin p.natDegree) (Fin p.natDegree) R" title="Matrix (Fin p.natDegree) (Fin p.natDegree) R">1</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-comment">-- From hdvd, get q such that X^m - <span class="lean-number">1</span> = p * q</span>
  <span class="lean-keyword" data-docs="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for
a description of supported patterns.

```lean
obtain ⟨patt⟩ : type := proof
```
is equivalent to
```lean
have h : type := proof
rcases h with ⟨patt⟩
```

If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.

If `type` is omitted, `:= proof` is required.
" title="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for">obtain</span> <span class="lean-bracket-1">⟨</span><span class="lean-var" data-type="R[X]" title="R[X]">q</span>, <span class="lean-var" data-type="X ^ m - 1 = p * q" title="X ^ m - 1 = p * q">hq</span><span class="lean-bracket-1">⟩</span> := <span class="lean-var" data-type="p ∣ X ^ m - 1" title="p ∣ X ^ m - 1">hdvd</span>
  <span class="lean-comment">-- Let A = companion p</span>
  <span class="lean-keyword" data-docs="The `let` tactic is for adding definitions to the local context of the main goal.
The definition can be unfolded, unlike definitions introduced by `have`.

* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.
* `let x := e` uses the type of `e` for `t`.
* `let : t := e` and `let := e` use `this` for the name of the hypothesis.
* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that let only one applicable constructor.
  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the
  local variables `x : α`, `y : β`, and `z : γ`.
* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `let` term.

## Properties and relations

* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics
  such as `simp`, `dsimp`, `unfold`, and `subst`.
* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.
  The tactic might fail if the local context depends on the value of the variable.
* The `let` tactic is preferred for data (non-propositions).
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
" title="The `let` tactic is for adding definitions to the local context of the main goal.">let</span> <span class="lean-var" data-type="Matrix (Fin p.natDegree) (Fin p.natDegree) R" title="Matrix (Fin p.natDegree) (Fin p.natDegree) R">A</span> := <span class="lean-const" data-name="Crystallographic.companion" data-signature="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R" data-docs="The companion matrix of a monic polynomial p of degree n.

For p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:
```
[0  0  0  ...  0  -a_0    ]
[1  0  0  ...  0  -a_1    ]
[0  1  0  ...  0  -a_2    ]
[        ...              ]
[0  0  0  ...  1  -a_{n-1}]
```

The matrix has 1s on the subdiagonal and the negatives of the polynomial
coefficients in the last column.
" title="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R
The companion matrix of a monic polynomial p of degree n....">companion</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span>
  <span class="lean-comment">-- We have aeval A p = <span class="lean-number">0</span> by companion_aeval_eq_zero</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(aeval A) p = 0" title="(aeval A) p = 0">hp_zero</span> : <span class="lean-const" data-name="Polynomial.aeval" data-signature="Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A" data-docs="Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is
the unique `R`-algebra homomorphism from `R[X]` to `A` sending `X` to `x`.

This is a stronger variant of the linear map `Polynomial.leval`. " title="Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A
Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is...">aeval</span> <span class="lean-var" data-type="Matrix (Fin p.natDegree) (Fin p.natDegree) R" title="Matrix (Fin p.natDegree) (Fin p.natDegree) R">A</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> = <span class="lean-expr" data-type="Matrix (Fin p.natDegree) (Fin p.natDegree) R" title="Matrix (Fin p.natDegree) (Fin p.natDegree) R">0</span> := <span class="lean-const" data-name="Crystallographic.companion_aeval_eq_zero" data-signature="Crystallographic.companion_aeval_eq_zero.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) : (aeval (companion p hp hn)) p = 0" title="Crystallographic.companion_aeval_eq_zero.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) : (aeval (companion p hp hn)) p = 0">companion_aeval_eq_zero</span> <span class="lean-var" data-type="R[X]" title="R[X]">p</span> <span class="lean-var" data-type="p.Monic" title="p.Monic">hp</span> <span class="lean-var" data-type="0 &lt; p.natDegree" title="0 &lt; p.natDegree">hn</span>
  <span class="lean-comment">-- Therefore aeval A </span><span class="lean-bracket-1">(</span>X^m - <span class="lean-number">1</span><span class="lean-bracket-1">)</span> = aeval A <span class="lean-bracket-1">(</span>p * q<span class="lean-bracket-1">)</span> = aeval A p * aeval A q = <span class="lean-number">0</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(aeval A) (X ^ m - 1) = 0" title="(aeval A) (X ^ m - 1) = 0">hXm1_zero</span> : <span class="lean-const" data-name="Polynomial.aeval" data-signature="Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A" data-docs="Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is
the unique `R`-algebra homomorphism from `R[X]` to `A` sending `X` to `x`.

This is a stronger variant of the linear map `Polynomial.leval`. " title="Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A
Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is...">aeval</span> <span class="lean-var" data-type="Matrix (Fin p.natDegree) (Fin p.natDegree) R" title="Matrix (Fin p.natDegree) (Fin p.natDegree) R">A</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-var" data-type="ℕ" title="ℕ">m</span> - <span class="lean-bracket-2">(</span><span class="lean-expr" data-type="R[X]" title="R[X]">1</span> : <span class="lean-var" data-type="Type u_1" title="Type u_1">R</span><span class="lean-bracket-3">[</span>X<span class="lean-bracket-3">]</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span> = <span class="lean-expr" data-type="Matrix (Fin p.natDegree) (Fin p.natDegree) R" title="Matrix (Fin p.natDegree) (Fin p.natDegree) R">0</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="X ^ m - 1 = p * q" title="X ^ m - 1 = p * q">hq</span>, <span class="lean-const" data-name="Polynomial.aeval_mul" data-signature="Polynomial.aeval_mul.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] {p q : R[X]} (x : A) :
  (aeval x) (p * q) = (aeval x) p * (aeval x) q" title="Polynomial.aeval_mul.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] {p q : R[X]} (x : A) :
  (aeval x) (p * q) = (aeval x) p * (aeval x) q">aeval_mul</span>, <span class="lean-var" data-type="(aeval A) p = 0" title="(aeval A) p = 0">hp_zero</span>, <span class="lean-const" data-name="MulZeroClass.zero_mul" data-signature="MulZeroClass.zero_mul.{u} {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀) : 0 * a = 0" data-docs="Zero is a left absorbing element for multiplication " title="MulZeroClass.zero_mul.{u} {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀) : 0 * a = 0
Zero is a left absorbing element for multiplication ">zero_mul</span><span class="lean-bracket-1">]</span>
  <span class="lean-comment">-- But aeval A </span><span class="lean-bracket-1">(</span>X^m - <span class="lean-number">1</span><span class="lean-bracket-1">)</span> = A^m - <span class="lean-number">1</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(aeval A) (X ^ m - 1) = A ^ m - 1" title="(aeval A) (X ^ m - 1) = A ^ m - 1">haeval</span> : <span class="lean-const" data-name="Polynomial.aeval" data-signature="Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A" data-docs="Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is
the unique `R`-algebra homomorphism from `R[X]` to `A` sending `X` to `x`.

This is a stronger variant of the linear map `Polynomial.leval`. " title="Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A
Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is...">aeval</span> <span class="lean-var" data-type="Matrix (Fin p.natDegree) (Fin p.natDegree) R" title="Matrix (Fin p.natDegree) (Fin p.natDegree) R">A</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-var" data-type="ℕ" title="ℕ">m</span> - <span class="lean-bracket-2">(</span><span class="lean-expr" data-type="R[X]" title="R[X]">1</span> : <span class="lean-var" data-type="Type u_1" title="Type u_1">R</span><span class="lean-bracket-3">[</span>X<span class="lean-bracket-3">]</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span> = <span class="lean-var" data-type="Matrix (Fin p.natDegree) (Fin p.natDegree) R" title="Matrix (Fin p.natDegree) (Fin p.natDegree) R">A</span> ^ <span class="lean-var" data-type="ℕ" title="ℕ">m</span> - <span class="lean-expr" data-type="Matrix (Fin p.natDegree) (Fin p.natDegree) R" title="Matrix (Fin p.natDegree) (Fin p.natDegree) R">1</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
    <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions.-
- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.
- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idᵢ`.
- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If
  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis
  `hᵢ` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="map_sub" data-signature="map_sub.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [AddGroup G] [SubtractionMonoid H]
  [AddMonoidHomClass F G H] (f : F) (a b : G) : f (a - b) = f a - f b" data-docs="Additive group homomorphisms preserve subtraction. " title="map_sub.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [AddGroup G] [SubtractionMonoid H]
  [AddMonoidHomClass F G H] (f : F) (a b : G) : f (a - b) = f a - f b
Additive group homomorphisms preserve subtraction. ">map_sub</span>, <span class="lean-const" data-name="map_pow" data-signature="map_pow.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [Monoid G] [Monoid H]
  [MonoidHomClass F G H] (f : F) (a : G) (n : ℕ) : f (a ^ n) = f a ^ n" data-docs="See note [hom simp lemma priority] " title="map_pow.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [Monoid G] [Monoid H]
  [MonoidHomClass F G H] (f : F) (a : G) (n : ℕ) : f (a ^ n) = f a ^ n
See note [hom simp lemma priority] ">map_pow</span>, <span class="lean-const" data-name="Polynomial.aeval_X" data-signature="Polynomial.aeval_X.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) :
  (aeval x) X = x" title="Polynomial.aeval_X.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) :
  (aeval x) X = x">aeval_X</span>, <span class="lean-const" data-name="map_one" data-signature="map_one.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [One M] [One N] [FunLike F M N] [OneHomClass F M N]
  (f : F) : f 1 = 1" data-docs="See note [hom simp lemma priority] " title="map_one.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [One M] [One N] [FunLike F M N] [OneHomClass F M N]
  (f : F) : f 1 = 1
See note [hom simp lemma priority] ">map_one</span><span class="lean-bracket-1">]</span>
  <span class="lean-comment">-- So A^m - <span class="lean-number">1</span> = <span class="lean-number">0</span>, i.e., A^m = <span class="lean-number">1</span></span>
  <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="(aeval A) (X ^ m - 1) = A ^ m - 1" title="(aeval A) (X ^ m - 1) = A ^ m - 1">haeval</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`
* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="(aeval A) (X ^ m - 1) = 0" title="(aeval A) (X ^ m - 1) = 0">hXm1_zero</span>
  <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="sub_eq_zero" data-signature="sub_eq_zero.{u_3} {G : Type u_3} [AddGroup G] {a b : G} : a - b = 0 ↔ a = b" title="sub_eq_zero.{u_3} {G : Type u_3} [AddGroup G] {a b : G} : a - b = 0 ↔ a = b">sub_eq_zero</span>.<span class="lean-const" data-name="Iff.mp" data-signature="Iff.mp {a b : Prop} (self : a ↔ b) : a → b" data-docs="Modus ponens for if and only if. If `a ↔ b` and `a`, then `b`. " title="Iff.mp {a b : Prop} (self : a ↔ b) : a → b
Modus ponens for if and only if. If `a ↔ b` and `a`, then `b`. ">mp</span> <span class="lean-var" data-type="A ^ m - 1 = 0" title="A ^ m - 1 = 0">hXm1_zero</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Basic.lean#L561-L586" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:companion-pow-dvd');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:companion-cycl-pow">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">4.0.4</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#lem:companion-cycl-pow">#</a>
    
    <a class="icon proof" href="sect0004.html#a0000000040"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0004.html#thm:companion-pow-dvd">Theorem 4.0.3</a></li>
          
          <li><a href="sect0004.html#thm:companion-pow-dvd">Theorem 4.0.3</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.companion_cyclotomic_pow_eq_one" class="lean_decl">Crystallographic.companion_cyclotomic_pow_eq_one</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>        \(C(\Phi _m)^m = I\). Since the cyclotomic polynomial \(\Phi _m\) divides \(X^m - 1\) (as \(X^m - 1 = \prod _{d \mid m} \Phi _d\)), we apply <span class="ttfamily">companion_pow_eq_one_of_dvd</span>.  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000040">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p> Since \(\Phi _m \mid X^m - 1\) (as \(X^m - 1 = \prod _{d \mid m} \Phi _d\)), we apply the general companion power theorem to conclude \(C(\Phi _m)^m = I\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Crystallographic.companion_cyclotomic_pow_eq_one" data-signature="Crystallographic.companion_cyclotomic_pow_eq_one (m : ℕ) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :
  companion (cyclotomic m ℤ) ⋯ hn ^ m = 1" title="Crystallographic.companion_cyclotomic_pow_eq_one (m : ℕ) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :
  companion (cyclotomic m ℤ) ⋯ hn ^ m = 1">companion_cyclotomic_pow_eq_one</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="ℕ" title="ℕ">m</span> : ℕ<span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; (cyclotomic m ℤ).natDegree" title="0 &lt; (cyclotomic m ℤ).natDegree">hn</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">0</span> &lt; <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ<span class="lean-bracket-2">)</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ" data-docs="`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ
`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. ">natDegree</span><span class="lean-bracket-1">)</span> :
    <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.companion" data-signature="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R" data-docs="The companion matrix of a monic polynomial p of degree n.

For p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:
```
[0  0  0  ...  0  -a_0    ]
[1  0  0  ...  0  -a_1    ]
[0  1  0  ...  0  -a_2    ]
[        ...              ]
[0  0  0  ...  1  -a_{n-1}]
```

The matrix has 1s on the subdiagonal and the negatives of the polynomial
coefficients in the last column.
" title="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R
The companion matrix of a monic polynomial p of degree n....">companion</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ<span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Polynomial.cyclotomic.monic" data-signature="Polynomial.cyclotomic.monic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : (cyclotomic n R).Monic" data-docs="`cyclotomic n` is monic. " title="Polynomial.cyclotomic.monic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : (cyclotomic n R).Monic
`cyclotomic n` is monic. ">cyclotomic.monic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ<span class="lean-bracket-2">)</span> <span class="lean-var" data-type="0 &lt; (cyclotomic m ℤ).natDegree" title="0 &lt; (cyclotomic m ℤ).natDegree">hn</span><span class="lean-bracket-1">)</span> ^ <span class="lean-var" data-type="ℕ" title="ℕ">m</span> = <span class="lean-expr" data-type="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℤ" title="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℤ">1</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.
" title="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.">apply</span> <span class="lean-const" data-name="Crystallographic.companion_pow_eq_one_of_dvd" data-signature="Crystallographic.companion_pow_eq_one_of_dvd.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdvd : p ∣ X ^ m - 1) : companion p hp hn ^ m = 1" title="Crystallographic.companion_pow_eq_one_of_dvd.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (hp : p.Monic)
  (hn : 0 &lt; p.natDegree) (m : ℕ) (hdvd : p ∣ X ^ m - 1) : companion p hp hn ^ m = 1">companion_pow_eq_one_of_dvd</span>
  <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Polynomial.cyclotomic.dvd_X_pow_sub_one" data-signature="Polynomial.cyclotomic.dvd_X_pow_sub_one.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : cyclotomic n R ∣ X ^ n - 1" title="Polynomial.cyclotomic.dvd_X_pow_sub_one.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : cyclotomic n R ∣ X ^ n - 1">cyclotomic.dvd_X_pow_sub_one</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ</code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Cyclotomic.lean#L39-L50" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:companion-cycl-pow');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:companion-cycl-order">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">4.0.5</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#thm:companion-cycl-order">#</a>
    
    <a class="icon proof" href="sect0004.html#a0000000041"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0004.html#lem:companion-cycl-pow">Theorem 4.0.4</a></li>
          
          <li><a href="sect0004.html#lem:companion-aeval-zero">Theorem 4.0.2</a></li>
          
          <li><a href="sect0004.html#thm:companion-charpoly">Theorem 4.0.1</a></li>
          
          <li><a href="sect0004.html#lem:companion-cycl-pow">Theorem 4.0.4</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.companion_cyclotomic_orderOf" class="lean_decl">Crystallographic.companion_cyclotomic_orderOf</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>        \(\mathrm{ord}(C(\Phi _m)) = m\) for \(m \geq 2\). The order is exactly \(m\) because: (1) \(\Phi _m \mid X^m - 1\) implies \(C(\Phi _m)^m = I\), and (2) if \(C(\Phi _m)^d = I\) for \(d {\lt} m\), then \(\Phi _m\) would divide \(X^d - 1\), contradicting that primitive \(m\)-th roots of unity are not \(d\)-th roots of unity for \(d {\lt} m\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000041">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p> The order is at most \(m\) since \(\Phi _m \mid X^m - 1\) implies \(C(\Phi _m)^m = I\). For the lower bound: if \(C(\Phi _m)^d = I\) for \(d {\lt} m\), then \(\Phi _m \mid X^d - 1\), but this contradicts that primitive \(m\)-th roots of unity are not \(d\)-th roots. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">theorem</span> <span class="lean-const lean-def" data-name="Crystallographic.companion_cyclotomic_orderOf" data-signature="Crystallographic.companion_cyclotomic_orderOf (m : ℕ) (hm : 2 ≤ m) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :
  orderOf (companion (cyclotomic m ℤ) ⋯ hn) = m" title="Crystallographic.companion_cyclotomic_orderOf (m : ℕ) (hm : 2 ≤ m) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :
  orderOf (companion (cyclotomic m ℤ) ⋯ hn) = m">companion_cyclotomic_orderOf</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="ℕ" title="ℕ">m</span> : ℕ<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="2 ≤ m" title="2 ≤ m">hm</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">2</span> <span class="lean-operator">≤</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span><span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; (cyclotomic m ℤ).natDegree" title="0 &lt; (cyclotomic m ℤ).natDegree">hn</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">0</span> &lt; <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ<span class="lean-bracket-2">)</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ" data-docs="`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ
`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. ">natDegree</span><span class="lean-bracket-1">)</span> :
    <span class="lean-const" data-name="orderOf" data-signature="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : ℕ" data-docs="`orderOf x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists.
Otherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. " title="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : ℕ
`orderOf x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists....">orderOf</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.companion" data-signature="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R" data-docs="The companion matrix of a monic polynomial p of degree n.

For p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:
```
[0  0  0  ...  0  -a_0    ]
[1  0  0  ...  0  -a_1    ]
[0  1  0  ...  0  -a_2    ]
[        ...              ]
[0  0  0  ...  1  -a_{n-1}]
```

The matrix has 1s on the subdiagonal and the negatives of the polynomial
coefficients in the last column.
" title="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R
The companion matrix of a monic polynomial p of degree n....">companion</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ<span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Polynomial.cyclotomic.monic" data-signature="Polynomial.cyclotomic.monic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : (cyclotomic n R).Monic" data-docs="`cyclotomic n` is monic. " title="Polynomial.cyclotomic.monic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : (cyclotomic n R).Monic
`cyclotomic n` is monic. ">cyclotomic.monic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ<span class="lean-bracket-2">)</span> <span class="lean-var" data-type="0 &lt; (cyclotomic m ℤ).natDegree" title="0 &lt; (cyclotomic m ℤ).natDegree">hn</span><span class="lean-bracket-1">)</span> = <span class="lean-var" data-type="ℕ" title="ℕ">m</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="The `let` tactic is for adding definitions to the local context of the main goal.
The definition can be unfolded, unlike definitions introduced by `have`.

* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.
* `let x := e` uses the type of `e` for `t`.
* `let : t := e` and `let := e` use `this` for the name of the hypothesis.
* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that let only one applicable constructor.
  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the
  local variables `x : α`, `y : β`, and `z : γ`.
* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `let` term.

## Properties and relations

* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics
  such as `simp`, `dsimp`, `unfold`, and `subst`.
* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.
  The tactic might fail if the local context depends on the value of the variable.
* The `let` tactic is preferred for data (non-propositions).
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
" title="The `let` tactic is for adding definitions to the local context of the main goal.">let</span> <span class="lean-var" data-type="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℤ" title="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℤ">A</span> := <span class="lean-const" data-name="Crystallographic.companion" data-signature="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R" data-docs="The companion matrix of a monic polynomial p of degree n.

For p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:
```
[0  0  0  ...  0  -a_0    ]
[1  0  0  ...  0  -a_1    ]
[0  1  0  ...  0  -a_2    ]
[        ...              ]
[0  0  0  ...  1  -a_{n-1}]
```

The matrix has 1s on the subdiagonal and the negatives of the polynomial
coefficients in the last column.
" title="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R
The companion matrix of a monic polynomial p of degree n....">companion</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Polynomial.cyclotomic.monic" data-signature="Polynomial.cyclotomic.monic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : (cyclotomic n R).Monic" data-docs="`cyclotomic n` is monic. " title="Polynomial.cyclotomic.monic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : (cyclotomic n R).Monic
`cyclotomic n` is monic. ">cyclotomic.monic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ<span class="lean-bracket-1">)</span> <span class="lean-var" data-type="0 &lt; (cyclotomic m ℤ).natDegree" title="0 &lt; (cyclotomic m ℤ).natDegree">hn</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm_pos</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">0</span> &lt; <span class="lean-var" data-type="ℕ" title="ℕ">m</span> := <span class="lean-const" data-name="Nat.lt_of_lt_of_le" data-signature="Nat.lt_of_lt_of_le {n m k : ℕ} : n &lt; m → m ≤ k → n &lt; k" title="Nat.lt_of_lt_of_le {n m k : ℕ} : n &lt; m → m ≤ k → n &lt; k">Nat.lt_of_lt_of_le</span> <span class="lean-bracket-1">(</span><span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="Normalize numerical expressions. Supports the operations `+` `-` `*` `/` `⁻¹` `^` and `%`
over numerical types such as `ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,
and can prove goals of the form `A = B`, `A ≠ B`, `A &lt; B` and `A ≤ B`, where `A` and `B` are
numerical expressions. It also has a relatively simple primality prover.
" title="Normalize numerical expressions. Supports the operations `+` `-` `*` `/` `⁻¹` `^` and `%`">norm_num</span> : <span class="lean-number">0</span> &lt; <span class="lean-number">2</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="2 ≤ m" title="2 ≤ m">hm</span>
  <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="orderOf_eq_iff" data-signature="orderOf_eq_iff.{u_1} {G : Type u_1} [Monoid G] {x : G} {n : ℕ} (h : 0 &lt; n) :
  orderOf x = n ↔ x ^ n = 1 ∧ ∀ m &lt; n, 0 &lt; m → x ^ m ≠ 1" title="orderOf_eq_iff.{u_1} {G : Type u_1} [Monoid G] {x : G} {n : ℕ} (h : 0 &lt; n) :
  orderOf x = n ↔ x ^ n = 1 ∧ ∀ m &lt; n, 0 &lt; m → x ^ m ≠ 1">orderOf_eq_iff</span> <span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm_pos</span><span class="lean-bracket-1">]</span>
  <span class="lean-keyword" data-docs="If the main goal&#x27;s target type is an inductive type, `constructor` solves it with
the first matching constructor, or else fails.
" title="If the main goal&#x27;s target type is an inductive type, `constructor` solves it with">constructor</span>
  <span class="lean-operator">·</span> <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Crystallographic.companion_cyclotomic_pow_eq_one" data-signature="Crystallographic.companion_cyclotomic_pow_eq_one (m : ℕ) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :
  companion (cyclotomic m ℤ) ⋯ hn ^ m = 1" title="Crystallographic.companion_cyclotomic_pow_eq_one (m : ℕ) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :
  companion (cyclotomic m ℤ) ⋯ hn ^ m = 1">companion_cyclotomic_pow_eq_one</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> <span class="lean-var" data-type="0 &lt; (cyclotomic m ℤ).natDegree" title="0 &lt; (cyclotomic m ℤ).natDegree">hn</span>
  <span class="lean-operator">·</span> <span class="lean-keyword" data-docs="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal&#x27;s target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`. It is equivalent to `intro _`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, given a type ascription, or matched against a pattern:
  ```lean
  -- ... ⊢ α × β → ...
  intro (a, b)
  -- ..., a : α, b : β ⊢ ...
  ```
* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side
  is a variable.
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
" title="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.">intro</span> <span class="lean-var" data-type="ℕ" title="ℕ">k</span> <span class="lean-var" data-type="k &lt; m" title="k &lt; m">hk</span> <span class="lean-var" data-type="0 &lt; k" title="0 &lt; k">hk_pos</span> <span class="lean-var" data-type="companion (cyclotomic m ℤ) ⋯ hn ^ k = 1" title="companion (cyclotomic m ℤ) ⋯ hn ^ k = 1">hAk</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(aeval A) (X ^ k - 1) = 0" title="(aeval A) (X ^ k - 1) = 0">haeval_zero</span> : <span class="lean-const" data-name="Polynomial.aeval" data-signature="Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A" data-docs="Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is
the unique `R`-algebra homomorphism from `R[X]` to `A` sending `X` to `x`.

This is a stronger variant of the linear map `Polynomial.leval`. " title="Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A
Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is...">aeval</span> <span class="lean-var" data-type="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℤ" title="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℤ">A</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-var" data-type="ℕ" title="ℕ">k</span> - <span class="lean-bracket-2">(</span><span class="lean-expr" data-type="ℤ[X]" title="ℤ[X]">1</span> : ℤ<span class="lean-bracket-3">[</span>X<span class="lean-bracket-3">]</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span> = <span class="lean-expr" data-type="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℤ" title="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℤ">0</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
      <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions.-
- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.
- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idᵢ`.
- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If
  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis
  `hᵢ` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="map_sub" data-signature="map_sub.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [AddGroup G] [SubtractionMonoid H]
  [AddMonoidHomClass F G H] (f : F) (a b : G) : f (a - b) = f a - f b" data-docs="Additive group homomorphisms preserve subtraction. " title="map_sub.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [AddGroup G] [SubtractionMonoid H]
  [AddMonoidHomClass F G H] (f : F) (a b : G) : f (a - b) = f a - f b
Additive group homomorphisms preserve subtraction. ">map_sub</span>, <span class="lean-const" data-name="map_pow" data-signature="map_pow.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [Monoid G] [Monoid H]
  [MonoidHomClass F G H] (f : F) (a : G) (n : ℕ) : f (a ^ n) = f a ^ n" data-docs="See note [hom simp lemma priority] " title="map_pow.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [Monoid G] [Monoid H]
  [MonoidHomClass F G H] (f : F) (a : G) (n : ℕ) : f (a ^ n) = f a ^ n
See note [hom simp lemma priority] ">map_pow</span>, <span class="lean-const" data-name="Polynomial.aeval_X" data-signature="Polynomial.aeval_X.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) :
  (aeval x) X = x" title="Polynomial.aeval_X.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) :
  (aeval x) X = x">aeval_X</span>, <span class="lean-const" data-name="map_one" data-signature="map_one.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [One M] [One N] [FunLike F M N] [OneHomClass F M N]
  (f : F) : f 1 = 1" data-docs="See note [hom simp lemma priority] " title="map_one.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [One M] [One N] [FunLike F M N] [OneHomClass F M N]
  (f : F) : f 1 = 1
See note [hom simp lemma priority] ">map_one</span><span class="lean-bracket-1">]</span>
      <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="companion (cyclotomic m ℤ) ⋯ hn ^ k = 1" title="companion (cyclotomic m ℤ) ⋯ hn ^ k = 1">hAk</span>, <span class="lean-const" data-name="sub_self" data-signature="sub_self.{u_1} {G : Type u_1} [AddGroup G] (a : G) : a - a = 0" title="sub_self.{u_1} {G : Type u_1} [AddGroup G] (a : G) : a - a = 0">sub_self</span><span class="lean-bracket-1">]</span>
    <span class="lean-comment">-- Work over ℚ where cyclotomic is irreducible</span>
    <span class="lean-keyword" data-docs="The `let` tactic is for adding definitions to the local context of the main goal.
The definition can be unfolded, unlike definitions introduced by `have`.

* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.
* `let x := e` uses the type of `e` for `t`.
* `let : t := e` and `let := e` use `this` for the name of the hypothesis.
* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that let only one applicable constructor.
  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the
  local variables `x : α`, `y : β`, and `z : γ`.
* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `let` term.

## Properties and relations

* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics
  such as `simp`, `dsimp`, `unfold`, and `subst`.
* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.
  The tactic might fail if the local context depends on the value of the variable.
* The `let` tactic is preferred for data (non-propositions).
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
" title="The `let` tactic is for adding definitions to the local context of the main goal.">let</span> <span class="lean-var" data-type="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℚ" title="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℚ">AQ</span> := <span class="lean-var" data-type="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℤ" title="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℤ">A</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {α : Type v} {β : Type w} (M : Matrix m n α) (f : α → β) :
  Matrix m n β" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {α : Type v} {β : Type w} (M : Matrix m n α) (f : α → β) :
  Matrix m n β
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R →+* A" data-docs="Embedding `R →+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R →+* A
Embedding `R →+* A` given by `Algebra` structure. ">algebraMap</span> ℤ ℚ<span class="lean-bracket-1">)</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(aeval AQ) (map (algebraMap ℤ ℚ) (X ^ k - 1)) = 0" title="(aeval AQ) (map (algebraMap ℤ ℚ) (X ^ k - 1)) = 0">haeval_Q_zero</span> : <span class="lean-const" data-name="Polynomial.aeval" data-signature="Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A" data-docs="Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is
the unique `R`-algebra homomorphism from `R[X]` to `A` sending `X` to `x`.

This is a stronger variant of the linear map `Polynomial.leval`. " title="Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] →ₐ[R] A
Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is...">aeval</span> <span class="lean-var" data-type="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℚ" title="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℚ">AQ</span> <span class="lean-bracket-1">(</span><span class="lean-bracket-2">(</span><span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-var" data-type="ℕ" title="ℕ">k</span> - <span class="lean-expr" data-type="ℤ[X]" title="ℤ[X]">1</span> : ℤ<span class="lean-bracket-3">[</span>X<span class="lean-bracket-3">]</span><span class="lean-bracket-2">)</span>.<span class="lean-const" data-name="Polynomial.map" data-signature="Polynomial.map.{u, v} {R : Type u} {S : Type v} [Semiring R] [Semiring S] (f : R →+* S) : R[X] → S[X]" data-docs="`map f p` maps a polynomial `p` across a ring hom `f` " title="Polynomial.map.{u, v} {R : Type u} {S : Type v} [Semiring R] [Semiring S] (f : R →+* S) : R[X] → S[X]
`map f p` maps a polynomial `p` across a ring hom `f` ">map</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R →+* A" data-docs="Embedding `R →+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R →+* A
Embedding `R →+* A` given by `Algebra` structure. ">algebraMap</span> ℤ ℚ<span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span> = <span class="lean-expr" data-type="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℚ" title="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℚ">0</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> : <span class="lean-var" data-type="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℚ" title="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℚ">AQ</span> = <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Algebra.ofId" data-signature="Algebra.ofId.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R →ₐ[R] A" data-docs="`AlgebraMap` as an `AlgHom`. " title="Algebra.ofId.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R →ₐ[R] A
`AlgebraMap` as an `AlgHom`. ">Algebra.ofId</span> ℤ ℚ<span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="AlgHom.mapMatrix" data-signature="AlgHom.mapMatrix.{u_2, u_7, u_11, u_12} {m : Type u_2} {R : Type u_7} {α : Type u_11} {β : Type u_12} [Fintype m]
  [DecidableEq m] [CommSemiring R] [Semiring α] [Semiring β] [Algebra R α] [Algebra R β] (f : α →ₐ[R] β) :
  Matrix m m α →ₐ[R] Matrix m m β" data-docs="The `AlgHom` between spaces of square matrices induced by an `AlgHom` between their
coefficients. This is `Matrix.map` as an `AlgHom`. " title="AlgHom.mapMatrix.{u_2, u_7, u_11, u_12} {m : Type u_2} {R : Type u_7} {α : Type u_11} {β : Type u_12} [Fintype m]
  [DecidableEq m] [CommSemiring R] [Semiring α] [Semiring β] [Algebra R α] [Algebra R β] (f : α →ₐ[R] β) :
  Matrix m m α →ₐ[R] Matrix m m β
The `AlgHom` between spaces of square matrices induced by an `AlgHom` between their...">mapMatrix</span> <span class="lean-var" data-type="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℤ" title="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℤ">A</span> := <span class="lean-const" data-name="rfl" data-signature="rfl.{u} {α : Sort u} {a : α} : a = a" data-docs="`rfl : a = a` is the unique constructor of the equality type. This is the
same as `Eq.refl` except that it takes `a` implicitly instead of explicitly.

This is a more powerful theorem than it may appear at first, because although
the statement of the theorem is `a = a`, Lean will allow anything that is
definitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in
Lean by `rfl`, because both sides are the same up to definitional equality.
" title="rfl.{u} {α : Sort u} {a : α} : a = a
`rfl : a = a` is the unique constructor of the equality type. This is the...">rfl</span>
      <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="AQ = (Algebra.ofId ℤ ℚ).mapMatrix A" title="AQ = (Algebra.ofId ℤ ℚ).mapMatrix A">this</span>, <span class="lean-const" data-name="Polynomial.aeval_map_algebraMap" data-signature="Polynomial.aeval_map_algebraMap.{u_1, u_2, u_3} {R : Type u_1} (A : Type u_2) {B : Type u_3} [CommSemiring R]
  [CommSemiring A] [Semiring B] [Algebra R A] [Algebra A B] [Algebra R B] [IsScalarTower R A B] (x : B) (p : R[X]) :
  (aeval x) (map (algebraMap R A) p) = (aeval x) p" title="Polynomial.aeval_map_algebraMap.{u_1, u_2, u_3} {R : Type u_1} (A : Type u_2) {B : Type u_3} [CommSemiring R]
  [CommSemiring A] [Semiring B] [Algebra R A] [Algebra A B] [Algebra R B] [IsScalarTower R A B] (x : B) (p : R[X]) :
  (aeval x) (map (algebraMap R A) p) = (aeval x) p">aeval_map_algebraMap</span>, <span class="lean-const" data-name="Polynomial.aeval_algHom_apply" data-signature="Polynomial.aeval_algHom_apply.{u, z, u_2, u_3} {R : Type u} {A : Type z} {B : Type u_2} [CommSemiring R] [Semiring A]
  [Semiring B] [Algebra R A] [Algebra R B] {F : Type u_3} [FunLike F A B] [AlgHomClass F R A B] (f : F) (x : A)
  (p : R[X]) : (aeval (f x)) p = f ((aeval x) p)" title="Polynomial.aeval_algHom_apply.{u, z, u_2, u_3} {R : Type u} {A : Type z} {B : Type u_2} [CommSemiring R] [Semiring A]
  [Semiring B] [Algebra R A] [Algebra R B] {F : Type u_3} [FunLike F A B] [AlgHomClass F R A B] (f : F) (x : A)
  (p : R[X]) : (aeval (f x)) p = f ((aeval x) p)">aeval_algHom_apply</span>, <span class="lean-var" data-type="(aeval A) (X ^ k - 1) = 0" title="(aeval A) (X ^ k - 1) = 0">haeval_zero</span>, <span class="lean-const" data-name="map_zero" data-signature="map_zero.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [Zero M] [Zero N] [FunLike F M N]
  [ZeroHomClass F M N] (f : F) : f 0 = 0" title="map_zero.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [Zero M] [Zero N] [FunLike F M N]
  [ZeroHomClass F M N] (f : F) : f 0 = 0">map_zero</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions.-
- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.
- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idᵢ`.
- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If
  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis
  `hᵢ` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Polynomial.map_sub" data-signature="Polynomial.map_sub.{u, u_1} {R : Type u} [Ring R] {p q : R[X]} {S : Type u_1} [Ring S] (f : R →+* S) :
  map f (p - q) = map f p - map f q" title="Polynomial.map_sub.{u, u_1} {R : Type u} [Ring R] {p q : R[X]} {S : Type u_1} [Ring S] (f : R →+* S) :
  map f (p - q) = map f p - map f q">Polynomial.map_sub</span>, <span class="lean-const" data-name="Polynomial.map_pow" data-signature="Polynomial.map_pow.{u, v} {R : Type u} {S : Type v} [Semiring R] {p : R[X]} [Semiring S] (f : R →+* S) (n : ℕ) :
  map f (p ^ n) = map f p ^ n" title="Polynomial.map_pow.{u, v} {R : Type u} {S : Type v} [Semiring R] {p : R[X]} [Semiring S] (f : R →+* S) (n : ℕ) :
  map f (p ^ n) = map f p ^ n">Polynomial.map_pow</span>, <span class="lean-const" data-name="Polynomial.map_X" data-signature="Polynomial.map_X.{u, v} {R : Type u} {S : Type v} [Semiring R] [Semiring S] (f : R →+* S) : map f X = X" title="Polynomial.map_X.{u, v} {R : Type u} {S : Type v} [Semiring R] [Semiring S] (f : R →+* S) : map f X = X">Polynomial.map_X</span>, <span class="lean-const" data-name="Polynomial.map_one" data-signature="Polynomial.map_one.{u, v} {R : Type u} {S : Type v} [Semiring R] [Semiring S] (f : R →+* S) : map f 1 = 1" title="Polynomial.map_one.{u, v} {R : Type u} {S : Type v} [Semiring R] [Semiring S] (f : R →+* S) : map f 1 = 1">Polynomial.map_one</span><span class="lean-bracket-1">]</span>
      <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`
* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="(aeval AQ) (map (algebraMap ℤ ℚ) (X ^ k - 1)) = 0" title="(aeval AQ) (map (algebraMap ℤ ℚ) (X ^ k - 1)) = 0">haeval_Q_zero</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="minpoly ℚ AQ ∣ X ^ k - 1" title="minpoly ℚ AQ ∣ X ^ k - 1">hdvd1</span> : <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `𝕜`-vector space for some field `𝕜` and `f : V →ₗ[𝕜] V` then
the minimal polynomial of `f` is `minpoly 𝕜 f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> ℚ <span class="lean-var" data-type="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℚ" title="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℚ">AQ</span> ∣ <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-var" data-type="ℕ" title="ℕ">k</span> - <span class="lean-expr" data-type="ℚ[X]" title="ℚ[X]">1</span> : ℚ<span class="lean-bracket-2">[</span>X<span class="lean-bracket-2">]</span><span class="lean-bracket-1">)</span> := <span class="lean-const" data-name="minpoly.dvd" data-signature="minpoly.dvd.{u_1, u_2} (A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {p : A[X]}
  (hp : (aeval x) p = 0) : minpoly A x ∣ p" data-docs="If an element `x` is a root of a polynomial `p`, then the minimal polynomial of `x` divides `p`.
See also `minpoly.isIntegrallyClosed_dvd` which relaxes the assumptions on `A` in exchange for
stronger assumptions on `B`. " title="minpoly.dvd.{u_1, u_2} (A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {p : A[X]}
  (hp : (aeval x) p = 0) : minpoly A x ∣ p
If an element `x` is a root of a polynomial `p`, then the minimal polynomial of `x` divides `p`....">minpoly.dvd</span> ℚ <span class="lean-var" data-type="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℚ" title="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℚ">AQ</span> <span class="lean-var" data-type="(aeval AQ) (X ^ k - 1) = 0" title="(aeval AQ) (X ^ k - 1) = 0">haeval_Q_zero</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="minpoly ℚ AQ = cyclotomic m ℚ" title="minpoly ℚ AQ = cyclotomic m ℚ">hminpoly_eq</span> : <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `𝕜`-vector space for some field `𝕜` and `f : V →ₗ[𝕜] V` then
the minimal polynomial of `f` is `minpoly 𝕜 f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> ℚ <span class="lean-var" data-type="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℚ" title="Matrix (Fin (cyclotomic m ℤ).natDegree) (Fin (cyclotomic m ℤ).natDegree) ℚ">AQ</span> = <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℚ := <span class="lean-const" data-name="Crystallographic.companion_cyclotomic_minpoly" data-signature="Crystallographic.companion_cyclotomic_minpoly (m : ℕ) (hm_pos : 0 &lt; m) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :
  have A := companion (cyclotomic m ℤ) ⋯ hn;
  have AQ := A.map ⇑(algebraMap ℤ ℚ);
  minpoly ℚ AQ = cyclotomic m ℚ" data-docs="For the companion matrix of cyclotomic m ℤ, the minimal polynomial over ℚ equals cyclotomic m ℚ.
This uses that minpoly | charpoly = cyclotomic, and cyclotomic is monic irreducible over ℚ. " title="Crystallographic.companion_cyclotomic_minpoly (m : ℕ) (hm_pos : 0 &lt; m) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :
  have A := companion (cyclotomic m ℤ) ⋯ hn;
  have AQ := A.map ⇑(algebraMap ℤ ℚ);
  minpoly ℚ AQ = cyclotomic m ℚ
For the companion matrix of cyclotomic m ℤ, the minimal polynomial over ℚ equals cyclotomic m ℚ....">companion_cyclotomic_minpoly</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> <span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm_pos</span> <span class="lean-var" data-type="0 &lt; (cyclotomic m ℤ).natDegree" title="0 &lt; (cyclotomic m ℤ).natDegree">hn</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="minpoly ℚ AQ = cyclotomic m ℚ" title="minpoly ℚ AQ = cyclotomic m ℚ">hminpoly_eq</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`
* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="minpoly ℚ AQ ∣ X ^ k - 1" title="minpoly ℚ AQ ∣ X ^ k - 1">hdvd1</span>
    <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Nat.not_dvd_of_pos_of_lt" data-signature="Nat.not_dvd_of_pos_of_lt {n m : ℕ} (h1 : 0 &lt; n) (h2 : n &lt; m) : ¬m ∣ n" title="Nat.not_dvd_of_pos_of_lt {n m : ℕ} (h1 : 0 &lt; n) (h2 : n &lt; m) : ¬m ∣ n">Nat.not_dvd_of_pos_of_lt</span> <span class="lean-var" data-type="0 &lt; k" title="0 &lt; k">hk_pos</span> <span class="lean-var" data-type="k &lt; m" title="k &lt; m">hk</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.dvd_of_cyclotomic_dvd_X_pow_sub_one" data-signature="Crystallographic.dvd_of_cyclotomic_dvd_X_pow_sub_one (m k : ℕ) (hm_pos : 0 &lt; m) (hk_pos : 0 &lt; k)
  (hdvd : cyclotomic m ℚ ∣ X ^ k - 1) : m ∣ k" data-docs="If cyclotomic m ℚ divides X^k - 1 for 0 &lt; k, then m ∣ k.
This uses the factorization X^k - 1 = ∏_{d|k} Φ_d and that cyclotomic polynomials
are coprime for different indices. " title="Crystallographic.dvd_of_cyclotomic_dvd_X_pow_sub_one (m k : ℕ) (hm_pos : 0 &lt; m) (hk_pos : 0 &lt; k)
  (hdvd : cyclotomic m ℚ ∣ X ^ k - 1) : m ∣ k
If cyclotomic m ℚ divides X^k - 1 for 0 &lt; k, then m ∣ k....">dvd_of_cyclotomic_dvd_X_pow_sub_one</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> <span class="lean-var" data-type="ℕ" title="ℕ">k</span> <span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm_pos</span> <span class="lean-var" data-type="0 &lt; k" title="0 &lt; k">hk_pos</span> <span class="lean-var" data-type="cyclotomic m ℚ ∣ X ^ k - 1" title="cyclotomic m ℚ ∣ X ^ k - 1">hdvd1</span><span class="lean-bracket-1">)</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Cyclotomic.lean#L110-L141" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:companion-cycl-order');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:companion-cycl-mem">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">4.0.6</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#thm:companion-cycl-mem">#</a>
    
    <a class="icon proof" href="sect0004.html#a0000000042"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0004.html#thm:companion-cycl-order">Theorem 4.0.5</a></li>
          
          <li><a href="sect0004.html#companion-def">Definition 4.0.1</a></li>
          
          <li><a href="sect0004.html#thm:companion-cycl-order">Theorem 4.0.5</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.companion_cyclotomic_mem_integerMatrixOrders" class="lean_decl">Crystallographic.companion_cyclotomic_mem_integerMatrixOrders</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>        \(m \in \mathrm{Ord}_{\varphi (m)}\) via \(C(\Phi _m)\). Since \(\deg (\Phi _m) = \varphi (m)\), the companion matrix \(C(\Phi _m)\) is \(\varphi (m) \times \varphi (m)\) with integer entries, and has order exactly \(m\) by <span class="ttfamily">companion_cyclotomic_orderOf</span>.  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000042">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p> The companion matrix \(C(\Phi _m)\) witnesses the membership: it is an integer matrix of dimension \(\deg (\Phi _m) = \varphi (m)\) with multiplicative order exactly \(m\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">theorem</span> <span class="lean-const lean-def" data-name="Crystallographic.companion_cyclotomic_mem_integerMatrixOrders" data-signature="Crystallographic.companion_cyclotomic_mem_integerMatrixOrders (m : ℕ) (hm : 2 ≤ m)
  (hn : 0 &lt; (cyclotomic m ℤ).natDegree) : m ∈ integerMatrixOrders (cyclotomic m ℤ).natDegree" title="Crystallographic.companion_cyclotomic_mem_integerMatrixOrders (m : ℕ) (hm : 2 ≤ m)
  (hn : 0 &lt; (cyclotomic m ℤ).natDegree) : m ∈ integerMatrixOrders (cyclotomic m ℤ).natDegree">companion_cyclotomic_mem_integerMatrixOrders</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="ℕ" title="ℕ">m</span> : ℕ<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="2 ≤ m" title="2 ≤ m">hm</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">2</span> <span class="lean-operator">≤</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span><span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; (cyclotomic m ℤ).natDegree" title="0 &lt; (cyclotomic m ℤ).natDegree">hn</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">0</span> &lt; <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ<span class="lean-bracket-2">)</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ" data-docs="`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ
`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. ">natDegree</span><span class="lean-bracket-1">)</span> :
    <span class="lean-var" data-type="ℕ" title="ℕ">m</span> <span class="lean-operator">∈</span> <span class="lean-const" data-name="Crystallographic.integerMatrixOrders" data-signature="Crystallographic.integerMatrixOrders (N : ℕ) : Set ℕ" data-docs="The set of possible orders for N×N integer matrices with finite order.
An integer `m` is in this set if there exists an N×N integer matrix `A` such that
`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). " title="Crystallographic.integerMatrixOrders (N : ℕ) : Set ℕ
The set of possible orders for N×N integer matrices with finite order....">Crystallographic.integerMatrixOrders</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ<span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ" data-docs="`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ
`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. ">natDegree</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="`use e₁, e₂, ⋯` is similar to `exists`, but unlike `exists` it is equivalent to applying the tactic
`refine ⟨e₁, e₂, ⋯, ?_, ⋯, ?_⟩` with any number of placeholders (rather than just one) and
then trying to close goals associated to the placeholders with a configurable discharger (rather
than just `try trivial`).

Examples:

```lean
example : ∃ x : Nat, x = x := by use 42

example : ∃ x : Nat, ∃ y : Nat, x = y := by use 42, 42

example : ∃ x : String × String, x.1 = x.2 := by use (&quot;forty-two&quot;, &quot;forty-two&quot;)
```

`use! e₁, e₂, ⋯` is similar but it applies constructors everywhere rather than just for
goals that correspond to the last argument of a constructor. This gives the effect that
nested constructors are being flattened out, with the supplied values being used along the
leaves and nodes of the tree of constructors.
With `use!` one can feed in each `42` one at a time:

```lean
example : ∃ p : Nat × Nat, p.1 = p.2 := by use! 42, 42

example : ∃ p : Nat × Nat, p.1 = p.2 := by use! (42, 42)
```

The second line makes use of the fact that `use!` tries refining with the argument before
applying a constructor. Also note that `use`/`use!` by default uses a tactic
called `use_discharger` to discharge goals, so `use! 42` will close the goal in this example since
`use_discharger` applies `rfl`, which as a consequence solves for the other `Nat` metavariable.

These tactics take an optional discharger to handle remaining explicit `Prop` constructor arguments.
By default it is `use (discharger := try with_reducible use_discharger) e₁, e₂, ⋯`.
To turn off the discharger and keep all goals, use `(discharger := skip)`.
To allow &quot;heavy refls&quot;, use `(discharger := try use_discharger)`.
" title="`use e₁, e₂, ⋯` is similar to `exists`, but unlike `exists` it is equivalent to applying the tactic">use</span> <span class="lean-const" data-name="Crystallographic.companion" data-signature="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R" data-docs="The companion matrix of a monic polynomial p of degree n.

For p = X^n + a_{n-1}X^{n-1} + ... + a_1 X + a_0, the companion matrix is:
```
[0  0  0  ...  0  -a_0    ]
[1  0  0  ...  0  -a_1    ]
[0  1  0  ...  0  -a_2    ]
[        ...              ]
[0  0  0  ...  1  -a_{n-1}]
```

The matrix has 1s on the subdiagonal and the negatives of the polynomial
coefficients in the last column.
" title="Crystallographic.companion.{u_1} {R : Type u_1} [CommRing R] (p : R[X]) (_hp : p.Monic) (_hn : 0 &lt; p.natDegree) :
  Matrix (Fin p.natDegree) (Fin p.natDegree) R
The companion matrix of a monic polynomial p of degree n....">companion</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Polynomial.cyclotomic.monic" data-signature="Polynomial.cyclotomic.monic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : (cyclotomic n R).Monic" data-docs="`cyclotomic n` is monic. " title="Polynomial.cyclotomic.monic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : (cyclotomic n R).Monic
`cyclotomic n` is monic. ">cyclotomic.monic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ<span class="lean-bracket-1">)</span> <span class="lean-var" data-type="0 &lt; (cyclotomic m ℤ).natDegree" title="0 &lt; (cyclotomic m ℤ).natDegree">hn</span>
  <span class="lean-keyword" data-docs="If the main goal&#x27;s target type is an inductive type, `constructor` solves it with
the first matching constructor, or else fails.
" title="If the main goal&#x27;s target type is an inductive type, `constructor` solves it with">constructor</span>
  <span class="lean-operator">·</span> <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Crystallographic.companion_cyclotomic_orderOf" data-signature="Crystallographic.companion_cyclotomic_orderOf (m : ℕ) (hm : 2 ≤ m) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :
  orderOf (companion (cyclotomic m ℤ) ⋯ hn) = m" title="Crystallographic.companion_cyclotomic_orderOf (m : ℕ) (hm : 2 ≤ m) (hn : 0 &lt; (cyclotomic m ℤ).natDegree) :
  orderOf (companion (cyclotomic m ℤ) ⋯ hn) = m">companion_cyclotomic_orderOf</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> <span class="lean-var" data-type="2 ≤ m" title="2 ≤ m">hm</span> <span class="lean-var" data-type="0 &lt; (cyclotomic m ℤ).natDegree" title="0 &lt; (cyclotomic m ℤ).natDegree">hn</span>
  <span class="lean-operator">·</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Cyclotomic.lean#L145-L158" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:companion-cycl-mem');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:mem-orders-totient">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">4.0.7</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0004.html#thm:mem-orders-totient">#</a>
    
    <a class="icon proof" href="sect0004.html#a0000000043"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0004.html#thm:companion-cycl-mem">Theorem 4.0.6</a></li>
          
          <li><a href="sect0004.html#thm:companion-cycl-mem">Theorem 4.0.6</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.mem_integerMatrixOrders_totient" class="lean_decl">Crystallographic.mem_integerMatrixOrders_totient</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>        For \(m \geq 2\), \(m \in \mathrm{Ord}_{\varphi (m)}\). This is the key existence result: for every \(m \geq 2\), there exists an integer matrix of dimension \(\varphi (m)\) with multiplicative order exactly \(m\), namely the companion matrix of \(\Phi _m\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000043">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p> Apply the cyclotomic companion membership theorem after noting that \(\deg (\Phi _m) = \varphi (m)\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">theorem</span> <span class="lean-const lean-def" data-name="Crystallographic.mem_integerMatrixOrders_totient" data-signature="Crystallographic.mem_integerMatrixOrders_totient (m : ℕ) (hm : 2 ≤ m) : m ∈ integerMatrixOrders m.totient" title="Crystallographic.mem_integerMatrixOrders_totient (m : ℕ) (hm : 2 ≤ m) : m ∈ integerMatrixOrders m.totient">mem_integerMatrixOrders_totient</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="ℕ" title="ℕ">m</span> : ℕ<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="2 ≤ m" title="2 ≤ m">hm</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">2</span> <span class="lean-operator">≤</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span><span class="lean-bracket-1">)</span> :
    <span class="lean-var" data-type="ℕ" title="ℕ">m</span> <span class="lean-operator">∈</span> <span class="lean-const" data-name="Crystallographic.integerMatrixOrders" data-signature="Crystallographic.integerMatrixOrders (N : ℕ) : Set ℕ" data-docs="The set of possible orders for N×N integer matrices with finite order.
An integer `m` is in this set if there exists an N×N integer matrix `A` such that
`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). " title="Crystallographic.integerMatrixOrders (N : ℕ) : Set ℕ
The set of possible orders for N×N integer matrices with finite order....">Crystallographic.integerMatrixOrders</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Nat.totient" data-signature="Nat.totient (n : ℕ) : ℕ" data-docs="Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are
coprime with `n`. " title="Nat.totient (n : ℕ) : ℕ
Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are...">Nat.totient</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span><span class="lean-bracket-1">)</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(cyclotomic m ℤ).natDegree = m.totient" title="(cyclotomic m ℤ).natDegree = m.totient">hdeg</span> : <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ<span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ" data-docs="`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ
`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. ">natDegree</span> = <span class="lean-const" data-name="Nat.totient" data-signature="Nat.totient (n : ℕ) : ℕ" data-docs="Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are
coprime with `n`. " title="Nat.totient (n : ℕ) : ℕ
Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are...">Nat.totient</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> := <span class="lean-const" data-name="Polynomial.natDegree_cyclotomic" data-signature="Polynomial.natDegree_cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] [Nontrivial R] :
  (cyclotomic n R).natDegree = n.totient" data-docs="The natural degree of `cyclotomic n` is `totient n`. " title="Polynomial.natDegree_cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] [Nontrivial R] :
  (cyclotomic n R).natDegree = n.totient
The natural degree of `cyclotomic n` is `totient n`. ">Polynomial.natDegree_cyclotomic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="0 &lt; m.totient" title="0 &lt; m.totient">htot_pos</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">0</span> &lt; <span class="lean-const" data-name="Nat.totient" data-signature="Nat.totient (n : ℕ) : ℕ" data-docs="Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are
coprime with `n`. " title="Nat.totient (n : ℕ) : ℕ
Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are...">Nat.totient</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> := <span class="lean-const" data-name="Nat.totient_pos" data-signature="Nat.totient_pos {n : ℕ} : 0 &lt; n.totient ↔ 0 &lt; n" title="Nat.totient_pos {n : ℕ} : 0 &lt; n.totient ↔ 0 &lt; n">Nat.totient_pos</span>.<span class="lean-const" data-name="Iff.mpr" data-signature="Iff.mpr {a b : Prop} (self : a ↔ b) : b → a" data-docs="Modus ponens for if and only if, reversed. If `a ↔ b` and `b`, then `a`. " title="Iff.mpr {a b : Prop} (self : a ↔ b) : b → a
Modus ponens for if and only if, reversed. If `a ↔ b` and `b`, then `a`. ">mpr</span> <span class="lean-bracket-1">(</span><span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span><span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="0 &lt; (cyclotomic m ℤ).natDegree" title="0 &lt; (cyclotomic m ℤ).natDegree">hn</span> : <span class="lean-expr" data-type="ℕ" title="ℕ">0</span> &lt; <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : ℕ) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> ℤ<span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ" data-docs="`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : ℕ
`natDegree p` forces `degree p` to ℕ, by defining `natDegree 0 = 0`. ">natDegree</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span>
  <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-operator">←</span> <span class="lean-var" data-type="(cyclotomic m ℤ).natDegree = m.totient" title="(cyclotomic m ℤ).natDegree = m.totient">hdeg</span><span class="lean-bracket-1">]</span>
  <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Crystallographic.companion_cyclotomic_mem_integerMatrixOrders" data-signature="Crystallographic.companion_cyclotomic_mem_integerMatrixOrders (m : ℕ) (hm : 2 ≤ m)
  (hn : 0 &lt; (cyclotomic m ℤ).natDegree) : m ∈ integerMatrixOrders (cyclotomic m ℤ).natDegree" title="Crystallographic.companion_cyclotomic_mem_integerMatrixOrders (m : ℕ) (hm : 2 ≤ m)
  (hn : 0 &lt; (cyclotomic m ℤ).natDegree) : m ∈ integerMatrixOrders (cyclotomic m ℤ).natDegree">companion_cyclotomic_mem_integerMatrixOrders</span> <span class="lean-var" data-type="ℕ" title="ℕ">m</span> <span class="lean-var" data-type="2 ≤ m" title="2 ≤ m">hm</span> <span class="lean-var" data-type="0 &lt; (cyclotomic m ℤ).natDegree" title="0 &lt; (cyclotomic m ℤ).natDegree">hn</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Companion/Cyclotomic.lean#L160-L173" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:mem-orders-totient');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>



</div> <!--main-text -->
</div> <!-- content-wrapper -->
</div> <!-- content -->
</div> <!-- wrapper -->

<nav class="prev_up_next">
  <svg  id="showmore-minus" class="icon icon-eye-minus showmore"><use xlink:href="symbol-defs.svg#icon-eye-minus"></use></svg>

  <svg  id="showmore-plus" class="icon icon-eye-plus showmore"><use xlink:href="symbol-defs.svg#icon-eye-plus"></use></svg>

  <a href="sect0003.html" title="Integer Matrix Orders"><svg  class="icon icon-arrow-left "><use xlink:href="symbol-defs.svg#icon-arrow-left"></use></svg>
</a>
  <a href="index.html" title="Crystallographic Restriction Theorem"><svg  class="icon icon-arrow-up "><use xlink:href="symbol-defs.svg#icon-arrow-up"></use></svg>
</a>
  <a href="sect0005.html" title="The Crystallographic Restriction Theorem"><svg  class="icon icon-arrow-right "><use xlink:href="symbol-defs.svg#icon-arrow-right"></use></svg>
</a>
</nav>

<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/plastex.js"></script>
<script type="text/javascript" src="js/svgxuse.js"></script>
<script type="text/javascript" src="js/js.cookie.min.js"></script>
<script type="text/javascript" src="js/showmore.js"></script>
</body>
</html>