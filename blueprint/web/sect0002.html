<!DOCTYPE html>
<html lang="en">
<head>
<script>
  MathJax = { 
    tex: {
		    inlineMath: [['$','$'], ['\\(','\\)']]
	} }
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<meta name="generator" content="plasTeX" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Psi Function</title>
<link rel="next" href="sect0003.html" title="Integer Matrix Orders" />
<link rel="prev" href="sect0001.html" title="Introduction" />
<link rel="up" href="index.html" title="Crystallographic Restriction Theorem" />
<link rel="stylesheet" href="styles/theme-blue.css" />
<link rel="stylesheet" href="styles/showmore.css" />
<link rel="stylesheet" href="styles/blueprint.css" />
<link rel="stylesheet" href="styles/amsthm.css" />
<link rel="stylesheet" href="styles/style.css" />
</head>

<body>
<header>
<svg  id="toc-toggle" class="icon icon-list-numbered "><use xlink:href="symbol-defs.svg#icon-list-numbered"></use></svg>
<h1 id="doc_title"><a href="index.html">Crystallographic Restriction Theorem</a></h1>
</header>

<div class="wrapper">
<nav class="toc">
<ul class="sub-toc-0">
<li class="">
  <a href="sect0001.html"><span class="toc_ref">1</span> <span class="toc_entry">Introduction</span></a>
 </li>
<li class=" active current">
  <a href="sect0002.html"><span class="toc_ref">2</span> <span class="toc_entry">The Psi Function</span></a>
 </li>
<li class="">
  <a href="sect0003.html"><span class="toc_ref">3</span> <span class="toc_entry">Integer Matrix Orders</span></a>
 </li>
<li class="">
  <a href="sect0004.html"><span class="toc_ref">4</span> <span class="toc_entry">Companion Matrices</span></a>
 </li>
<li class="">
  <a href="sect0005.html"><span class="toc_ref">5</span> <span class="toc_entry">The Crystallographic Restriction Theorem</span></a>
 </li>
<li class="">
  <a href="sect0006.html"><span class="toc_ref">A</span> <span class="toc_entry">Appendix</span></a>
 </li>
<li ><a href="dep_graph_document.html">Dependency graph</a></li>
</ul>
</nav>

<div class="content">
<div class="content-wrapper">


<div class="main-text">
<h1 id="a0000000003">2 The Psi Function</h1>
<p>The \(\psi \) function measures the “arithmetic complexity” of a positive integer \(m\). For a prime power \(p^k\), we define: </p>
<ul class="itemize">
  <li><p>\(\psi _{\mathrm{pp}}(p,k) = \varphi (p^k)\) for \(p\) odd or \(k \geq 2\) </p>
</li>
  <li><p>\(\psi _{\mathrm{pp}}(2,1) = 0\) </p>
</li>
</ul>
<p>For a general integer \(m\) with prime factorization \(m = \prod _i p_i^{k_i}\), we have: </p>
<div class="displaymath" id="a0000000011">
  \[ \psi (m) = \sum _i \psi _{\mathrm{pp}}(p_i, k_i) \]
</div>
<div class="definition_thmwrapper sbs-container theorem-style-definition" id="psiPrimePow-def">
  <div class="sbs-latex-column">
    <div class="definition_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.0.1</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0002.html#psiPrimePow-def">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.psiPrimePow" class="lean_decl">Crystallographic.psiPrimePow</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="definition_thmcontent">
    <p>     The function \(\psi _{\text{pp}}(p, k)\) computes the contribution of a single prime power \(p^k\) to \(\psi \). Returns \(0\) if \(k = 0\) or if \(p = 2\) and \(k = 1\), otherwise returns \(\varphi (p^k)\). </p>
<p>The special case \(\psi _{\text{pp}}(2, 1) = 0\) reflects that \(-I\) achieves order \(2\) in any dimension \(\geq 1\), so order \(2\) does not require additional dimensions. For all other prime powers \(p^k\), we need \(\varphi (p^k)\) dimensions to achieve order \(p^k\). </p>

    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>Crystallographic.psiPrimePow (p k : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">Helper function that computes the contribution of a single prime power p^k to psi.\nReturns 0 if k = 0, returns 0 if p = 2 and k = 1, otherwise returns phi(p^k). </code>","1":"<code>ℕ</code>","2":"<code class=\"docstring\">`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n</code>","3":"<code>Nat.totient (n : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">Euler's totient function. This counts the number of naturals strictly less than `n` which are\ncoprime with `n`. </code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1978">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.psiPrimePow" data-verso-hover="0">psiPrimePow</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-2017" data-verso-hover="2">if</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="1">0</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-2017" data-verso-hover="2">then</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="1">0</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-2017" data-verso-hover="2">else</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-2040" data-verso-hover="2">if</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="1">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="1">1</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-2040" data-verso-hover="2">then</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="1">0</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-2040" data-verso-hover="2">else</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.totient" data-verso-hover="3">Nat.totient</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="1">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Psi/Basic.lean#L49-L63" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>

<div class="definition_thmwrapper sbs-container theorem-style-definition" id="psi-def">
  <div class="sbs-latex-column">
    <div class="definition_thmheading">
      <span class="definition_thmcaption">
      Definition
      </span>
      <span class="definition_thmlabel">2.0.2</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0002.html#psi-def">#</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0002.html#psiPrimePow-def">Definition 2.0.1</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.psi" class="lean_decl">Crystallographic.psi</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="definition_thmcontent">
    <p>     The psi function \(\psi (m) = \sum _{p^k \|  m} \psi _{\text{pp}}(p, k)\), which gives the minimum dimension \(N\) such that an \(N \times N\) integer matrix can have order \(m\). </p>
<p>For \(m\) with prime factorization \(m = \prod _i p_i^{k_i}\): </p>
<div class="displaymath" id="a0000000012">
  \[ \psi (m) = \sum _i \psi _{\text{pp}}(p_i, k_i) = \sum _{\substack {p^k \|  m \\ (p,k) \neq (2,1)}} \varphi (p^k) \]
</div>
<p> This gives the minimum dimension needed to realize order \(m\).  </p>

    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>Crystallographic.psi (m : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The psi function for crystallographic restriction.\npsi(m) is the minimum dimension N such that an N×N integer matrix can have order m.\n\nDefined as the sum over prime power factors: if m = prod p_i^{k_i}, then\npsi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) </code>","1":"<code>ℕ</code>","2":"<code>Nat.factorization (n : ℕ) : ℕ →₀ ℕ</code><span class=\"sep\"></span><code class=\"docstring\">`n.factorization` is the finitely supported function `ℕ →₀ ℕ`\nmapping each prime factor of `n` to its multiplicity in `n`. </code>","3":"<code>Finsupp.sum.{u_1, u_8, u_10} {α : Type u_1} {M : Type u_8} {N : Type u_10} [Zero M] [AddCommMonoid N] (f : α →₀ M)\n  (g : α → M → N) : N</code><span class=\"sep\"></span><code class=\"docstring\">`sum f g` is the sum of `g a (f a)` over the support of `f`. </code>","4":"<code>Crystallographic.psiPrimePow (p k : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">Helper function that computes the contribution of a single prime power p^k to psi.\nReturns 0 if k = 0, returns 0 if p = 2 and k = 1, otherwise returns phi(p^k). </code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-3014">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.psi" data-verso-hover="0">psi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.205" data-verso-hover="1">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
  </span><span class="var token" data-binding="var-_uniq.205" data-verso-hover="1">m</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.factorization" data-verso-hover="2">factorization</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Finsupp.sum" data-verso-hover="3">sum</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3063">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.282" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.285" data-verso-hover="1">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.psiPrimePow" data-verso-hover="4">psiPrimePow</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.282" data-verso-hover="1">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.285" data-verso-hover="1">k</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Psi/Basic.lean#L70-L87" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>

<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:psi-prime-pow">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">2.0.1</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0002.html#lem:psi-prime-pow">#</a>
    
    <a class="icon proof" href="sect0002.html#a0000000013"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0002.html#psiPrimePow-def">Definition 2.0.1</a></li>
          
          <li><a href="sect0002.html#psi-def">Definition 2.0.2</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.psi_prime_pow" class="lean_decl">Crystallographic.psi_prime_pow</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>      For prime \(p\) and \(k {\gt} 0\): \(\psi (p^k) = \varphi (p^k)\) unless \(p = 2, k = 1\). </p>
<p>For a prime power \(p^k\), the factorization has a single term, so \(\psi (p^k) = \psi _{\text{pp}}(p, k)\). This equals \(\varphi (p^k) = p^{k-1}(p-1)\) except when \(p = 2\) and \(k = 1\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000013">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>For prime power \(p^k\), the factorization has a single term, so \(\psi (p^k) = \psi _{pp}(p, k)\). This equals \(\varphi (p^k)\) except when \(p = 2, k = 1\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>ℕ</code>","1":"<code>Nat.Prime p</code>","2":"<code>Nat.Prime (p : ℕ) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. </code>","3":"<code>0 &lt; k</code>","4":"<code>Crystallographic.psi (m : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The psi function for crystallographic restriction.\npsi(m) is the minimum dimension N such that an N×N integer matrix can have order m.\n\nDefined as the sum over prime power factors: if m = prod p_i^{k_i}, then\npsi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) </code>","5":"<code class=\"docstring\">`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n</code>","6":"<code>Nat.totient (n : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">Euler's totient function. This counts the number of naturals strictly less than `n` which are\ncoprime with `n`. </code>","7":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-4200">theorem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">psi_prime_pow</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.419" data-verso-hover="0">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.421" data-verso-hover="0">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.424" data-verso-hover="1">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.419" data-verso-hover="0">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.Prime" data-verso-hover="2">Prime</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.470" data-verso-hover="3">hk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.421" data-verso-hover="0">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="const token" data-binding="const-Crystallographic.psi" data-verso-hover="4">psi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.419" data-verso-hover="0">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.421" data-verso-hover="0">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-4282" data-verso-hover="5">if</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.419" data-verso-hover="0">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.421" data-verso-hover="0">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">1</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-4282" data-verso-hover="5">then</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">0</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-4282" data-verso-hover="5">else</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.totient" data-verso-hover="6">Nat.totient</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.419" data-verso-hover="0">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.421" data-verso-hover="0">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-4336" data-verso-hover="7">by</span></code><code class="lean-proof-body"><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-4341" data-verso-hover="0">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-4346">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">psi</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-4359" data-verso-hover="1">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hp.factorization_pow</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-4387" data-verso-hover="1">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">Finsupp.sum_single_index</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">psiPrimePow_zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-4440" data-verso-hover="0">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-4445">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">psiPrimePow</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hk.ne'</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ite_false</span><span class="unknown token" data-binding="">]</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Psi/Basic.lean#L107-L122" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:psi-prime-pow');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:factorization-disjoint">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">2.0.2</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0002.html#lem:factorization-disjoint">#</a>
    
    <a class="icon proof" href="sect0002.html#a0000000014"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.factorization_support_disjoint" class="lean_decl">Crystallographic.factorization_support_disjoint</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   Coprime numbers have disjoint prime factorization supports. </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000014">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>If \(p\) divides both \(m\) and \(n\), then \(p \mid \gcd (m,n) = 1\), contradicting \(p\) prime. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma factorization_support_disjoint {m n : ℕ} (h : m.Coprime n) :
    Disjoint m.factorization.support n.factorization.support :=
  Nat.support_factorization m ▸ Nat.support_factorization n ▸ h.disjoint_primeFactors</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Psi/Basic.lean#L161-L169" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:psi-coprime-add">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">2.0.3</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0002.html#lem:psi-coprime-add">#</a>
    
    <a class="icon proof" href="sect0002.html#a0000000015"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0002.html#psi-def">Definition 2.0.2</a></li>
          
          <li><a href="sect0002.html#lem:factorization-disjoint">Theorem 2.0.2</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.psi_coprime_add" class="lean_decl">Crystallographic.psi_coprime_add</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>      \(\psi (mn) = \psi (m) + \psi (n)\) for coprime \(m, n\). </p>
<p>When \(\gcd (m, n) = 1\), the prime factorizations of \(m\) and \(n\) share no common primes, so </p>
<div class="displaymath" id="a0000000016">
  \[ \psi (mn) = \sum _{p^k \|  mn} \psi _{\text{pp}}(p, k) = \sum _{p^k \|  m} \psi _{\text{pp}}(p, k) + \sum _{p^k \|  n} \psi _{\text{pp}}(p, k) = \psi (m) + \psi (n). \]
</div>


    </div>
    <div class="proof_wrapper proof_inline" id="a0000000015">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>When \(\gcd (m, n) = 1\), the factorizations of \(m\) and \(n\) are disjoint. Each prime power in \(mn\) comes from exactly one of \(m\) or \(n\), so the \(\psi \) contributions add. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>ℕ</code>","1":"<code>0 &lt; m</code>","2":"<code>0 &lt; n</code>","3":"<code>m.Coprime n</code>","4":"<code>Nat.Coprime (m n : ℕ) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. </code>","5":"<code>Crystallographic.psi (m : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The psi function for crystallographic restriction.\npsi(m) is the minimum dimension N such that an N×N integer matrix can have order m.\n\nDefined as the sum over prime power factors: if m = prod p_i^{k_i}, then\npsi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) </code>","6":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-7679">theorem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">psi_coprime_add</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1988" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1990" data-verso-hover="0">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2036" data-verso-hover="1">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1988" data-verso-hover="0">m</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2074" data-verso-hover="2">hn</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1990" data-verso-hover="0">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2078" data-verso-hover="3">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1988" data-verso-hover="0">m</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.Coprime" data-verso-hover="4">Coprime</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1990" data-verso-hover="0">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="const token" data-binding="const-Crystallographic.psi" data-verso-hover="5">psi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1988" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1990" data-verso-hover="0">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.psi" data-verso-hover="5">psi</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1988" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.psi" data-verso-hover="5">psi</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1990" data-verso-hover="0">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-7796" data-verso-hover="6">by</span></code><code class="lean-proof-body"><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-7801" data-verso-hover="0">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-7806">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">psi</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Finsupp.sum</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-7832" data-verso-hover="1">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">Nat.factorization_mul</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.pos_iff_ne_zero.mp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.pos_iff_ne_zero.mp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hn</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-7917" data-verso-hover="2">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdisj</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">factorization_support_disjoint</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-7966" data-verso-hover="1">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">Finsupp.support_add_eq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdisj</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-8002" data-verso-hover="1">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">Finset.sum_union</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdisj</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.congr-8032" data-verso-hover="3">congr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-8045" data-verso-hover="4">apply</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Finset.sum_congr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">rfl</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-8076" data-verso-hover="5">intro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.congr-8091" data-verso-hover="3">congr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-8103" data-verso-hover="1">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">Finsupp.add_apply</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">factorization_eq_zero_of_disjoint_support</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdisj</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">add_zero</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-8193" data-verso-hover="4">apply</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Finset.sum_congr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">rfl</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-8224" data-verso-hover="5">intro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.congr-8239" data-verso-hover="3">congr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-8251" data-verso-hover="1">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">Finsupp.add_apply</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">factorization_eq_zero_of_disjoint_support</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdisj.symm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">zero_add</span><span class="unknown token" data-binding="">]</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Psi/Basic.lean#L177-L208" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:psi-coprime-add');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:psi-ge-psiPrimePow">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">2.0.4</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0002.html#lem:psi-ge-psiPrimePow">#</a>
    
    <a class="icon proof" href="sect0002.html#a0000000017"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.psi_ge_psiPrimePow_of_mem_support" class="lean_decl">Crystallographic.psi_ge_psiPrimePow_of_mem_support</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   \(\psi (m) \geq \psi _{\mathrm{pp}}(p, v_p(m))\) for each prime \(p \mid m\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000017">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>The sum \(\psi (m)\) includes the term \(\psi _{\mathrm{pp}}(p, v_p(m))\), and all terms are non-negative. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma psi_ge_psiPrimePow_of_mem_support {m p : ℕ}
    (hp : p ∈ m.factorization.support) :
    psiPrimePow p (m.factorization p) ≤ psi m := by</span></code><code class="lean-proof-body"><span class="lean-plain">simp only [psi, Finsupp.sum]
  have hnonneg : ∀ i ∈ m.factorization.support, 0 ≤ psiPrimePow i (m.factorization i) := by
    intro i _
    simp only [psiPrimePow]
    split_ifs &lt;;&gt; omega
  exact Finset.single_le_sum hnonneg hp</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Psi/Basic.lean#L230-L244" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:psi-ge-psiPrimePow');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:two-le-totient-prime-pow">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">2.0.5</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0002.html#lem:two-le-totient-prime-pow">#</a>
    
    <a class="icon proof" href="sect0002.html#a0000000018"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.two_le_totient_primePow" class="lean_decl">Crystallographic.two_le_totient_primePow</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>      For any prime power \(p^k {\gt} 2\), we have \(2 \leq \varphi (p^k)\). </p>
<p>Specifically, \(\varphi (p^k) = p^{k-1}(p-1) \geq 2\) unless \((p, k) = (2, 1)\), in which case \(\varphi (2) = 1\). This bound is essential for showing that sums of totients are bounded by products when factors are coprime.  - </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000018">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By cases on \(p = 2\): if \(p \neq 2\), then \(p \geq 3\) so \(\varphi (p^k) = p^{k-1}(p-1) \geq 1 \cdot 2 = 2\). If \(p = 2\) and \(k \geq 2\), then \(\varphi (2^k) = 2^{k-1} \geq 2\). The case \((2, 1)\) is excluded by hypothesis. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>ℕ</code>","1":"<code>Nat.Prime p</code>","2":"<code>Nat.Prime (p : ℕ) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. </code>","3":"<code>0 &lt; k</code>","4":"<code>¬(p = 2 ∧ k = 1)</code>","5":"<code>Nat.totient (n : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">Euler's totient function. This counts the number of naturals strictly less than `n` which are\ncoprime with `n`. </code>","6":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-1653">theorem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">two_le_totient_primePow</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="0">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="0">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7" data-verso-hover="1">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="0">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.Prime" data-verso-hover="2">Prime</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.53" data-verso-hover="3">hk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="0">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.114" data-verso-hover="4">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="0">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="0">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.totient" data-verso-hover="5">Nat.totient</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="0">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="0">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-1786" data-verso-hover="6">by</span></code><code class="lean-proof-body"><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-1791" data-verso-hover="0">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">Nat.totient_prime_pow</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hk</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-«tacticBy_cases_:_»-1826" data-verso-hover="1">by_cases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simpa-1852" data-verso-hover="2">simpa</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hp2</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-1864">using</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.pow_le_pow_right</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-1892" data-verso-hover="3">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-1895" data-verso-hover="4">omega</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-1903" data-verso-hover="3">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-1906" data-verso-hover="4">omega</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-1932" data-verso-hover="5">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.lt_of_le_of_ne</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp.two_le</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Ne.symm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp2</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.calcTactic-2001" data-verso-hover="6">calc</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≥</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.mul_le_mul_right</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.one_le_pow</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp.pos</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≥</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-2115" data-verso-hover="3">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-2118" data-verso-hover="4">omega</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Psi/Bounds.lean#L39-L56" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:two-le-totient-prime-pow');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:factorization-split-lt">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">2.0.6</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0002.html#lem:factorization-split-lt">#</a>
    
    <a class="icon proof" href="sect0002.html#a0000000019"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.factorization_split_lt" class="lean_decl">Crystallographic.factorization_split_lt</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>      A composite number \(m {\gt} 2\) that is not a prime power can be written as \(m = p^e \cdot m'\) where \(p\) is prime, \(e {\gt} 0\), \(\gcd (p^e, m') = 1\), and both \(p^e {\lt} m\) and \(1 {\lt} m' {\lt} m\). </p>
<p>This decomposition is essential for strong induction proofs on composite numbers: it provides strictly smaller coprime factors to which the inductive hypothesis applies.  - </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000019">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>Take \(p = \mathrm{minFac}(m)\) and \(e = \nu _p(m)\), the \(p\)-adic valuation. Then \(m' = m / p^e\) is coprime to \(p^e\) (disjoint prime support). Since \(m\) is not a prime power, \(m' \neq 1\). The bounds \(p^e {\lt} m\) and \(m' {\lt} m\) follow from \(m' {\gt} 1\) and \(p^e \geq 2\) respectively. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>ℕ</code>","1":"<code>2 &lt; m</code>","2":"<code>¬IsPrimePow m</code>","3":"<code>IsPrimePow.{u_1} {R : Type u_1} [CommMonoidWithZero R] (n : R) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`n` is a prime power if there is a prime `p` and a positive natural `k` such that `n` can be\nwritten as `p^k`. </code>","4":"<code>Nat.Prime (p : ℕ) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. </code>","5":"<code>Nat.Coprime (m n : ℕ) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. </code>","6":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-3577">theorem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">factorization_split_lt</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.365" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.407" data-verso-hover="1">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.365" data-verso-hover="0">m</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.417" data-verso-hover="2">h_not_pp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="const token" data-binding="const-IsPrimePow" data-verso-hover="3">IsPrimePow</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.365" data-verso-hover="0">m</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">∃</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.422" data-verso-hover="0">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.426" data-verso-hover="0">e</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.430" data-verso-hover="0">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.422" data-verso-hover="0">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.Prime" data-verso-hover="4">Prime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.426" data-verso-hover="0">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.422" data-verso-hover="0">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.426" data-verso-hover="0">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.430" data-verso-hover="0">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.365" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.422" data-verso-hover="0">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.426" data-verso-hover="0">e</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.Coprime" data-verso-hover="5">Coprime</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.430" data-verso-hover="0">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.430" data-verso-hover="0">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.430" data-verso-hover="0">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.365" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.422" data-verso-hover="0">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.426" data-verso-hover="0">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.365" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-3788" data-verso-hover="6">by</span></code><code class="lean-proof-body"><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-3793" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_ne_zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-3822" data-verso-hover="1">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-3825" data-verso-hover="2">omega</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-3833" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_ne_one</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-3861" data-verso-hover="1">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-3864" data-verso-hover="2">omega</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-3872" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-3895" data-verso-hover="1">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-3898" data-verso-hover="2">omega</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-3906" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminFac_prime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m.minFac.Prime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.minFac_prime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_ne_one</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Mathlib.Tactic.setTactic-3974" data-verso-hover="3">set</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m.minFac</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Mathlib.Tactic.setTactic-3994" data-verso-hover="3">set</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m.factorization</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-4023" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">he_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">Nat.Prime.factorization_pos_of_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminFac_prime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_ne_zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.minFac_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-4131" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.ordProj_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Mathlib.Tactic.setTactic-4180" data-verso-hover="3">set</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">/</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-4202" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.div_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.le_of_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdvd</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.pow_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminFac_prime.pos</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-4301" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_eq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.mul_div_cancel'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdvd</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">symm</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-4366" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hcop</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.Coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.coprime_ordCompl</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminFac_prime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_ne_zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|&gt;.</span><span class="unknown token" data-binding="">pow_left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text">
  -- m' ≠ 1 because m is not a prime power
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-4511" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_ne_one</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-4541" data-verso-hover="1">by</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-4548" data-verso-hover="4">intro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_one</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-4566" data-verso-hover="5">apply</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_not_pp</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-4585" data-verso-hover="6">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">isPrimePow_nat_iff</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-4613" data-verso-hover="7">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">p</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminFac_prime</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">he_pos</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-4651" data-verso-hover="1">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-4654" data-verso-hover="6">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hm_eq</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_one</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">mul_one</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-4688" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_gt_one</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-4716" data-verso-hover="1">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-4719" data-verso-hover="2">omega</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-4727" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_lt</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-4751" data-verso-hover="1">by</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-4758" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpe_ge2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-4788" data-verso-hover="1">by</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.calcTactic-4797" data-verso-hover="8">calc</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≥</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.pow_le_pow_right</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminFac_prime.one_lt.le</span><span class="inter-text"> </span><span class="unknown token" data-binding="">he_pos</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pow_one</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≥</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminFac_prime.two_le</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.calcTactic-4944" data-verso-hover="8">calc</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">one_mul</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">symm</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.mul_lt_mul_of_pos_right</span><span class="inter-text">
          </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.one_lt_pow</span><span class="inter-text"> </span><span class="unknown token" data-binding="">he_pos.ne'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminFac_prime.one_lt</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_pos</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_eq.symm</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-5128" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpe_lt</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-5155" data-verso-hover="1">by</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.calcTactic-5162" data-verso-hover="8">calc</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">mul_one</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">symm</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.mul_lt_mul_of_pos_left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_gt_one</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.pow_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminFac_prime.pos</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_eq.symm</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-5327" data-verso-hover="7">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">p</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminFac_prime</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">he_pos</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_eq.symm</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hcop</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_gt_one</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_lt</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpe_lt</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Psi/Bounds.lean#L71-L119" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:factorization-split-lt');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:psi-pos-of-odd">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">2.0.7</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0002.html#lem:psi-pos-of-odd">#</a>
    
    <a class="icon proof" href="sect0002.html#a0000000020"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0002.html#psi-def">Definition 2.0.2</a></li>
          
          <li><a href="sect0002.html#psiPrimePow-def">Definition 2.0.1</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.psi_pos_of_odd_ge_three" class="lean_decl">Crystallographic.psi_pos_of_odd_ge_three</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>      For odd \(m \geq 3\), we have \(\psi (m) {\gt} 0\). </p>
<p>Since \(m \geq 3\) and \(m\) is odd, \(m\) has a prime factor \(q \geq 3\) (specifically, \(q = \mathrm{minFac}(m)\)). The prime power \(q^{\nu _q(m)}\) contributes \(\psi _{\mathrm{pp}}(q, \nu _q(m)) = \varphi (q^{\nu _q(m)}) {\gt} 0\) to \(\psi (m)\), since \((q, \nu _q(m)) \neq (2, 1)\).  - </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000020">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>The minimal prime factor \(q = \mathrm{minFac}(m)\) satisfies \(q \geq 3\) (since \(2 \nmid m\)). Thus \((q, \nu _q(m))\) is a nontrivial pair, and \(\psi (m) \geq \psi _{\mathrm{pp}}(q, \nu _q(m)) = \varphi (q^{\nu _q(m)}) {\gt} 0\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>ℕ</code>","1":"<code>3 ≤ m</code>","2":"<code>Odd m</code>","3":"<code>Odd.{u_2} {α : Type u_2} [Semiring α] (a : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">An element `a` of a semiring is odd if there exists `k` such `a = 2*k + 1`. </code>","4":"<code>Crystallographic.psi (m : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The psi function for crystallographic restriction.\npsi(m) is the minimum dimension N such that an N×N integer matrix can have order m.\n\nDefined as the sum over prime power factors: if m = prod p_i^{k_i}, then\npsi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) </code>","5":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-6065">theorem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">psi_pos_of_odd_ge_three</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.663" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.705" data-verso-hover="1">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.663" data-verso-hover="0">m</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.746" data-verso-hover="2">hm_odd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Odd" data-verso-hover="3">Odd</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.663" data-verso-hover="0">m</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="typed token" data-binding="" data-verso-hover="0">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.psi" data-verso-hover="4">psi</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.663" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-6158" data-verso-hover="5">by</span></code><code class="lean-proof-body"><span class="inter-text">
  -- m &gt;= 3 implies m != 1, so minFac(m) is prime
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-6213" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_ne_one</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-6241" data-verso-hover="1">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-6244" data-verso-hover="2">omega</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-6252" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_ne_zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-6281" data-verso-hover="1">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-6284" data-verso-hover="2">omega</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Mathlib.Tactic.setTactic-6292" data-verso-hover="3">set</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m.minFac</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-6310">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_def</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-6324" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_prime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q.Prime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.minFac_prime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_ne_one</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-6380" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.minFac_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text">
  -- m is odd, so minFac(m) != 2 (otherwise 2 would divide m)
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-6486" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_ne2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-6511" data-verso-hover="1">by</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-6518" data-verso-hover="4">intro</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq2eq</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-6534" data-verso-hover="5">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hq2eq</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-6545" data-verso-hover="6">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_dvd</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-6559" data-verso-hover="7">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_odd.not_two_dvd_nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_dvd</span><span class="inter-text">
  -- Therefore minFac(m) &gt;= 3
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-6627" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_ge3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-6652" data-verso-hover="1">by</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-6659" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_prime.two_le</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-6701" data-verso-hover="2">omega</span><span class="inter-text">
  -- q is in the factorization support
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-6748" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_in_support</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m.factorization.support</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-6802" data-verso-hover="1">by</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-6809" data-verso-hover="5">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">Finsupp.mem_support_iff</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-6842" data-verso-hover="7">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.Prime.factorization_pos_of_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_prime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_ne_zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_dvd</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">ne'</span><span class="inter-text">
  -- psi(m) &gt;= psiPrimePow(q, ord_q(m))
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-6958" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hcontrib</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">psiPrimePow</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">m.factorization</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="unknown token" data-binding="">psi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">psi_ge_psiPrimePow_of_mem_support</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_in_support</span><span class="inter-text">
  -- psiPrimePow(q, k) = totient(q^k) &gt; 0 for q &gt;= 3 (since q != 2 means (q, k) != (2, 1))
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-7166" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hcontrib_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">psiPrimePow</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">m.factorization</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-7227" data-verso-hover="1">by</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-7234" data-verso-hover="8">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-7239">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">psiPrimePow</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-7262" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hk_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m.factorization</span><span class="inter-text"> </span><span class="unknown token" data-binding="">q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">Nat.Prime.factorization_pos_of_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_prime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_ne_zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_dvd</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-7373" data-verso-hover="8">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-7378">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hk_pos.ne'</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ite_false</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-7411" data-verso-hover="8">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-7416">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hq_ne2</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">false_and</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ite_false</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-7456" data-verso-hover="7">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.totient_pos.mpr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.pow_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hq_prime.pos</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-7511" data-verso-hover="2">omega</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Psi/Bounds.lean#L121-L164" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:psi-pos-of-odd');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:psi-le-totient">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">2.0.8</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0002.html#lem:psi-le-totient">#</a>
    
    <a class="icon proof" href="sect0002.html#a0000000021"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0002.html#psi-def">Definition 2.0.2</a></li>
          
          <li><a href="sect0002.html#psiPrimePow-def">Definition 2.0.1</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.psi_le_totient" class="lean_decl">Crystallographic.psi_le_totient</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   For all \(m \geq 1\), we have \(\psi (m) \leq \varphi (m)\). </p>
<p>We prove \(\psi (m) \leq \varphi (m)\) by strong induction on \(m\). The key observation is that \(\psi \) excludes the contribution from \((2, 1)\), while \(\varphi \) includes \(\varphi (2) = 1\), so \(\psi \leq \varphi \) with equality when \(2 \nmid m\) or \(4 \mid m\). </p>
<p>The proof proceeds by strong induction on \(m\): </p>
<ul class="itemize">
  <li><p>For \(m = 1\): \(\psi (1) = 0 \leq 1 = \varphi (1)\) </p>
</li>
  <li><p>For prime powers \(p^k\): \(\psi (p^k) = \varphi (p^k)\) (with the exception \(\psi (2) = 0\)) </p>
</li>
  <li><p>For composite \(m = 2 \cdot \text{odd}\): \(\psi (m) = \psi (\text{odd}) \leq \varphi (\text{odd}) = \varphi (m)\) </p>
</li>
  <li><p>For general composite without \(2^1\) factor: each \(\varphi (p^k) \geq 2\), so sum \(\leq \) product </p>
</li>
</ul>
<p>  - </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000021">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By strong induction on \(m\). For \(m = 1\): both sides are \(0\). For \(m {\gt} 1\): use coprime factorization \(m = a \cdot b\) with \(1 {\lt} a, b {\lt} m\). Then \(\psi (m) = \psi (a) + \psi (b) \leq \varphi (a) + \varphi (b) \leq \varphi (m)\) by the inductive hypothesis and multiplicativity of \(\varphi \). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma psi_le_totient (m : ℕ) (hm : 0 &lt; m) : psi m ≤ Nat.totient m := by</span></code><code class="lean-proof-body"><span class="lean-plain">-- Strong induction on m
  induction m using Nat.strong_induction_on with
  | _ m IH =&gt;
  -- Handle small cases separately
  rcases Nat.lt_trichotomy m 1 with hm0 | rfl | hm_gt1
  · omega -- m &lt; 1 contradicts hm
  · simp [psi_one] -- m = 1
  · rcases Nat.lt_trichotomy m 2 with hm_lt2 | rfl | hm_ge3
    · omega -- m &lt; 2 but m &gt; 1, contradiction
    · simp [psi_two] -- m = 2
    · -- m ≥ 3
      have hm_gt1 : 1 &lt; m := by omega
      -- Check if m is a prime power
      by_cases hpow : IsPrimePow m
      · -- m is a prime power p^k
        rw [isPrimePow_nat_iff] at hpow
        obtain ⟨p, k, hp, hk, rfl⟩ := hpow
        rw [psi_prime_pow p k hp hk]
        split_ifs with h21
        · simp -- psi(2) = 0 ≤ totient(2)
        · exact le_refl _ -- psi(p^k) = totient(p^k) for other prime powers
      · -- m is not a prime power, so it has multiple distinct prime factors
        -- Factor m = p^e * m&#x27; using factorization_split_lt
        obtain ⟨p, e, m&#x27;, hp, he_pos, hm_eq, hcop, hm&#x27;_gt_one, hm&#x27;_lt, _⟩ :=
          factorization_split_lt (by omega : 2 &lt; m) hpow
        have hm&#x27;_pos : 0 &lt; m&#x27; := by omega
        have hm&#x27;_ne_one : m&#x27; ≠ 1 := by omega
        -- psi and totient are additive/multiplicative on coprime factors
        rw [← hm_eq, psi_coprime_add _ _ (Nat.pow_pos hp.pos) hm&#x27;_pos hcop,
            Nat.totient_mul hcop]
        -- By IH: psi(m&#x27;) ≤ totient(m&#x27;)
        have IH_m&#x27; : psi m&#x27; ≤ Nat.totient m&#x27; := IH m&#x27; hm&#x27;_lt hm&#x27;_pos
        -- For the prime power part: psi(p^e) ≤ totient(p^e)
        have hpsi_pe : psi (p ^ e) ≤ Nat.totient (p ^ e) := by
          rw [psi_prime_pow p e hp he_pos]
          split_ifs &lt;;&gt; simp
        -- Three cases based on whether p^e or m&#x27; equals 2
        by_cases h21 : p = 2 ∧ e = 1
        · -- Case 1: p^e = 2, so psi(2) = 0 and totient(2) = 1
          obtain ⟨hp2, he1⟩ := h21
          simp only [hp2, he1, pow_one, psi_two, Nat.totient_two, zero_add,
            one_mul]
          exact IH_m&#x27;
        · by_cases hm&#x27;2 : m&#x27; = 2
          · -- Case 2: m&#x27; = 2, so psi(2) = 0 and totient(2) = 1
            simp only [hm&#x27;2, psi_two, Nat.totient_two, add_zero, mul_one]
            exact hpsi_pe
          · -- Case 3: Neither is 2^1, so both totients &gt;= 2
            have htot_m&#x27;_ge2 : 2 ≤ Nat.totient m&#x27; :=
              two_le_totient_of_two_lt m&#x27; (by omega : 2 &lt; m&#x27;)
            have htot_pe_ge2 : 2 ≤ Nat.totient (p ^ e) := two_le_totient_primePow hp he_pos h21
            exact psi_sum_le_totient_prod_of_ge_two hpsi_pe IH_m&#x27; htot_pe_ge2 htot_m&#x27;_ge2</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Psi/Bounds.lean#L168-L251" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:psi-le-totient');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:prime-pow-achieved-of-lcm-eq">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">2.0.9</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0002.html#lem:prime-pow-achieved-of-lcm-eq">#</a>
    
    <a class="icon proof" href="sect0002.html#a0000000022"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0006.html#lem:lcm-factorization-le-sup">Theorem A.0.2</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.primePow_achieved_of_lcm_eq" class="lean_decl">Crystallographic.primePow_achieved_of_lcm_eq</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   If \(S\) is a finite set of divisors of \(m\) with \(\mathrm{lcm}(S) = m\), then for each prime \(q\) dividing \(m\), some element \(d \in S\) is divisible by \(q^{\nu _q(m)}\). </p>
<p>In other words, the full \(q\)-power component of \(m\) must be "achieved" by some element of \(S\). This is the key combinatorial fact ensuring that \(\psi (m) \leq \sum _{d \in S} \varphi (d)\).  - </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000022">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By contradiction: if all \(d \in S\) have \(\nu _q(d) {\lt} \nu _q(m)\), then \(\nu _q(\mathrm{lcm}(S)) = \sup _{d \in S} \nu _q(d) {\lt} \nu _q(m)\), contradicting \(\mathrm{lcm}(S) = m\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma primePow_achieved_of_lcm_eq {m : ℕ} (hm : 0 &lt; m) (S : Finset ℕ)
    (hS_sub : ∀ d ∈ S, d ∣ m) (hS_lcm : S.lcm id = m) :
    ∀ q ∈ m.factorization.support, ∃ d ∈ S, q ^ m.factorization q ∣ d := by</span></code><code class="lean-proof-body"><span class="lean-plain">intro q hq
  have hq_prime := Nat.prime_of_mem_primeFactors (Nat.support_factorization m ▸ hq)
  by_contra hall
  push_neg at hall
  -- All d ∈ S have q^{ord_q(m)} not dividing d
  have hall&#x27; : ∀ d ∈ S, d.factorization q &lt; m.factorization q := by
    intro d hd
    have hndvd := hall d hd
    have hdvd : d ∣ m := hS_sub d hd
    have hd_pos : 0 &lt; d := Nat.pos_of_dvd_of_pos hdvd hm
    by_contra hge
    push_neg at hge
    have := (hq_prime.pow_dvd_iff_le_factorization hd_pos.ne&#x27;).mpr hge
    exact hndvd this
  -- lcm(S).factorization q = sup of d.factorization q, which is &lt; m.factorization q
  -- This contradicts hS_lcm since lcm(S) = m requires matching factorizations.
  have hne_zero : S.lcm id ≠ 0 := by rw [hS_lcm]; exact hm.ne&#x27;
  have hk_pos : 0 &lt; m.factorization q := Finsupp.mem_support_iff.mp hq |&gt; Nat.pos_of_ne_zero
  have hfact_q : (S.lcm id).factorization q &lt; m.factorization q := by
    -- Show: (S.lcm id).factorization q ≤ S.sup (d.factorization q) &lt; m.factorization q
    have hsup_lt : S.sup (fun d =&gt; d.factorization q) &lt; m.factorization q :=
      Finset.sup_lt_iff hk_pos |&gt;.mpr (fun d hd =&gt; hall&#x27; d hd)
    -- Use extracted lemma for lcm factorization bound
    have hS_ne_zero : ∀ d ∈ S, d ≠ 0 := fun d hd =&gt;
      (Nat.pos_of_dvd_of_pos (hS_sub d hd) hm).ne&#x27;
    exact lt_of_le_of_lt (Finset.lcm_factorization_le_sup S id q hS_ne_zero) hsup_lt
  rw [hS_lcm] at hfact_q
  omega</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Psi/Bounds.lean#L253-L293" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:prime-pow-achieved-of-lcm-eq');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:finset-nonempty-of-two-le-lcm">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">2.0.10</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0002.html#lem:finset-nonempty-of-two-le-lcm">#</a>
    
    <a class="icon proof" href="sect0002.html#a0000000023"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Finset.nonempty_of_two_le_lcm" class="lean_decl">Crystallographic.Finset.nonempty_of_two_le_lcm</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   If \(\mathrm{lcm}(S) \geq 2\) for a finite set \(S\) of natural numbers, then \(S\) is nonempty. </p>
<p>This follows immediately from the fact that \(\mathrm{lcm}(\emptyset ) = 1\) by convention.  - </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000023">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By contradiction: if \(S = \emptyset \), then \(\mathrm{lcm}(S) = 1 {\lt} 2\), contradicting the hypothesis. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma Finset.nonempty_of_two_le_lcm {S : Finset ℕ} (hS_lcm_ge2 : 2 ≤ S.lcm id) :
    S.Nonempty := by</span></code><code class="lean-proof-body"><span class="lean-plain">by_contra h
  rw [Finset.not_nonempty_iff_eq_empty] at h
  simp only [h, Finset.lcm_empty] at hS_lcm_ge2
  omega</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Psi/Bounds.lean#L418-L431" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:finset-nonempty-of-two-le-lcm');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:finset-exists-one-lt-of-two-le-lcm">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">2.0.11</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0002.html#lem:finset-exists-one-lt-of-two-le-lcm">#</a>
    
    <a class="icon proof" href="sect0002.html#a0000000024"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0002.html#lem:finset-nonempty-of-two-le-lcm">Theorem 2.0.10</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Finset.exists_one_lt_of_two_le_lcm" class="lean_decl">Crystallographic.Finset.exists_one_lt_of_two_le_lcm</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   If \(S\) is a finite set of positive integers with \(\mathrm{lcm}(S) \geq 2\), then some element \(d \in S\) satisfies \(d {\gt} 1\). </p>
<p>This is because \(\mathrm{lcm}\) of a set where all elements equal \(1\) would be \(1\).  - </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000024">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By contradiction: if all \(d \in S\) satisfy \(d \leq 1\), then since all \(d {\gt} 0\) we have \(d = 1\) for all \(d \in S\). Thus \(\mathrm{lcm}(S) = 1 {\lt} 2\), a contradiction. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma Finset.exists_one_lt_of_two_le_lcm {S : Finset ℕ} (hS_pos : ∀ d ∈ S, 0 &lt; d)
    (hS_lcm_ge2 : 2 ≤ S.lcm id) : ∃ d ∈ S, 1 &lt; d := by</span></code><code class="lean-proof-body"><span class="lean-plain">by_contra hall_le1
  push_neg at hall_le1
  have hall_eq1 : ∀ d ∈ S, d = 1 := fun d hd =&gt; by
    have hd_pos := hS_pos d hd
    have hd_le1 := hall_le1 d hd
    omega
  have hlcm_eq1 : S.lcm id = 1 := by
    apply Nat.eq_one_of_dvd_one
    apply Finset.lcm_dvd_iff.mpr
    intro d hd
    simp only [id_eq, hall_eq1 d hd, Nat.one_dvd]
  omega</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Psi/Bounds.lean#L433-L455" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:finset-exists-one-lt-of-two-le-lcm');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:sum-totient-ge-psi">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">2.0.12</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0002.html#lem:sum-totient-ge-psi">#</a>
    
    <a class="icon proof" href="sect0002.html#a0000000025"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0002.html#psi-def">Definition 2.0.2</a></li>
          
          <li><a href="sect0002.html#lem:psi-le-totient">Theorem 2.0.8</a></li>
          
          <li><a href="sect0002.html#lem:finset-nonempty-of-two-le-lcm">Theorem 2.0.10</a></li>
          
          <li><a href="sect0002.html#lem:finset-exists-one-lt-of-two-le-lcm">Theorem 2.0.11</a></li>
          
          <li><a href="sect0002.html#lem:prime-pow-achieved-of-lcm-eq">Theorem 2.0.9</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.sum_totient_ge_psi_of_lcm_eq" class="lean_decl">Crystallographic.sum_totient_ge_psi_of_lcm_eq</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   For any finite set \(S\) of divisors of \(m\) with \(\mathrm{lcm}(S) = m\), we have \(\psi (m) \leq \sum _{d \in S} \varphi (d)\). </p>
<p>For a finite set \(S\) of divisors of \(m\) with \(\mathrm{lcm}(S) = m\), we have \(\sum _{d \in S} \varphi (d) \geq \psi (m)\). This follows from the prime factorization structure: each prime power \(p^k \|  m\) must appear in some \(d \in S\), contributing at least \(\psi _{\mathrm{pp}}(p, k)\). This is the combinatorial heart of the forward direction. The minimum sum is achieved when \(S\) consists of one prime power for each distinct prime in \(m\)’s prime factorization, giving exactly \(\psi (m)\).  - </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000025">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>For each prime power \(p^k \|  m\), some \(d \in S\) must have \(p^k \mid d\) (since \(\mathrm{lcm}(S) = m\)). The element with maximal \(p\)-valuation contributes at least \(\varphi (p^k) \geq \psi _{\mathrm{pp}}(p, k)\). Summing over distinct prime powers and using non-negativity gives the bound. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma sum_totient_ge_psi_of_lcm_eq (m : ℕ) (hm : 0 &lt; m) (S : Finset ℕ)
    (hS_sub : ∀ d ∈ S, d ∣ m) (hS_lcm : S.lcm id = m) :
    psi m ≤ ∑ d ∈ S, Nat.totient d := by</span></code><code class="lean-proof-body"><span class="lean-plain">-- If m ∈ S, apply helper lemma directly
  by_cases hm_in_S : m ∈ S
  · exact totient_sum_ge_psi_of_mem hm S hS_sub hm_in_S
  -- If m ∉ S, we use strong induction on m
  · induction m using Nat.strong_induction_on generalizing S with
    | _ m IH =&gt;
    -- For m = 1: psi(1) = 0 ≤ any sum
    by_cases hm_eq1 : m = 1
    · simp only [hm_eq1, psi_one, Nat.zero_le]
    have hm_ge2 : 2 ≤ m := by omega
    have hS_lcm_ge2 : 2 ≤ S.lcm id := hS_lcm ▸ hm_ge2
    have hS_pos : ∀ d ∈ S, 0 &lt; d := fun d hd =&gt; Nat.pos_of_dvd_of_pos (hS_sub d hd) hm
    -- S is nonempty since lcm(S) &gt;= 2
    have _hS_ne : S.Nonempty := Finset.nonempty_of_two_le_lcm hS_lcm_ge2
    -- Some element of S is &gt; 1
    have _hS_has_gt1 : ∃ d ∈ S, 1 &lt; d := Finset.exists_one_lt_of_two_le_lcm hS_pos hS_lcm_ge2
    -- Check if m is a prime power
    by_cases hpow : IsPrimePow m
    · -- m is a prime power p^k: contradiction since p^k must be in S
      exfalso
      rw [isPrimePow_nat_iff] at hpow
      obtain ⟨p, k, hp, hk, hm_eq⟩ := hpow
      exact hm_in_S (hm_eq ▸ Finset.prime_pow_mem_of_lcm_eq hp hk S
        (fun d hd =&gt; hm_eq ▸ hS_sub d hd) (hm_eq ▸ hS_lcm))
    · -- m is not a prime power: use achiever function approach
      have h_achieves := primePow_achieved_of_lcm_eq hm S hS_sub hS_lcm
      have h_ach : ∀ q ∈ nontrivialPrimes m, ∃ d ∈ S, q ^ m.factorization q ∣ d := fun q hq =&gt;
        h_achieves q (Finset.mem_of_mem_filter q hq)
      -- Construct achiever function and prove its properties
      let achiever : ℕ → ℕ := fun q =&gt;
        if hq : q ∈ nontrivialPrimes m then (h_ach q hq).choose else 0
      have h_achiever_mem : ∀ q ∈ nontrivialPrimes m, achiever q ∈ S := fun q hq =&gt; by
        simp only [achiever, dif_pos hq]; exact (h_ach q hq).choose_spec.1
      have h_achiever_dvd : ∀ q ∈ nontrivialPrimes m, q ^ m.factorization q ∣ achiever q :=
        fun q hq =&gt; by simp only [achiever, dif_pos hq]; exact (h_ach q hq).choose_spec.2
      -- Apply the fiberwise bound
      calc psi m
          = ∑ q ∈ nontrivialPrimes m, Nat.totient (q ^ m.factorization q) :=
            psi_eq_sum_nontrivial_totients m
        _ ≤ ∑ d ∈ S, Nat.totient d :=
            sum_nontrivial_totients_le_sum_totients S hS_pos achiever h_achiever_mem h_achiever_dvd</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Psi/Bounds.lean#L457-L524" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:sum-totient-ge-psi');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>



</div> <!--main-text -->
</div> <!-- content-wrapper -->
</div> <!-- content -->
</div> <!-- wrapper -->

<nav class="prev_up_next">
  <svg  id="showmore-minus" class="icon icon-eye-minus showmore"><use xlink:href="symbol-defs.svg#icon-eye-minus"></use></svg>

  <svg  id="showmore-plus" class="icon icon-eye-plus showmore"><use xlink:href="symbol-defs.svg#icon-eye-plus"></use></svg>

  <a href="sect0001.html" title="Introduction"><svg  class="icon icon-arrow-left "><use xlink:href="symbol-defs.svg#icon-arrow-left"></use></svg>
</a>
  <a href="index.html" title="Crystallographic Restriction Theorem"><svg  class="icon icon-arrow-up "><use xlink:href="symbol-defs.svg#icon-arrow-up"></use></svg>
</a>
  <a href="sect0003.html" title="Integer Matrix Orders"><svg  class="icon icon-arrow-right "><use xlink:href="symbol-defs.svg#icon-arrow-right"></use></svg>
</a>
</nav>

<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/plastex.js"></script>
<script type="text/javascript" src="js/svgxuse.js"></script>
<script type="text/javascript" src="js/js.cookie.min.js"></script>
<script type="text/javascript" src="js/showmore.js"></script>
</body>
</html>