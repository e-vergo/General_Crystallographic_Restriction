<!DOCTYPE html>
<html lang="en">
<head>
<script>
  MathJax = { 
    tex: {
		    inlineMath: [['$','$'], ['\\(','\\)']]
	} }
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<meta name="generator" content="plasTeX" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Crystallographic Restriction Theorem</title>
<link rel="next" href="sect0006.html" title="Appendix" />
<link rel="prev" href="sect0004.html" title="Companion Matrices" />
<link rel="up" href="index.html" title="Crystallographic Restriction Theorem" />
<link rel="stylesheet" href="styles/theme-blue.css" />
<link rel="stylesheet" href="styles/showmore.css" />
<link rel="stylesheet" href="styles/blueprint.css" />
<link rel="stylesheet" href="styles/amsthm.css" />
<link rel="stylesheet" href="styles/style.css" />
</head>

<body>
<header>
<svg  id="toc-toggle" class="icon icon-list-numbered "><use xlink:href="symbol-defs.svg#icon-list-numbered"></use></svg>
<h1 id="doc_title"><a href="index.html">Crystallographic Restriction Theorem</a></h1>
</header>

<div class="wrapper">
<nav class="toc">
<ul class="sub-toc-0">
<li class="">
  <a href="sect0001.html"><span class="toc_ref">1</span> <span class="toc_entry">Introduction</span></a>
 </li>
<li class="">
  <a href="sect0002.html"><span class="toc_ref">2</span> <span class="toc_entry">The Psi Function</span></a>
 </li>
<li class="">
  <a href="sect0003.html"><span class="toc_ref">3</span> <span class="toc_entry">Integer Matrix Orders</span></a>
 </li>
<li class="">
  <a href="sect0004.html"><span class="toc_ref">4</span> <span class="toc_entry">Companion Matrices</span></a>
 </li>
<li class=" active current">
  <a href="sect0005.html"><span class="toc_ref">5</span> <span class="toc_entry">The Crystallographic Restriction Theorem</span></a>
 </li>
<li class="">
  <a href="sect0006.html"><span class="toc_ref">A</span> <span class="toc_entry">Appendix</span></a>
 </li>
<li ><a href="dep_graph_document.html">Dependency graph</a></li>
</ul>
</nav>

<div class="content">
<div class="content-wrapper">


<div class="main-text">
<h1 id="a0000000006">5 The Crystallographic Restriction Theorem</h1>
<p>The proof splits into two directions: showing \(\psi (m) \leq N\) is necessary (forward) and sufficient (backward) for \(m \in \mathrm{Ord}_N\). </p>
<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:pow-eq-one-of-minpoly-dvd">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.1</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:pow-eq-one-of-minpoly-dvd">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000044"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Matrix.pow_eq_one_of_minpoly_dvd_X_pow_sub_one" class="lean_decl">Matrix.pow_eq_one_of_minpoly_dvd_X_pow_sub_one</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   If \(\mu _A \mid X^k - 1\), then \(A^k = I\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000044">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>The polynomial \(X^k - 1\) annihilates \(A\) (since the minimal polynomial does), meaning \(A^k - I = 0\). Transfer this identity from \(\mathbb {Q}\) back to \(\mathbb {Z}\) via the injectivity of \(\mathbb {Z} \to \mathbb {Q}\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma pow_eq_one_of_minpoly_dvd_X_pow_sub_one {N : ℕ} (A : Matrix (Fin N) (Fin N) ℤ) (k : ℕ)
    (hdvd : minpoly ℚ (A.map (algebraMap ℤ ℚ)) ∣ X ^ k - 1) : A ^ k = 1 := by</span></code><code class="lean-proof-body"><span class="lean-plain">let A_Q := A.map (algebraMap ℤ ℚ)
  -- If minpoly | X^k - 1, then aeval A_Q (X^k - 1) = 0
  have haeval : aeval A_Q (X ^ k - 1 : ℚ[X]) = 0 := by
    obtain ⟨q, hq⟩ := hdvd
    rw [hq, map_mul, minpoly.aeval, zero_mul]
  -- This means A_Q^k = 1
  simp only [map_sub, map_pow, aeval_X, map_one, sub_eq_zero] at haeval
  -- Transfer back to A via injectivity
  have hinj := Crystallographic.Matrix.map_algebraMap_int_injective N
  apply hinj
  change (A ^ k).map (algebraMap ℤ ℚ) =
    (1 : Matrix (Fin N) (Fin N) ℤ).map (algebraMap ℤ ℚ)
  rw [Matrix.map_pow, Matrix.map_one (algebraMap ℤ ℚ) (map_zero _) (map_one _)]
  exact haeval</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Forward.lean#L48-L71" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:pow-eq-one-of-minpoly-dvd');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:minpoly-dvd-X-pow-sub-one">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.2</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:minpoly-dvd-X-pow-sub-one">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000045"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Matrix.minpoly_dvd_X_pow_sub_one_of_pow_eq_one" class="lean_decl">Matrix.minpoly_dvd_X_pow_sub_one_of_pow_eq_one</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   If \(A^m = I\), then \(\mu _A \mid X^m - 1\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000045">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>The polynomial \(X^m - 1\) annihilates \(A\) since \((A_{\mathbb {Q}})^m - I = 0\). The minimal polynomial divides any annihilating polynomial by definition. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma minpoly_dvd_X_pow_sub_one_of_pow_eq_one {N : ℕ} (A : Matrix (Fin N) (Fin N) ℤ) (m : ℕ)
    (hpow : A ^ m = 1) : minpoly ℚ (A.map (algebraMap ℤ ℚ)) ∣ X ^ m - 1 := by</span></code><code class="lean-proof-body"><span class="lean-plain">apply minpoly.dvd
  simp only [map_sub, map_pow, aeval_X, map_one]
  rw [← Matrix.map_pow, hpow,
    Matrix.map_one (algebraMap ℤ ℚ) (map_zero _) (map_one _), sub_self]</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Forward.lean#L73-L85" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:minpoly-dvd-X-pow-sub-one');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:cyclotomic-finset-product-dvd">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.3</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:cyclotomic-finset-product-dvd">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000046"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.cyclotomic_finset_product_dvd" class="lean_decl">Crystallographic.cyclotomic_finset_product_dvd</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   If \(\Phi _d \mid f\) for all \(d \in S\), then \(\prod _{d \in S} \Phi _d \mid f\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000046">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By induction on \(S\). The empty product divides everything. For the insert case, use that cyclotomic polynomials with distinct indices are coprime over \(\mathbb {Q}\), so \(\Phi _d\) is coprime to \(\prod _{x \in s} \Phi _x\) when \(d \notin s\). Then apply coprime divisibility: if \(a, b\) are coprime and both divide \(f\), then \(ab \mid f\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma cyclotomic_finset_product_dvd {target : ℚ[X]} (S : Finset ℕ)
    (hdvd_each : ∀ d ∈ S, cyclotomic d ℚ ∣ target) :
    (∏ d ∈ S, cyclotomic d ℚ) ∣ target := by</span></code><code class="lean-proof-body"><span class="lean-plain">induction S using Finset.induction with
  | empty =&gt; simp only [Finset.prod_empty, one_dvd]
  | @insert d s hd_notin IH =&gt;
    rw [Finset.prod_insert hd_notin]
    have hdvd_d : cyclotomic d ℚ ∣ target := hdvd_each d (Finset.mem_insert_self d s)
    have hdvd_prod : (∏ x ∈ s, cyclotomic x ℚ) ∣ target :=
        IH (fun x hx =&gt; hdvd_each x (Finset.mem_insert_of_mem hx))
    have hcop : IsCoprime (cyclotomic d ℚ) (∏ x ∈ s, cyclotomic x ℚ) := by
      apply IsCoprime.prod_right
      intro x hx
      exact cyclotomic.isCoprime_rat (fun heq =&gt; hd_notin (heq ▸ hx))
    exact hcop.mul_dvd hdvd_d hdvd_prod</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Forward.lean#L93-L115" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:cyclotomic-finset-product-dvd');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:minpoly-dvd-prod-cyclotomic">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.4</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:minpoly-dvd-prod-cyclotomic">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000047"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0005.html#lem:cyclotomic-finset-product-dvd">Theorem 5.0.3</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.minpoly_dvd_prod_cyclotomic_of_dvd_X_pow_sub_one" class="lean_decl">Crystallographic.minpoly_dvd_prod_cyclotomic_of_dvd_X_pow_sub_one</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   If \(\mu _A \mid X^m - 1\) and \(S = \{ d \mid m : \Phi _d \mid \mu _A\} \), then \(\mu _A \mid \prod _{d \in S} \Phi _d\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000047">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>Split \(X^m - 1 = (\prod _{d \in S} \Phi _d) \cdot (\prod _{d \notin S} \Phi _d)\). Since \(\Phi _d\) is irreducible and does not divide \(\mu _A\) for \(d \notin S\), we have \(\gcd (\mu _A, \Phi _d) = 1\). Thus \(\mu _A\) is coprime to \(\prod _{d \notin S} \Phi _d\). Since \(\mu _A \mid X^m - 1\), it must divide \(\prod _{d \in S} \Phi _d\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma minpoly_dvd_prod_cyclotomic_of_dvd_X_pow_sub_one {N : ℕ} [NeZero N]
    (A : Matrix (Fin N) (Fin N) ℤ) (m : ℕ) (hm : 0 &lt; m) (S : Finset ℕ) (hS_sub : S ⊆ m.divisors)
    (hS_def : ∀ d ∈ m.divisors, d ∈ S ↔ cyclotomic d ℚ ∣ minpoly ℚ (A.map (algebraMap ℤ ℚ)))
    (hminpoly_dvd : minpoly ℚ (A.map (algebraMap ℤ ℚ)) ∣ X ^ m - 1) :
    minpoly ℚ (A.map (algebraMap ℤ ℚ)) ∣ ∏ d ∈ S, cyclotomic d ℚ := by</span></code><code class="lean-proof-body"><span class="lean-plain">let A_Q := A.map (algebraMap ℤ ℚ)
  -- Key: {x ∈ m.divisors | x ∈ S} = S since S ⊆ m.divisors
  have hS_eq : m.divisors.filter (· ∈ S) = S := by
    ext d
    simp only [Finset.mem_filter]
    exact ⟨fun ⟨_, hd⟩ =&gt; hd, fun hd =&gt; ⟨hS_sub hd, hd⟩⟩
  -- minpoly is coprime to the product of cyclotomics NOT in S
  have hcoprime_with_complement : IsCoprime (minpoly ℚ A_Q)
      (∏ d ∈ m.divisors.filter (· ∉ S), cyclotomic d ℚ) :=
    IsCoprime.prod_right fun d hd =&gt; by
      have hd_div := (Finset.mem_filter.mp hd).1
      have hd_not_in_S := (Finset.mem_filter.mp hd).2
      have hndvd : ¬cyclotomic d ℚ ∣ minpoly ℚ A_Q := fun hdvd =&gt;
        hd_not_in_S ((hS_def d hd_div).mpr hdvd)
      exact (cyclotomic_coprime_minpoly_of_not_mem A d (Nat.pos_of_mem_divisors hd_div) hndvd).symm
  -- Split X^m - 1 = (∏_{d∈S} Φ_d) * (∏_{d∉S} Φ_d)
  have hprod_split : ∏ d ∈ m.divisors, cyclotomic d ℚ =
      (∏ d ∈ S, cyclotomic d ℚ) * (∏ d ∈ m.divisors.filter (· ∉ S), cyclotomic d ℚ) := by
    rw [← Finset.prod_filter_mul_prod_filter_not m.divisors (· ∈ S), hS_eq]
  rw [← prod_cyclotomic_eq_X_pow_sub_one hm, hprod_split] at hminpoly_dvd
  exact hcoprime_with_complement.dvd_of_dvd_mul_right hminpoly_dvd</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Forward.lean#L125-L165" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:minpoly-dvd-prod-cyclotomic');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:minpoly-eq-prod-cyclotomic">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.5</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:minpoly-eq-prod-cyclotomic">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000048"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0005.html#lem:minpoly-dvd-prod-cyclotomic">Theorem 5.0.4</a></li>
          
          <li><a href="sect0005.html#lem:cyclotomic-finset-product-dvd">Theorem 5.0.3</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.minpoly_eq_prod_cyclotomic_of_dvd_X_pow_sub_one" class="lean_decl">Crystallographic.minpoly_eq_prod_cyclotomic_of_dvd_X_pow_sub_one</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   If \(\mu _A \mid X^m - 1\), then there exists \(S \subseteq \mathrm{divisors}(m)\) such that \(\mu _A = \prod _{d \in S} \Phi _d\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000048">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>Let \(S = \{ d \mid m : \Phi _d \mid \mu _A\} \). By the previous lemma, \(\mu _A \mid \prod _{d \in S} \Phi _d\). Conversely, by definition of \(S\), each \(\Phi _d\) for \(d \in S\) divides \(\mu _A\), so their coprime product divides \(\mu _A\). Mutual divisibility of monic polynomials implies equality. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma minpoly_eq_prod_cyclotomic_of_dvd_X_pow_sub_one {N : ℕ} [NeZero N]
    (A : Matrix (Fin N) (Fin N) ℤ) (m : ℕ) (hm : 0 &lt; m)
    (hminpoly_dvd : minpoly ℚ (A.map (algebraMap ℤ ℚ)) ∣ X ^ m - 1) :
    ∃ S : Finset ℕ, (∀ d ∈ S, d ∣ m) ∧
      minpoly ℚ (A.map (algebraMap ℤ ℚ)) = ∏ d ∈ S, cyclotomic d ℚ := by</span></code><code class="lean-proof-body"><span class="lean-plain">classical
  let A_Q := A.map (algebraMap ℤ ℚ)
  let S := m.divisors.filter (fun d =&gt; cyclotomic d ℚ ∣ minpoly ℚ A_Q)
  have hS_sub : S ⊆ m.divisors := Finset.filter_subset _ _
  have hS_dvd : ∀ d ∈ S, d ∣ m := fun d hd =&gt;
    (Nat.mem_divisors.mp (Finset.mem_filter.mp hd).1).1
  have hS_def : ∀ d ∈ m.divisors, d ∈ S ↔ cyclotomic d ℚ ∣ minpoly ℚ A_Q := fun d hd =&gt;
    ⟨fun hS =&gt; (Finset.mem_filter.mp hS).2, fun hdvd =&gt; Finset.mem_filter.mpr ⟨hd, hdvd⟩⟩
  -- minpoly ∣ ∏_{d∈S} Φ_d (by coprimality argument)
  have hminpoly_dvd_prod : minpoly ℚ A_Q ∣ ∏ d ∈ S, cyclotomic d ℚ :=
    minpoly_dvd_prod_cyclotomic_of_dvd_X_pow_sub_one A m hm S hS_sub hS_def hminpoly_dvd
  -- ∏_{d∈S} Φ_d ∣ minpoly (by definition of S)
  have hprod_dvd_minpoly : (∏ d ∈ S, cyclotomic d ℚ) ∣ minpoly ℚ A_Q :=
    cyclotomic_finset_product_dvd S (fun d hd =&gt; (Finset.mem_filter.mp hd).2)
  -- Equality by mutual divisibility of monic polynomials
  exact ⟨S, hS_dvd, Polynomial.eq_of_monic_of_associated
    (minpoly.monic (Matrix.isIntegral A_Q))
    (Polynomial.monic_prod_of_monic _ _ (fun d _ =&gt; cyclotomic.monic d ℚ))
    (associated_of_dvd_dvd hminpoly_dvd_prod hprod_dvd_minpoly)⟩</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Forward.lean#L167-L201" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:minpoly-eq-prod-cyclotomic');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:cyclotomic-divisors-lcm-eq">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.6</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:cyclotomic-divisors-lcm-eq">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000049"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0005.html#lem:minpoly-eq-prod-cyclotomic">Theorem 5.0.5</a></li>
          
          <li><a href="sect0005.html#lem:pow-eq-one-of-minpoly-dvd">Theorem 5.0.1</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.cyclotomic_divisors_lcm_eq_of_orderOf" class="lean_decl">Crystallographic.cyclotomic_divisors_lcm_eq_of_orderOf</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   If \(\mathrm{ord}(A) = m\) and \(\mu _A = \prod _{d \in S} \Phi _d\) with \(S \subseteq \mathrm{divisors}(m)\), then \(\mathrm{lcm}(S) = m\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000049">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>Suppose \(\ell = \mathrm{lcm}(S) {\lt} m\). Then \(\mu _A = \prod _{d \in S} \Phi _d\) divides \(\prod _{d \mid \ell } \Phi _d = X^\ell - 1\), since each \(d \in S\) divides \(\ell \). By the transfer lemma, \(A^\ell = I\). But this contradicts \(\mathrm{ord}(A) = m {\gt} \ell \). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma cyclotomic_divisors_lcm_eq_of_orderOf {N : ℕ} [NeZero N]
    (A : Matrix (Fin N) (Fin N) ℤ) (m : ℕ) (hm : 0 &lt; m) (hA_ord : orderOf A = m)
    (S : Finset ℕ) (hS_sub : ∀ d ∈ S, d ∣ m)
    (hminpoly_eq_prod : minpoly ℚ (A.map (algebraMap ℤ ℚ)) = ∏ d ∈ S, cyclotomic d ℚ) :
    S.lcm id = m := by</span></code><code class="lean-proof-body"><span class="lean-plain">let A_Q := A.map (algebraMap ℤ ℚ)
  -- If lcm(S) &lt; m, then minpoly | X^{lcm(S)} - 1, so A^{lcm(S)} = 1
  -- This contradicts orderOf A = m
  by_contra hne
  have hlcm_dvd_m : S.lcm id ∣ m := Finset.lcm_dvd (fun d hd =&gt; hS_sub d hd)
  have hlcm_le : S.lcm id ≤ m := Nat.le_of_dvd hm hlcm_dvd_m
  have hlcm_lt : S.lcm id &lt; m := Nat.lt_of_le_of_ne hlcm_le hne
  -- minpoly | ∏_{d|lcm(S)} Φ_d = X^{lcm(S)} - 1
  have hlcm_pos : 0 &lt; S.lcm id := by
    by_cases hS_empty : S = ∅
    · -- If S = ∅, then minpoly = 1 (empty product), contradiction since
      -- minpoly has positive degree
      simp only [hS_empty, Finset.prod_empty] at hminpoly_eq_prod
      have hdeg := minpoly.natDegree_pos (Matrix.isIntegral A_Q)
      rw [hminpoly_eq_prod, natDegree_one] at hdeg
      omega
    · have hne_zero : S.lcm id ≠ 0 := Finset.lcm_ne_zero_iff.mpr fun d hd =&gt;
        (Nat.pos_of_mem_divisors (Nat.mem_divisors.mpr ⟨hS_sub d hd, hm.ne&#x27;⟩)).ne&#x27;
      exact Nat.pos_of_ne_zero hne_zero
  -- Helper: X^d - 1 | X^n - 1 when d | n
  have X_pow_sub_one_dvd : ∀ (d n : ℕ), d ∣ n → (X ^ d - 1 : ℚ[X]) ∣ X ^ n - 1 := by
    intro d n hdvd
    obtain ⟨k, hk⟩ := hdvd
    rw [hk]
    exact pow_one_sub_dvd_pow_mul_sub_one X d k
  have hminpoly_dvd_lcm : minpoly ℚ A_Q ∣ X ^ (S.lcm id) - 1 := by
    rw [hminpoly_eq_prod]
    apply cyclotomic_finset_product_dvd
    intro d hd
    have hd_dvd_lcm : d ∣ S.lcm id := Finset.dvd_lcm hd
    calc cyclotomic d ℚ ∣ X ^ d - 1 := cyclotomic.dvd_X_pow_sub_one d ℚ
      _ ∣ X ^ (S.lcm id) - 1 := X_pow_sub_one_dvd d (S.lcm id) hd_dvd_lcm
  -- Therefore A^{lcm(S)} = 1
  have hpow_lcm : A ^ (S.lcm id) = 1 :=
    Matrix.pow_eq_one_of_minpoly_dvd_X_pow_sub_one A (S.lcm id) hminpoly_dvd_lcm
  -- But orderOf A = m &gt; lcm(S), so orderOf A | lcm(S) is false
  have hord_dvd := orderOf_dvd_of_pow_eq_one hpow_lcm
  rw [hA_ord] at hord_dvd
  have := Nat.le_of_dvd hlcm_pos hord_dvd
  omega</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Forward.lean#L203-L257" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:cyclotomic-divisors-lcm-eq');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:forward-direction">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.7</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#thm:forward-direction">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000050"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0003.html#integerMatrixOrders-def">Definition 3.0.1</a></li>
          
          <li><a href="sect0002.html#psi-def">Definition 2.0.2</a></li>
          
          <li><a href="sect0002.html#lem:sum-totient-ge-psi">Theorem 2.0.12</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.psi_le_of_mem_integerMatrixOrders" class="lean_decl">Crystallographic.psi_le_of_mem_integerMatrixOrders</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>      <b class="bfseries">Forward Direction:</b> If \(m \in \mathrm{Ord}_N\), then \(\psi (m) \leq N\). </p>
<p><b class="bfseries">Mathematical context:</b> The key insight is that integer matrices with finite order have constrained eigenvalues: if \(A^m = I\), all eigenvalues are \(m\)-th roots of unity. The minimal polynomial over \(\mathbb {Q}\) factors into cyclotomic polynomials \(\Phi _d\) for various divisors \(d\) of \(m\). The requirement that \(\mathrm{ord}(A) = m\) (not some proper divisor) forces the set of cyclotomic factors to have \(\mathrm{lcm} = m\), which constrains the total degree. </p>
<p><b class="bfseries">Proof outline:</b> </p>
<ol class="enumerate">
  <li><p>Let \(A\) be an \(N \times N\) integer matrix with \(\mathrm{ord}(A) = m\). </p>
</li>
  <li><p>The minimal polynomial of \(A\) over \(\mathbb {Q}\) divides \(X^m - 1 = \prod _{d \mid m} \Phi _d\). </p>
</li>
  <li><p>Since \(\Phi _d\) are irreducible and pairwise coprime over \(\mathbb {Q}\), the minimal polynomial equals \(\prod _{d \in S} \Phi _d\) for some \(S \subseteq \mathrm{divisors}(m)\). </p>
</li>
  <li><p>The condition \(\mathrm{ord}(A) = m\) forces \(\mathrm{lcm}(S) = m\): if \(\mathrm{lcm}(S) {\lt} m\), then \(A^{\mathrm{lcm}(S)} = I\), contradicting \(\mathrm{ord}(A) = m\). </p>
</li>
  <li><p>The degree of the minimal polynomial is \(\sum _{d \in S} \varphi (d)\). </p>
</li>
  <li><p>By the sum-totient lemma (applied to any \(S\) with \(\mathrm{lcm}(S) = m\)), \(\psi (m) \leq \sum _{d \in S} \varphi (d) = \deg (\mathrm{minpoly}) \leq \deg (\mathrm{charpoly}) = N\). </p>
</li>
</ol>


    </div>
    <div class="proof_wrapper proof_inline" id="a0000000050">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>Let \(A\) be an \(N \times N\) integer matrix with \(A^m = I\). The minimal polynomial \(\mu _A\) over \(\mathbb {Q}\) divides \(X^m - 1\) and factors into cyclotomic polynomials \(\Phi _d\) for various \(d \mid m\). Each factor contributes \(\varphi (d)\) to \(\deg (\mu _A) \leq N\). Since distinct \(\Phi _d\) are coprime and their lcm must be \(m\), summing the totients of appearing divisors gives \(\psi (m) \leq N\). - </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>ℕ</code>","1":"<code>0 &lt; m</code>","2":"<code>m ∈ integerMatrixOrders N</code>","3":"<code>Crystallographic.integerMatrixOrders (N : ℕ) : Set ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The set of possible orders for N×N integer matrices with finite order.\nAn integer `m` is in this set if there exists an N×N integer matrix `A` such that\n`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). </code>","4":"<code>Crystallographic.psi (m : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The psi function for crystallographic restriction.\npsi(m) is the minimum dimension N such that an N×N integer matrix can have order m.\n\nDefined as the sum over prime power factors: if m = prod p_i^{k_i}, then\npsi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) </code>","5":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-16725">theorem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">psi_le_of_mem_integerMatrixOrders</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10918" data-verso-hover="0">N</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10920" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10966" data-verso-hover="1">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10920" data-verso-hover="0">m</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11047" data-verso-hover="2">hord</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10920" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.integerMatrixOrders" data-verso-hover="3">integerMatrixOrders</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10918" data-verso-hover="0">N</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.psi" data-verso-hover="4">Crystallographic.psi</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10920" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10918" data-verso-hover="0">N</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-16867" data-verso-hover="5">by</span></code><code class="lean-proof-body"><span class="inter-text">
  -- Extract the matrix A with orderOf A = m
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.obtain-16917" data-verso-hover="0">obtain</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">A</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_ord</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hord</span><span class="inter-text">
  -- Handle the case N = 0 separately
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-16991" data-verso-hover="1">rcases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.eq_zero_or_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-17019">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">rfl</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hN_pos</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- N = 0: The only 0×0 matrix is empty, with order 1
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHaveI__-17100" data-verso-hover="2">haveI</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">IsEmpty</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Fin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Fin.isEmpty</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-17143" data-verso-hover="3">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_eq_1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Matrix.ext</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-17178">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">i</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Fin.elim0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">i</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-17203" data-verso-hover="4">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hA_eq_1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">orderOf_one</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-17229" data-verso-hover="5">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_ord</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.subst-17243" data-verso-hover="6">subst</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_ord</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-17260" data-verso-hover="7">simp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">Crystallographic.psi_one</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- N &gt; 0: Use psi ≤ deg(minpoly) ≤ deg(charpoly) = N
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHaveI__-17358" data-verso-hover="2">haveI</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">NeZero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">Nat.pos_iff_ne_zero.mp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hN_pos</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet__-17418" data-verso-hover="8">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A_Q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A.map</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">algebraMap</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℤ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    -- The minimal polynomial degree is at most N
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-17510" data-verso-hover="3">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminpoly_deg_le</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">minpoly</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A_Q</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">natDegree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-17570" data-verso-hover="9">by</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-17579" data-verso-hover="3">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Matrix.minpoly_dvd_charpoly</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A_Q</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-17630" data-verso-hover="3">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hne</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A_Q.charpoly</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Matrix.charpoly_monic</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A_Q</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">ne_zero</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.calcTactic-17705" data-verso-hover="10">calc</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">minpoly</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A_Q</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">natDegree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A_Q.charpoly.natDegree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
          </span><span class="unknown token" data-binding="">Polynomial.natDegree_le_of_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hne</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Fintype.card</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Fin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Matrix.charpoly_natDegree_eq_dim</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A_Q</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Fintype.card_fin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text">
    -- minpoly | X^m - 1 since A^m = 1
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-17970" data-verso-hover="3">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpow</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-17995" data-verso-hover="9">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-17998" data-verso-hover="4">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_ord</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-18015" data-verso-hover="11">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pow_orderOf_eq_one</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-18046" data-verso-hover="3">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminpoly_dvd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">minpoly</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A_Q</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∣</span><span class="inter-text"> </span><span class="unknown token" data-binding="">X</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">Matrix.minpoly_dvd_X_pow_sub_one_of_pow_eq_one</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpow</span><span class="inter-text">
    -- Get S and the product decomposition from helper lemma
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.obtain-18226" data-verso-hover="0">obtain</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">S</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hS_sub</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminpoly_eq_prod</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">minpoly_eq_prod_cyclotomic_of_dvd_X_pow_sub_one</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminpoly_dvd</span><span class="inter-text">
    -- The lcm of S equals m (otherwise order would be smaller)
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-18412" data-verso-hover="3">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hS_lcm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">S.lcm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">id</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">cyclotomic_divisors_lcm_eq_of_orderOf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hA_ord</span><span class="inter-text"> </span><span class="unknown token" data-binding="">S</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hS_sub</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminpoly_eq_prod</span><span class="inter-text">
    -- Compute the degree as sum of totients
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-18575" data-verso-hover="3">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdeg_eq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">minpoly</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A_Q</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">natDegree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∑</span><span class="inter-text"> </span><span class="unknown token" data-binding="">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="unknown token" data-binding="">S</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.totient</span><span class="inter-text"> </span><span class="unknown token" data-binding="">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-18650" data-verso-hover="9">by</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-18659" data-verso-hover="4">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hminpoly_eq_prod</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Polynomial.natDegree_prod</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-18712">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">cyclotomic_ne_zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-18756" data-verso-hover="11">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Finset.sum_congr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">rfl</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-18784">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">natDegree_cyclotomic</span><span class="inter-text"> </span><span class="unknown token" data-binding="">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    -- Apply sum_totient_ge_psi_of_lcm_eq
    </span><span class="keyword token" data-binding="kw-occ-Lean.calcTactic-18869" data-verso-hover="10">calc</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Crystallographic.psi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∑</span><span class="inter-text"> </span><span class="unknown token" data-binding="">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="unknown token" data-binding="">S</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.totient</span><span class="inter-text"> </span><span class="unknown token" data-binding="">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">sum_totient_ge_psi_of_lcm_eq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">S</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hS_sub</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hS_lcm</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">minpoly</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℚ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">A_Q</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">natDegree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hdeg_eq.symm</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hminpoly_deg_le</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Forward.lean#L259-L346" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:forward-direction');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:permMatrix-one">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.8</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:permMatrix-one">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000051"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Equiv.Perm.permMatrix_one" class="lean_decl">Crystallographic.Equiv.Perm.permMatrix_one</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   The permutation matrix of the identity is the identity matrix: \(P_{\mathrm{id}} = I\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000051">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>Direct computation using \(\mathrm{toPEquiv}(\mathrm{id}) = \mathrm{refl}\) and \(\mathrm{toMatrix}(\mathrm{refl}) = I\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma permMatrix_one {n : Type*} [DecidableEq n] {R : Type*} [Zero R] [One R] :
    (1 : Equiv.Perm n).permMatrix R = (1 : Matrix n n R) := by</span></code><code class="lean-proof-body"><span class="lean-plain">simp only [Equiv.Perm.permMatrix, Equiv.Perm.one_def, Equiv.toPEquiv_refl, PEquiv.toMatrix_refl]</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L67-L74" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:permMatrix-one');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:permMatrix-mul">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.9</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:permMatrix-mul">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000052"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Equiv.Perm.permMatrix_mul" class="lean_decl">Crystallographic.Equiv.Perm.permMatrix_mul</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   Permutation matrices satisfy \(P_{\sigma \cdot \tau } = P_\tau \cdot P_\sigma \) (contravariant homomorphism). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000052">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>Follows from \(\mathrm{toPEquiv}(\sigma \circ \tau ) = \mathrm{toPEquiv}(\tau ) \cdot \mathrm{toPEquiv}(\sigma )\) and the corresponding property for partial equivalence matrices. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma permMatrix_mul {n : Type*} [DecidableEq n] [Fintype n] {R : Type*} [Semiring R]
    (σ τ : Equiv.Perm n) :
    (σ * τ).permMatrix R = τ.permMatrix R * σ.permMatrix R := by</span></code><code class="lean-proof-body"><span class="lean-plain">simp only [Equiv.Perm.permMatrix]
  rw [Equiv.Perm.mul_def, Equiv.toPEquiv_trans, PEquiv.toMatrix_trans]</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L76-L86" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:permMatrix-mul');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:permMatrix-pow">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.10</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:permMatrix-pow">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000053"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0005.html#lem:permMatrix-one">Theorem 5.0.8</a></li>
          
          <li><a href="sect0005.html#lem:permMatrix-mul">Theorem 5.0.9</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Equiv.Perm.permMatrix_pow" class="lean_decl">Crystallographic.Equiv.Perm.permMatrix_pow</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   Powers of permutation matrices satisfy \(P_{\sigma ^k} = P_\sigma ^k\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000053">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By induction on \(k\): the base case uses \(P_{\mathrm{id}} = I\), and the inductive step uses \(P_{\sigma \cdot \tau } = P_\tau \cdot P_\sigma \) together with commutativity of powers. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma permMatrix_pow {n : Type*} [DecidableEq n] [Fintype n] {R : Type*} [Semiring R]
    (σ : Equiv.Perm n) (k : ℕ) :
    (σ ^ k).permMatrix R = (σ.permMatrix R) ^ k := by</span></code><code class="lean-proof-body"><span class="lean-plain">induction k with
  | zero =&gt; simp [permMatrix_one]
  | succ k ih =&gt;
    rw [pow_succ, pow_succ, permMatrix_mul, ih]
    -- Goal: σ.permMatrix * (σ.permMatrix)^k = (σ.permMatrix)^k * σ.permMatrix
    -- Use SemiconjBy or direct equality - both sides are equal
    exact (Commute.pow_self (σ.permMatrix R) k).eq.symm</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L88-L103" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:permMatrix-pow');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:permMatrix-eq-one-iff">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.11</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:permMatrix-eq-one-iff">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000054"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0005.html#lem:permMatrix-one">Theorem 5.0.8</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Equiv.Perm.permMatrix_eq_one_iff" class="lean_decl">Crystallographic.Equiv.Perm.permMatrix_eq_one_iff</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   \(P_\sigma = I\) if and only if \(\sigma = \mathrm{id}\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000054">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>The forward direction shows that if \(P_\sigma = I\) then for each \(x\), the entry \((P_\sigma )_{x, \sigma (x)} = 1\) forces \(\sigma (x) = x\). The reverse is immediate from \(P_{\mathrm{id}} = I\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma permMatrix_eq_one_iff {n : Type*} [DecidableEq n] [Fintype n] {R : Type*} [Semiring R]
    [Nontrivial R] (σ : Equiv.Perm n) :
    σ.permMatrix R = 1 ↔ σ = 1 := by</span></code><code class="lean-proof-body"><span class="lean-plain">constructor
  · intro h
    ext x
    have hx := congrFun (congrFun h x) (σ x)
    simp only [Equiv.Perm.permMatrix, Equiv.toPEquiv_apply, PEquiv.toMatrix_apply, Matrix.one_apply,
      Option.mem_def] at hx
    by_cases hσx : σ x = x
    · exact hσx
    · exfalso
      -- hx says: if σ (σ x) = σ x then 1 else 0 = if x = σ x then 1 else 0
      -- After simp, lhs simplifies using σ (σ x) = σ x ↔ σ x = x (by injectivity)
      -- which is true since Option.mem_def
      -- rhs: x = σ x is false by hσx
      have h1 : (1 : R) = if x = σ x then 1 else 0 := hx
      rw [if_neg (ne_comm.mpr hσx)] at h1
      exact one_ne_zero h1
  · intro h; rw [h]; exact permMatrix_one</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L105-L131" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:permMatrix-eq-one-iff');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:orderOf-permMatrix">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.12</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:orderOf-permMatrix">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000055"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Equiv.Perm.orderOf_permMatrix" class="lean_decl">Crystallographic.Equiv.Perm.orderOf_permMatrix</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   The order of \(P_\sigma \) equals the order of \(\sigma \) for a permutation matrix. </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000055">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>Since \(P_{\sigma ^k} = P_\sigma ^k\) and \(P_\sigma = I \iff \sigma = \mathrm{id}\), the order of \(P_\sigma \) equals the order of \(\sigma \). The key is that the permutation matrix map preserves powers and is injective on the group of permutation matrices. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma orderOf_permMatrix {n : Type*} [DecidableEq n] [Fintype n] {R : Type*} [Semiring R]
    [Nontrivial R] (σ : Equiv.Perm n) :
    orderOf (σ.permMatrix R) = orderOf σ := by</span></code><code class="lean-proof-body"><span class="lean-plain">rcases Nat.eq_zero_or_pos (orderOf σ) with hord | hord
  · -- σ has infinite order (orderOf σ = 0)
    rw [hord, orderOf_eq_zero_iff&#x27;]
    intro k hk heq
    have h1 : (σ ^ k).permMatrix R = 1 := by rw [permMatrix_pow]; exact heq
    rw [permMatrix_eq_one_iff] at h1
    exact (orderOf_eq_zero_iff&#x27;.mp hord) k hk h1
  · -- σ has finite order
    rw [orderOf_eq_iff hord]
    constructor
    · rw [← permMatrix_pow, pow_orderOf_eq_one]; exact permMatrix_one
    · intro k hk_lt hk_pos heq
      have hk&#x27; : (σ ^ k).permMatrix R = 1 := by rw [permMatrix_pow]; exact heq
      rw [permMatrix_eq_one_iff] at hk&#x27;
      have hdvd : orderOf σ ∣ k := orderOf_dvd_of_pow_eq_one hk&#x27;
      exact Nat.not_lt.mpr (Nat.le_of_dvd hk_pos hdvd) hk_lt</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L133-L157" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:orderOf-permMatrix');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:orderOf-finRotate">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.13</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:orderOf-finRotate">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000056"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Equiv.Perm.orderOf_finRotate" class="lean_decl">Crystallographic.Equiv.Perm.orderOf_finRotate</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   The order of \(\mathrm{finRotate}(n)\) equals \(n\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000056">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>The \(\mathrm{finRotate}(n)\) permutation is an \(n\)-cycle with full support \(\mathrm{Fin}\  n\). By the cycle order theorem, the order of a cycle equals its length, which is \(n\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma orderOf_finRotate (n : ℕ) (hn : 2 ≤ n) : orderOf (finRotate n) = n := by</span></code><code class="lean-proof-body"><span class="lean-plain">have hcycle := isCycle_finRotate_of_le hn
  have hord := Equiv.Perm.IsCycle.orderOf hcycle
  have hsupp := support_finRotate_of_le hn
  rw [hord, hsupp, Finset.card_univ, Fintype.card_fin]</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L159-L168" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:orderOf-finRotate');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:orderOf-permMatrix-finRotate">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.14</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:orderOf-permMatrix-finRotate">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000057"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0005.html#lem:orderOf-permMatrix">Theorem 5.0.12</a></li>
          
          <li><a href="sect0005.html#lem:orderOf-finRotate">Theorem 5.0.13</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Equiv.Perm.orderOf_permMatrix_finRotate" class="lean_decl">Crystallographic.Equiv.Perm.orderOf_permMatrix_finRotate</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   The permutation matrix of \(\mathrm{finRotate}(n)\) has order \(n\) over \(\mathbb {Z}\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000057">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>Combines the order-preservation property \(\mathrm{ord}(P_\sigma ) = \mathrm{ord}(\sigma )\) with \(\mathrm{ord}(\mathrm{finRotate}(n)) = n\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma orderOf_permMatrix_finRotate (n : ℕ) (hn : 2 ≤ n) :
    orderOf ((finRotate n).permMatrix ℤ) = n := by</span></code><code class="lean-proof-body"><span class="lean-plain">rw [orderOf_permMatrix, orderOf_finRotate n hn]</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L170-L178" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:orderOf-permMatrix-finRotate');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:mem-integerMatrixOrders-self">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.15</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:mem-integerMatrixOrders-self">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000058"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.mem_integerMatrixOrders_self" class="lean_decl">Crystallographic.mem_integerMatrixOrders_self</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>   \(m \in \mathrm{Ord}_m\) for \(m \geq 2\) via permutation matrix. </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000058">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>The permutation matrix \(P_{\mathrm{finRotate}(m)}\) is an \(m \times m\) integer matrix with order exactly \(m\), since \(\mathrm{finRotate}(m)\) has order \(m\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-plain">lemma mem_integerMatrixOrders_self (n : ℕ) (hn : 2 ≤ n) : n ∈ integerMatrixOrders n := by</span></code><code class="lean-proof-body"><span class="lean-plain">use (finRotate n).permMatrix ℤ
  constructor
  · exact Equiv.Perm.orderOf_permMatrix_finRotate n hn
  · omega</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L182-L191" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:mem-integerMatrixOrders-self');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:primePow-mem-integerMatrixOrders-psi">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.16</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#thm:primePow-mem-integerMatrixOrders-psi">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000059"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.primePow_mem_integerMatrixOrders_psi" class="lean_decl">Crystallographic.primePow_mem_integerMatrixOrders_psi</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>      For a prime power \(p^k\) with \(p\) odd or \(k \geq 2\), we have \(p^k \in \mathrm{Ord}_{\psi (p^k)}\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000059">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>For these prime powers, \(\psi (p^k) = \varphi (p^k)\). The companion matrix of \(\Phi _{p^k}\) has dimension \(\varphi (p^k)\) and order exactly \(p^k\), so \(p^k \in \mathrm{Ord}_{\varphi (p^k)} = \mathrm{Ord}_{\psi (p^k)}\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>ℕ</code>","1":"<code>Nat.Prime p</code>","2":"<code>Nat.Prime (p : ℕ) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. </code>","3":"<code>0 &lt; k</code>","4":"<code>¬(p = 2 ∧ k = 1)</code>","5":"<code>Crystallographic.integerMatrixOrders (N : ℕ) : Set ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The set of possible orders for N×N integer matrices with finite order.\nAn integer `m` is in this set if there exists an N×N integer matrix `A` such that\n`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). </code>","6":"<code>Crystallographic.psi (m : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The psi function for crystallographic restriction.\npsi(m) is the minimum dimension N such that an N×N integer matrix can have order m.\n\nDefined as the sum over prime power factors: if m = prod p_i^{k_i}, then\npsi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) </code>","7":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-9407">theorem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">primePow_mem_integerMatrixOrders_psi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4448" data-verso-hover="0">p</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4450" data-verso-hover="0">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4453" data-verso-hover="1">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4448" data-verso-hover="0">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.Prime" data-verso-hover="2">Prime</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4499" data-verso-hover="3">hk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4450" data-verso-hover="0">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4560" data-verso-hover="4">hpk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4448" data-verso-hover="0">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4450" data-verso-hover="0">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.4448" data-verso-hover="0">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4450" data-verso-hover="0">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.integerMatrixOrders" data-verso-hover="5">integerMatrixOrders</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Crystallographic.psi" data-verso-hover="6">psi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4448" data-verso-hover="0">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4450" data-verso-hover="0">k</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-9577" data-verso-hover="7">by</span></code><code class="lean-proof-body"><span class="inter-text">
  -- psi(p^k) = totient(p^k) for this case
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-9625" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpsi_eq</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">psi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.totient</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-9677" data-verso-hover="1">by</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-9684" data-verso-hover="2">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">psi_prime_pow</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hk</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-9717" data-verso-hover="3">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-9722">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hpk</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ite_false</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-9746" data-verso-hover="2">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">hpsi_eq</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  -- Use companion matrix lemma
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-9793" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpk_ge2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-9823" data-verso-hover="1">by</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-9830" data-verso-hover="0">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp_ge2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp.two_le</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.calcTactic-9869" data-verso-hover="4">calc</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≥</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.pow_le_pow_right</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.le_of_lt</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp.one_lt</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hk</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pow_one</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≥</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp_ge2</span><span class="inter-text">
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-9993" data-verso-hover="5">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">mem_integerMatrixOrders_totient</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpk_ge2</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L195-L215" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:primePow-mem-integerMatrixOrders-psi');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:mem-integerMatrixOrders-psi">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.17</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#thm:mem-integerMatrixOrders-psi">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000060"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0005.html#thm:primePow-mem-integerMatrixOrders-psi">Theorem 5.0.16</a></li>
          
          <li><a href="sect0002.html#psi-def">Definition 2.0.2</a></li>
          
          <li><a href="sect0003.html#lem:one-mem-orders">Theorem 3.0.1</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.mem_integerMatrixOrders_psi" class="lean_decl">Crystallographic.mem_integerMatrixOrders_psi</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>      For \(m \geq 1\) with \(m \neq 2\), we have \(m \in \mathrm{Ord}_{\psi (m)}\). The construction achieves order \(m\) using exactly \(\psi (m)\) dimensions via block diagonal matrices of cyclotomic companion matrices.  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000060">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>By strong induction on \(m\). For \(m = 1\), the identity achieves order 1 in dimension \(\psi (1) = 0\). For prime powers \(p^k\) (excluding \(2^1\)), the companion matrix of \(\Phi _{p^k}\) has order \(p^k\) in dimension \(\varphi (p^k) = \psi (p^k)\). For composite \(m = p^e \cdot m'\) with coprime factors, we use block diagonal of matrices achieving orders \(p^e\) and \(m'\) from the induction hypothesis, with dimension \(\psi (p^e) + \psi (m') = \psi (m)\) by additivity of \(\psi \) on coprime factors. For \(m = 2 \cdot m'\) with \(m'\) odd, negating the order-\(m'\) matrix doubles the order without changing dimension. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>ℕ</code>","1":"<code>0 &lt; m</code>","2":"<code>m ≠ 2</code>","3":"<code>Crystallographic.integerMatrixOrders (N : ℕ) : Set ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The set of possible orders for N×N integer matrices with finite order.\nAn integer `m` is in this set if there exists an N×N integer matrix `A` such that\n`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). </code>","4":"<code>Crystallographic.psi (m : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The psi function for crystallographic restriction.\npsi(m) is the minimum dimension N such that an N×N integer matrix can have order m.\n\nDefined as the sum over prime power factors: if m = prod p_i^{k_i}, then\npsi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) </code>","5":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-15519">theorem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">mem_integerMatrixOrders_psi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6420" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6466" data-verso-hover="1">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6420" data-verso-hover="0">m</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6496" data-verso-hover="2">hm2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6420" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≠</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">2</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.6420" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.integerMatrixOrders" data-verso-hover="3">integerMatrixOrders</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Crystallographic.psi" data-verso-hover="4">psi</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6420" data-verso-hover="0">m</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-15637" data-verso-hover="5">by</span></code><code class="lean-proof-body"><span class="inter-text">
  -- Use strong induction on m
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-15673" data-verso-hover="0">induction</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-15685">using</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.strong_induction_on</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.inductionAlts-15715" data-verso-hover="1">with</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">IH</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
  -- Case: m = 1
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-15753" data-verso-hover="2">rcases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.one_le_iff_ne_zero.mpr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm.ne'</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">eq_or_lt'</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-15806">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">rfl</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_gt1</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-15829" data-verso-hover="3">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-15834">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">psi_one</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-15850" data-verso-hover="4">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">one_mem_integerMatrixOrders</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- Case: m &gt; 1, i.e., m &gt;= 2
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-15924" data-verso-hover="5">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_gt2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-15947" data-verso-hover="6">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-15950" data-verso-hover="7">omega</span><span class="inter-text">
    -- Check if m is a prime power
    </span><span class="keyword token" data-binding="kw-occ-«tacticBy_cases_:_»-15995" data-verso-hover="8">by_cases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpow</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">IsPrimePow</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- m is a prime power p^k
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-16063" data-verso-hover="9">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">isPrimePow_nat_iff</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-16087" data-verso-hover="10">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpow</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.obtain-16101" data-verso-hover="11">obtain</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">p</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hk</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpk</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpow</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.subst-16146" data-verso-hover="12">subst</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpk</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-«tacticBy_cases_:_»-16162" data-verso-hover="8">by_cases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h21</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.obtain-16202" data-verso-hover="11">obtain</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">rfl</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">rfl</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h21</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-16232" data-verso-hover="3">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-16237">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">pow_one</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-16252" data-verso-hover="10">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_gt2</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-16263" data-verso-hover="7">omega</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-16278" data-verso-hover="4">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">primePow_mem_integerMatrixOrders_psi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h21</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- m is not a prime power: use factorization_split_lt
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.obtain-16402" data-verso-hover="11">obtain</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">p</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">he_pos</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_eq</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hcop</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_lt</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">factorization_split_lt</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-16498" data-verso-hover="6">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-16501" data-verso-hover="7">omega</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpow</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-«tacticBy_cases_:_»-16527" data-verso-hover="8">by_cases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_pe_is_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∧</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- p^e = 2, so m = 2 * m' with m' odd
        </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-16619" data-verso-hover="5">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hcop'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.Coprime</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-16652" data-verso-hover="6">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-16655" data-verso-hover="3">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-16660">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">h_pe_is_2</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_pe_is_2</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pow_one</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-16701" data-verso-hover="10">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hcop</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⊢</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-16714" data-verso-hover="4">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hcop</span><span class="inter-text">
        </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-16733" data-verso-hover="5">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">hm'_odd</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_ne_2</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_ge3</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">odd_ne_two_ge_three_of_coprime_two</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hcop'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-16816" data-verso-hover="6">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-16819" data-verso-hover="7">omega</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
        </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-16834" data-verso-hover="9">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.show-16838">show</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic'-16854">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-16857" data-verso-hover="3">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-16862">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">h_pe_is_2</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_pe_is_2</span><span class="unknown token" data-binding="">.</span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">pow_one</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-16903" data-verso-hover="10">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_eq</span><span class="unknown token" data-binding="">;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-16913" data-verso-hover="7">omega</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
        </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-16928" data-verso-hover="4">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">mem_integerMatrixOrders_psi_2_times_odd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-16978" data-verso-hover="6">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-16981" data-verso-hover="7">omega</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_odd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_ge3</span><span class="inter-text">
          </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">IH</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_lt</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-17029" data-verso-hover="6">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-17032" data-verso-hover="7">omega</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_ne_2</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-«tacticBy_cases_:_»-17058" data-verso-hover="8">by_cases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_eq_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- m' = 2, so m = p^e * 2 with p^e odd
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-17145" data-verso-hover="5">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">hpe_odd</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpe_ge3</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">primePow_odd_ge_three_of_coprime_two</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">he_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">hm'_eq_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">▸</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hcop</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-17253" data-verso-hover="9">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_eq</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_eq_2</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-17288" data-verso-hover="4">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">mem_integerMatrixOrders_psi_odd_times_2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">Nat.pow_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp.pos</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpe_odd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpe_ge3</span><span class="inter-text">
            </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">primePow_mem_integerMatrixOrders_psi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">he_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_pe_is_2</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- Neither is 2, use block diagonal construction
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-17524" data-verso-hover="9">rw</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_eq</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-17549" data-verso-hover="4">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">mem_integerMatrixOrders_psi_composite</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-17604" data-verso-hover="6">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-17607" data-verso-hover="7">omega</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hcop</span><span class="inter-text">
            </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">primePow_mem_integerMatrixOrders_psi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">e</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">he_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h_pe_is_2</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
            </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">IH</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_lt</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-17721" data-verso-hover="6">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-17724" data-verso-hover="7">omega</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm'_eq_2</span><span class="unknown token" data-binding="">)</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L295-L360" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:mem-integerMatrixOrders-psi');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:backward-direction">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.18</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#thm:backward-direction">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000061"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0003.html#integerMatrixOrders-def">Definition 3.0.1</a></li>
          
          <li><a href="sect0002.html#psi-def">Definition 2.0.2</a></li>
          
          <li><a href="sect0004.html#companion-def">Definition 4.0.1</a></li>
          
          <li><a href="sect0004.html#thm:companion-charpoly">Theorem 4.0.1</a></li>
          
          <li><a href="sect0004.html#thm:companion-cycl-order">Theorem 4.0.5</a></li>
          
          <li><a href="sect0004.html#thm:mem-orders-totient">Theorem 4.0.7</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.mem_integerMatrixOrders_of_psi_le" class="lean_decl">Crystallographic.mem_integerMatrixOrders_of_psi_le</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>      <b class="bfseries">Backward Direction:</b> If \(\psi (m) \leq N\), then \(m \in \mathrm{Ord}_N\). </p>
<p><b class="bfseries">Mathematical context:</b> The companion matrix of a monic polynomial \(p(X)\) has \(p(X)\) as both its characteristic and minimal polynomial. For the cyclotomic polynomial \(\Phi _m\), the companion matrix \(C_m\) satisfies \(\Phi _m(C_m) = 0\), so \(C_m^m = I\), and since \(\Phi _m\) is minimal (irreducible over \(\mathbb {Q}\) and dividing \(X^m - 1\) but not \(X^k - 1\) for \(k {\lt} m\)), we get \(\mathrm{ord}(C_m) = m\). The key optimization in the \(\psi \) function is that \(\psi (2) = 0\): order 2 is achieved by \(-I\) in any dimension, so we do not need to “pay” \(\varphi (2) = 1\) for the factor of 2. </p>
<p><b class="bfseries">Proof by explicit construction:</b> </p>
<ol class="enumerate">
  <li><p>For \(m = 1\): Use the identity matrix (any dimension). </p>
</li>
  <li><p>For \(m = 2\): Use \(-I\) (dimension \(\geq 1\)), achieving order 2 without adding to \(\psi \). </p>
</li>
  <li><p>For odd prime power \(p^k\): The companion matrix of \(\Phi _{p^k}\) has size \(\varphi (p^k)\). </p>
</li>
  <li><p>For \(2^k\) with \(k \geq 2\): The companion matrix of \(\Phi _{2^k}\) has size \(\varphi (2^k) = 2^{k-1}\). </p>
</li>
  <li><p>For \(m = 2m'\) with \(m'\) odd: If \(A\) has order \(m'\), then \(-A\) has order \(2m'\) (same dimension). </p>
</li>
  <li><p>For general \(m = \prod p_i^{k_i}\): Block diagonal of companion matrices for \(p_i^{k_i}\) with \(p_i \neq 2\) or \(k_i \geq 2\). The orders combine via \(\mathrm{lcm}\) (which equals the product for coprime factors), giving total order \(m\) in dimension \(\psi (m)\). </p>
</li>
  <li><p>Pad with identity blocks to reach size \(N \times N\) (padding does not change order). </p>
</li>
</ol>
<p>  - </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000061">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>We construct a matrix of order \(m\) in dimension \(\psi (m)\) by taking block diagonals of companion matrices for cyclotomic polynomials \(\Phi _{p^k}\) of each prime power factor. The companion matrix \(C(\Phi _{p^k})\) has order exactly \(p^k\) and size \(\varphi (p^k)\). Block diagonal matrices have order equal to the lcm of block orders, which equals \(m\) for coprime factors. Identity padding extends to dimension \(N \geq \psi (m)\). - </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>ℕ</code>","1":"<code>0 &lt; m</code>","2":"<code>psi m ≤ N</code>","3":"<code>Crystallographic.psi (m : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The psi function for crystallographic restriction.\npsi(m) is the minimum dimension N such that an N×N integer matrix can have order m.\n\nDefined as the sum over prime power factors: if m = prod p_i^{k_i}, then\npsi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) </code>","4":"<code>m = 1 ∨ 0 &lt; N</code>","5":"<code>Crystallographic.integerMatrixOrders (N : ℕ) : Set ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The set of possible orders for N×N integer matrices with finite order.\nAn integer `m` is in this set if there exists an N×N integer matrix `A` such that\n`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). </code>","6":"<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-23055">theorem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">mem_integerMatrixOrders_of_psi_le</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7213" data-verso-hover="0">N</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7215" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7261" data-verso-hover="1">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7215" data-verso-hover="0">m</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7269" data-verso-hover="2">hpsi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.psi" data-verso-hover="3">psi</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7215" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7213" data-verso-hover="0">N</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7338" data-verso-hover="4">hNm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7215" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7213" data-verso-hover="0">N</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.7215" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.integerMatrixOrders" data-verso-hover="5">integerMatrixOrders</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7213" data-verso-hover="0">N</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-23208" data-verso-hover="6">by</span></code><code class="lean-proof-body"><span class="inter-text">
  -- Handle base cases m = 1, 2
  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-23245" data-verso-hover="0">rcases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.lt_trichotomy</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-23274">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_lt2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">rfl</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_gt2</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- m &lt; 2 and 0 &lt; m, so m = 1
    </span><span class="keyword token" data-binding="kw-occ-Mathlib.Tactic.intervalCases-23339" data-verso-hover="1">interval_cases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text">
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-23360" data-verso-hover="2">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">one_mem_integerMatrixOrders</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- m = 2: use -I, need N &gt; 0
    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.cases-23434" data-verso-hover="3">cases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hNm</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.inductionAlts-23444" data-verso-hover="4">with</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">inl</span><span class="inter-text"> </span><span class="unknown token" data-binding="">h</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-23464" data-verso-hover="5">omega</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">inr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hN_pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHaveI__-23496" data-verso-hover="6">haveI</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">NeZero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">Nat.pos_iff_ne_zero.mp</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hN_pos</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text">
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-23558" data-verso-hover="2">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">two_mem_integerMatrixOrders</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- m &gt; 2, i.e., m &gt;= 3
    -- If m ≤ N, use permutation matrix directly
    </span><span class="keyword token" data-binding="kw-occ-«tacticBy_cases_:_»-23677" data-verso-hover="7">by_cases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hle</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-23707" data-verso-hover="2">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">integerMatrixOrders_mono</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hle</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">mem_integerMatrixOrders_self</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-23775" data-verso-hover="8">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-23778" data-verso-hover="5">omega</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
    </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- m &gt; N: need companion matrices
      </span><span class="keyword token" data-binding="kw-occ-Mathlib.Tactic.Push.push_neg-23833" data-verso-hover="9">push_neg</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.location-23842" data-verso-hover="10">at</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hle</span><span class="inter-text">
      -- Case split on m
      </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-23880" data-verso-hover="0">rcases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.lt_trichotomy</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">5</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-23909">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_lt5</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">rfl</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_gt5</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- m ∈ {3, 4}: use small case helper
        </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave__-23992" data-verso-hover="11">have</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm34</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">{</span><span class="unknown token" data-binding="">3</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">4</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">6</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Finset</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-24038" data-verso-hover="8">by</span><span class="inter-text">
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-24051" data-verso-hover="12">simp</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-24056">only</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">Finset.mem_insert</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Finset.mem_singleton</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-24113" data-verso-hover="5">omega</span><span class="inter-text">
        </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-24127" data-verso-hover="2">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">mem_integerMatrixOrders_small</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm34</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpsi</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- m = 5
        </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-24203" data-verso-hover="2">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">mem_integerMatrixOrders_five</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpsi</span><span class="inter-text">
      </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- m &gt; 5
        </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rcases-24271" data-verso-hover="0">rcases</span><span class="inter-text"> </span><span class="unknown token" data-binding="">Nat.lt_trichotomy</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">6</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-24300">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_lt6</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">rfl</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_gt6</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.omega-24338" data-verso-hover="5">omega</span><span class="inter-text"> -- impossible: 5 &lt; m &lt; 6
        </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- m = 6
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-24399" data-verso-hover="2">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">mem_integerMatrixOrders_small</span><span class="inter-text"> </span><span class="unknown token" data-binding="">6</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-24440" data-verso-hover="8">by</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-24443" data-verso-hover="12">simp</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpsi</span><span class="inter-text">
        </span><span class="unknown token" data-binding="">·</span><span class="inter-text"> -- m &gt; 6: general case
          </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-24498" data-verso-hover="2">exact</span><span class="inter-text"> </span><span class="unknown token" data-binding="">mem_integerMatrixOrders_of_psi_le_large</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm_gt6</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpsi</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L404-L485" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:backward-direction');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:main-theorem">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.19</span>
      <div class="thm_header_extras">

    
    ✓
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#thm:main-theorem">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000062"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.crystallographic_restriction" class="lean_decl">Crystallographic.crystallographic_restriction</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>      <b class="bfseries">The Crystallographic Restriction Theorem:</b> An \(N \times N\) integer matrix can have finite order \(m\) if and only if \(\psi (m) \leq N\). </p>
<p>Equivalently: \(m \in \mathrm{Ord}_N \iff \psi (m) \leq N\). </p>
<p>This theorem completely characterizes which rotation orders are achievable by integer matrices in each dimension. The function \(\psi \) is defined as: \(\psi (1) = \psi (2) = 0\), and for other \(m\), \(\psi (m) = \sum _{p^k \|  m, p \neq 2 \text{ or } k \geq 2} \varphi (p^k)\). </p>
<p><b class="bfseries">Forward direction:</b> If \(A \in \mathbb {Z}^{N \times N}\) has order \(m\), the minimal polynomial of \(A\) over \(\mathbb {Q}\) divides \(X^m - 1\) and must include cyclotomic factors \(\Phi _d\) for divisors \(d\) whose lcm equals \(m\). The sum of \(\varphi (d)\) over these divisors is at least \(\psi (m)\), and this sum bounds the degree of the minimal polynomial, which is at most \(N\). </p>
<p><b class="bfseries">Backward direction:</b> For each prime power \(p^k\) (with \(p \neq 2\) or \(k \geq 2\)), the companion matrix of \(\Phi _{p^k}\) has size \(\varphi (p^k)\) and order \(p^k\). For general \(m\), block diagonal combinations of these companion matrices achieve order \(m\) in dimension \(\psi (m)\). - </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000062">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">▶</span>
      </div>
      <div class="proof_content">
      <p>The proof combines the forward and backward directions. The forward direction shows that eigenvalue constraints force \(\psi (m) \leq N\). The backward direction constructs explicit matrices achieving each order using companion matrices of cyclotomic polynomials. - </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code" data-lean-hovers='{"0":"<code>ℕ</code>","1":"<code>0 &lt; m</code>","2":"<code>m = 1 ∨ 0 &lt; N</code>","3":"<code>Crystallographic.integerMatrixOrders (N : ℕ) : Set ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The set of possible orders for N×N integer matrices with finite order.\nAn integer `m` is in this set if there exists an N×N integer matrix `A` such that\n`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). </code>","4":"<code>Crystallographic.psi (m : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The psi function for crystallographic restriction.\npsi(m) is the minimum dimension N such that an N×N integer matrix can have order m.\n\nDefined as the sum over prime power factors: if m = prod p_i^{k_i}, then\npsi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) </code>"}'><code class="lean-signature"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-2843">theorem</span><span class="inter-text"> </span><span class="unknown token" data-binding="">crystallographic_restriction</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="0">N</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.50" data-verso-hover="1">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="0">m</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.119" data-verso-hover="2">hNm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∨</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="0">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="0">N</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
    </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">∈</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.integerMatrixOrders" data-verso-hover="3">integerMatrixOrders</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="0">N</span><span class="inter-text"> </span><span class="unknown token" data-binding="">↔</span><span class="inter-text"> </span><span class="const token" data-binding="const-Crystallographic.psi" data-verso-hover="4">psi</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4" data-verso-hover="0">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">≤</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="0">N</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span></code><code class="lean-proof-body"><span class="inter-text">
  </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">psi_le_of_mem_integerMatrixOrders</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm</span><span class="unknown token" data-binding="">,</span><span class="inter-text">
   </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-3032">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpsi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">mem_integerMatrixOrders_of_psi_le</span><span class="inter-text"> </span><span class="unknown token" data-binding="">N</span><span class="inter-text"> </span><span class="unknown token" data-binding="">m</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hm</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hpsi</span><span class="inter-text"> </span><span class="unknown token" data-binding="">hNm</span><span class="unknown token" data-binding="">⟩</span><span class="inter-text">

</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/MainTheorem.lean#L42-L75" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:main-theorem');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === '▼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>
<script>
(function() {
  // Global initialization guard - only run once per page
  if (window._leanHoverTooltipsInitialized) return;
  window._leanHoverTooltipsInitialized = true;

  // Create tooltip element
  var tooltip = document.createElement('div');
  tooltip.className = 'lean-hover-tooltip';
  tooltip.style.display = 'none';
  document.body.appendChild(tooltip);

  // Initialize hover tooltips for all .lean-code blocks
  document.querySelectorAll('.lean-code[data-lean-hovers]').forEach(function(codeBlock) {
    var hoverData = codeBlock.dataset.leanHovers;
    if (!hoverData) return;

    var hovers;
    try {
      hovers = JSON.parse(hoverData);
    } catch (e) {
      console.warn('Failed to parse hover data:', e);
      return;
    }

    codeBlock.querySelectorAll('[data-verso-hover]').forEach(function(el) {
      var hoverId = el.dataset.versoHover;
      var content = hovers[hoverId];
      if (!content) return;

      el.addEventListener('mouseenter', function(e) {
        tooltip.innerHTML = content;
        tooltip.style.display = 'block';
        var rect = el.getBoundingClientRect();
        tooltip.style.left = rect.left + window.scrollX + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
      });

      el.addEventListener('mouseleave', function() {
        tooltip.style.display = 'none';
      });
    });
  });
})();
</script>




</div> <!--main-text -->
</div> <!-- content-wrapper -->
</div> <!-- content -->
</div> <!-- wrapper -->

<nav class="prev_up_next">
  <svg  id="showmore-minus" class="icon icon-eye-minus showmore"><use xlink:href="symbol-defs.svg#icon-eye-minus"></use></svg>

  <svg  id="showmore-plus" class="icon icon-eye-plus showmore"><use xlink:href="symbol-defs.svg#icon-eye-plus"></use></svg>

  <a href="sect0004.html" title="Companion Matrices"><svg  class="icon icon-arrow-left "><use xlink:href="symbol-defs.svg#icon-arrow-left"></use></svg>
</a>
  <a href="index.html" title="Crystallographic Restriction Theorem"><svg  class="icon icon-arrow-up "><use xlink:href="symbol-defs.svg#icon-arrow-up"></use></svg>
</a>
  <a href="sect0006.html" title="Appendix"><svg  class="icon icon-arrow-right "><use xlink:href="symbol-defs.svg#icon-arrow-right"></use></svg>
</a>
</nav>

<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/plastex.js"></script>
<script type="text/javascript" src="js/svgxuse.js"></script>
<script type="text/javascript" src="js/js.cookie.min.js"></script>
<script type="text/javascript" src="js/showmore.js"></script>
</body>
</html>