<!DOCTYPE html>
<html lang="en">
<head>
<script>
  MathJax = { 
    tex: {
		    inlineMath: [['$','$'], ['\\(','\\)']]
	} }
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<meta name="generator" content="plasTeX" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Crystallographic Restriction Theorem</title>
<link rel="next" href="sect0006.html" title="Appendix" />
<link rel="prev" href="sect0004.html" title="Companion Matrices" />
<link rel="up" href="index.html" title="Crystallographic Restriction Theorem" />
<link rel="stylesheet" href="styles/theme-blue.css" />
<link rel="stylesheet" href="styles/showmore.css" />
<link rel="stylesheet" href="styles/blueprint.css" />
<link rel="stylesheet" href="styles/amsthm.css" />
<link rel="stylesheet" href="styles/style.css" />
</head>

<body>
<header>
<svg  id="toc-toggle" class="icon icon-list-numbered "><use xlink:href="symbol-defs.svg#icon-list-numbered"></use></svg>
<h1 id="doc_title"><a href="index.html">Crystallographic Restriction Theorem</a></h1>
</header>

<div class="wrapper">
<nav class="toc">
<ul class="sub-toc-0">
<li class="">
  <a href="sect0001.html"><span class="toc_ref">1</span> <span class="toc_entry">Introduction</span></a>
 </li>
<li class="">
  <a href="sect0002.html"><span class="toc_ref">2</span> <span class="toc_entry">The Psi Function</span></a>
 </li>
<li class="">
  <a href="sect0003.html"><span class="toc_ref">3</span> <span class="toc_entry">Integer Matrix Orders</span></a>
 </li>
<li class="">
  <a href="sect0004.html"><span class="toc_ref">4</span> <span class="toc_entry">Companion Matrices</span></a>
 </li>
<li class=" active current">
  <a href="sect0005.html"><span class="toc_ref">5</span> <span class="toc_entry">The Crystallographic Restriction Theorem</span></a>
 </li>
<li class="">
  <a href="sect0006.html"><span class="toc_ref">A</span> <span class="toc_entry">Appendix</span></a>
 </li>
<li ><a href="dep_graph_document.html">Dependency graph</a></li>
</ul>
</nav>

<div class="content">
<div class="content-wrapper">


<div class="main-text">
<h1 id="a0000000006">5 The Crystallographic Restriction Theorem</h1>
<p>The proof splits into two directions: showing \(\psi (m) \leq N\) is necessary (forward) and sufficient (backward) for \(m \in \mathrm{Ord}_N\). </p>
<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:pow-eq-one-of-minpoly-dvd">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.1</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:pow-eq-one-of-minpoly-dvd">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000044"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Matrix.pow_eq_one_of_minpoly_dvd_X_pow_sub_one" class="lean_decl">Matrix.pow_eq_one_of_minpoly_dvd_X_pow_sub_one</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       If \(\mu _A \mid X^k - 1\), then \(A^k = I\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000044">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p>The polynomial \(X^k - 1\) annihilates \(A\) (since the minimal polynomial does), meaning \(A^k - I = 0\). Transfer this identity from \(\mathbb {Q}\) back to \(\mathbb {Z}\) via the injectivity of \(\mathbb {Z} \to \mathbb {Q}\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Matrix.pow_eq_one_of_minpoly_dvd_X_pow_sub_one" data-signature="Matrix.pow_eq_one_of_minpoly_dvd_X_pow_sub_one {N : â„•} (A : Matrix (Fin N) (Fin N) â„¤) (k : â„•)
  (hdvd : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ k - 1) : A ^ k = 1" data-docs="If the minimal polynomial of an integer matrix A divides X^k - 1, then A^k = 1.
This transfers the polynomial identity back to the matrix via the ring homomorphism. " title="Matrix.pow_eq_one_of_minpoly_dvd_X_pow_sub_one {N : â„•} (A : Matrix (Fin N) (Fin N) â„¤) (k : â„•)
  (hdvd : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ k - 1) : A ^ k = 1
If the minimal polynomial of an integer matrix A divides X^k - 1, then A^k = 1....">pow_eq_one_of_minpoly_dvd_X_pow_sub_one</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="â„•" title="â„•">N</span> : â„•<span class="lean-bracket-1">}</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> : <span class="lean-const" data-name="Matrix" data-signature="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (Î± : Type v) : Type (max u u&#x27; v)" data-docs="`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`
and whose columns are indexed by `n`. " title="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (Î± : Type v) : Type (max u u&#x27; v)
`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`...">Matrix</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : â„•) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : â„•) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : â„•) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : â„•) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-2">)</span> â„¤<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">k</span> : â„•<span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ k - 1" title="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ k - 1">hdvd</span> : <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-bracket-2">(</span><span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-3">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-3">)</span><span class="lean-bracket-2">)</span> âˆ£ <span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-var" data-type="â„•" title="â„•">k</span> - <span class="lean-expr" data-type="â„š[X]" title="â„š[X]">1</span><span class="lean-bracket-1">)</span> : <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> ^ <span class="lean-var" data-type="â„•" title="â„•">k</span> = <span class="lean-expr" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">1</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="The `let` tactic is for adding definitions to the local context of the main goal.
The definition can be unfolded, unlike definitions introduced by `have`.

* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.
* `let x := e` uses the type of `e` for `t`.
* `let : t := e` and `let := e` use `this` for the name of the hypothesis.
* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that let only one applicable constructor.
  For example, given `p : Î± Ã— Î² Ã— Î³`, `let âŸ¨x, y, zâŸ© := p` produces the
  local variables `x : Î±`, `y : Î²`, and `z : Î³`.
* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `let` term.

## Properties and relations

* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics
  such as `simp`, `dsimp`, `unfold`, and `subst`.
* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.
  The tactic might fail if the local context depends on the value of the variable.
* The `let` tactic is preferred for data (non-propositions).
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
" title="The `let` tactic is for adding definitions to the local context of the main goal.">let</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span> := <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-1">)</span>
  <span class="lean-comment">-- If minpoly | X^k - <span class="lean-number">1</span>, then aeval A_Q </span><span class="lean-bracket-1">(</span>X^k - <span class="lean-number">1</span><span class="lean-bracket-1">)</span> = <span class="lean-number">0</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(aeval A_Q) (X ^ k - 1) = 0" title="(aeval A_Q) (X ^ k - 1) = 0">haeval</span> : <span class="lean-const" data-name="Polynomial.aeval" data-signature="Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] â†’â‚[R] A" data-docs="Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is
the unique `R`-algebra homomorphism from `R[X]` to `A` sending `X` to `x`.

This is a stronger variant of the linear map `Polynomial.leval`. " title="Polynomial.aeval.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) : R[X] â†’â‚[R] A
Given a valuation `x` of the variable in an `R`-algebra `A`, `aeval R A x` is...">aeval</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-var" data-type="â„•" title="â„•">k</span> - <span class="lean-expr" data-type="â„š[X]" title="â„š[X]">1</span> : â„š<span class="lean-bracket-2">[</span>X<span class="lean-bracket-2">]</span><span class="lean-bracket-1">)</span> = <span class="lean-expr" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">0</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
    <span class="lean-keyword" data-docs="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for
a description of supported patterns.

```lean
obtain âŸ¨pattâŸ© : type := proof
```
is equivalent to
```lean
have h : type := proof
rcases h with âŸ¨pattâŸ©
```

If `âŸ¨pattâŸ©` is omitted, `rcases` will try to infer the pattern.

If `type` is omitted, `:= proof` is required.
" title="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for">obtain</span> <span class="lean-bracket-1">âŸ¨</span><span class="lean-var" data-type="â„š[X]" title="â„š[X]">q</span>, <span class="lean-var" data-type="X ^ k - 1 = minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) * q" title="X ^ k - 1 = minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) * q">hq</span><span class="lean-bracket-1">âŸ©</span> := <span class="lean-var" data-type="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ k - 1" title="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ k - 1">hdvd</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="X ^ k - 1 = minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) * q" title="X ^ k - 1 = minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) * q">hq</span>, <span class="lean-const" data-name="map_mul" data-signature="map_mul.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [Mul M] [Mul N] [FunLike F M N] [MulHomClass F M N]
  (f : F) (x y : M) : f (x * y) = f x * f y" data-docs="See note [hom simp lemma priority] " title="map_mul.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [Mul M] [Mul N] [FunLike F M N] [MulHomClass F M N]
  (f : F) (x y : M) : f (x * y) = f x * f y
See note [hom simp lemma priority] ">map_mul</span>, <span class="lean-const" data-name="minpoly.aeval" data-signature="minpoly.aeval.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) :
  (aeval x) (minpoly A x) = 0" data-docs="An element is a root of its minimal polynomial. " title="minpoly.aeval.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) :
  (aeval x) (minpoly A x) = 0
An element is a root of its minimal polynomial. ">minpoly.aeval</span>, <span class="lean-const" data-name="MulZeroClass.zero_mul" data-signature="MulZeroClass.zero_mul.{u} {Mâ‚€ : Type u} [self : MulZeroClass Mâ‚€] (a : Mâ‚€) : 0 * a = 0" data-docs="Zero is a left absorbing element for multiplication " title="MulZeroClass.zero_mul.{u} {Mâ‚€ : Type u} [self : MulZeroClass Mâ‚€] (a : Mâ‚€) : 0 * a = 0
Zero is a left absorbing element for multiplication ">zero_mul</span><span class="lean-bracket-1">]</span>
  <span class="lean-comment">-- This means A_Q^k = <span class="lean-number">1</span></span>
  <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="map_sub" data-signature="map_sub.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [AddGroup G] [SubtractionMonoid H]
  [AddMonoidHomClass F G H] (f : F) (a b : G) : f (a - b) = f a - f b" data-docs="Additive group homomorphisms preserve subtraction. " title="map_sub.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [AddGroup G] [SubtractionMonoid H]
  [AddMonoidHomClass F G H] (f : F) (a b : G) : f (a - b) = f a - f b
Additive group homomorphisms preserve subtraction. ">map_sub</span>, <span class="lean-const" data-name="map_pow" data-signature="map_pow.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [Monoid G] [Monoid H]
  [MonoidHomClass F G H] (f : F) (a : G) (n : â„•) : f (a ^ n) = f a ^ n" data-docs="See note [hom simp lemma priority] " title="map_pow.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [Monoid G] [Monoid H]
  [MonoidHomClass F G H] (f : F) (a : G) (n : â„•) : f (a ^ n) = f a ^ n
See note [hom simp lemma priority] ">map_pow</span>, <span class="lean-const" data-name="Polynomial.aeval_X" data-signature="Polynomial.aeval_X.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) :
  (aeval x) X = x" title="Polynomial.aeval_X.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) :
  (aeval x) X = x">aeval_X</span>, <span class="lean-const" data-name="map_one" data-signature="map_one.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [One M] [One N] [FunLike F M N] [OneHomClass F M N]
  (f : F) : f 1 = 1" data-docs="See note [hom simp lemma priority] " title="map_one.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [One M] [One N] [FunLike F M N] [OneHomClass F M N]
  (f : F) : f 1 = 1
See note [hom simp lemma priority] ">map_one</span>, <span class="lean-const" data-name="sub_eq_zero" data-signature="sub_eq_zero.{u_3} {G : Type u_3} [AddGroup G] {a b : G} : a - b = 0 â†” a = b" title="sub_eq_zero.{u_3} {G : Type u_3} [AddGroup G] {a b : G} : a - b = 0 â†” a = b">sub_eq_zero</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`
* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="(aeval A_Q) (X ^ k - 1) = 0" title="(aeval A_Q) (X ^ k - 1) = 0">haeval</span>
  <span class="lean-comment">-- Transfer back to A via injectivity</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="Function.Injective fun x =&gt; x.map â‡‘(algebraMap â„¤ â„š)" title="Function.Injective fun x =&gt; x.map â‡‘(algebraMap â„¤ â„š)">hinj</span> := <span class="lean-const" data-name="Crystallographic.Matrix.map_algebraMap_int_injective" data-signature="Crystallographic.Matrix.map_algebraMap_int_injective (N : â„•) : Function.Injective fun x =&gt; x.map â‡‘(algebraMap â„¤ â„š)" data-docs="Mapping integer matrices to rational matrices via `algebraMap â„¤ â„š` is injective. " title="Crystallographic.Matrix.map_algebraMap_int_injective (N : â„•) : Function.Injective fun x =&gt; x.map â‡‘(algebraMap â„¤ â„š)
Mapping integer matrices to rational matrices via `algebraMap â„¤ â„š` is injective. ">Crystallographic.Matrix.map_algebraMap_int_injective</span> <span class="lean-var" data-type="â„•" title="â„•">N</span>
  <span class="lean-keyword" data-docs="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.
" title="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.">apply</span> <span class="lean-var" data-type="Function.Injective fun x =&gt; x.map â‡‘(algebraMap â„¤ â„š)" title="Function.Injective fun x =&gt; x.map â‡‘(algebraMap â„¤ â„š)">hinj</span>
  <span class="lean-keyword" data-docs="* `change tgt&#x27;` will change the goal from `tgt` to `tgt&#x27;`,
  assuming these are definitionally equal.
* `change t&#x27; at h` will change hypothesis `h : t` to have type `t&#x27;`, assuming
  assuming `t` and `t&#x27;` are definitionally equal.
" title="* `change tgt&#x27;` will change the goal from `tgt` to `tgt&#x27;`,">change</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> ^ <span class="lean-var" data-type="â„•" title="â„•">k</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-1">)</span> =
    <span class="lean-bracket-1">(</span><span class="lean-expr" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">1</span> : <span class="lean-const" data-name="Matrix" data-signature="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (Î± : Type v) : Type (max u u&#x27; v)" data-docs="`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`
and whose columns are indexed by `n`. " title="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (Î± : Type v) : Type (max u u&#x27; v)
`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`...">Matrix</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : â„•) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : â„•) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : â„•) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : â„•) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-2">)</span> â„¤<span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Matrix.map_pow" data-signature="Matrix.map_pow.{u_2, u_14, u_15} {m : Type u_2} [Fintype m] [DecidableEq m] {Î± : Type u_14} {Î² : Type u_15} [Semiring Î±]
  [Semiring Î²] (M : Matrix m m Î±) (f : Î± â†’+* Î²) (a : â„•) : (M ^ a).map â‡‘f = M.map â‡‘f ^ a" title="Matrix.map_pow.{u_2, u_14, u_15} {m : Type u_2} [Fintype m] [DecidableEq m] {Î± : Type u_14} {Î² : Type u_15} [Semiring Î±]
  [Semiring Î²] (M : Matrix m m Î±) (f : Î± â†’+* Î²) (a : â„•) : (M ^ a).map â‡‘f = M.map â‡‘f ^ a">Matrix.map_pow</span>, <span class="lean-const" data-name="Matrix.map_one" data-signature="Matrix.map_one.{v, w, u_3} {n : Type u_3} {Î± : Type v} {Î² : Type w} [DecidableEq n] [Zero Î±] [One Î±] [Zero Î²] [One Î²]
  (f : Î± â†’ Î²) (hâ‚€ : f 0 = 0) (hâ‚ : f 1 = 1) : map 1 f = 1" title="Matrix.map_one.{v, w, u_3} {n : Type u_3} {Î± : Type v} {Î² : Type w} [DecidableEq n] [Zero Î±] [One Î±] [Zero Î²] [One Î²]
  (f : Î± â†’ Î²) (hâ‚€ : f 0 = 0) (hâ‚ : f 1 = 1) : map 1 f = 1">Matrix.map_one</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="map_zero" data-signature="map_zero.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [Zero M] [Zero N] [FunLike F M N]
  [ZeroHomClass F M N] (f : F) : f 0 = 0" title="map_zero.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [Zero M] [Zero N] [FunLike F M N]
  [ZeroHomClass F M N] (f : F) : f 0 = 0">map_zero</span> _<span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="map_one" data-signature="map_one.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [One M] [One N] [FunLike F M N] [OneHomClass F M N]
  (f : F) : f 1 = 1" data-docs="See note [hom simp lemma priority] " title="map_one.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [One M] [One N] [FunLike F M N] [OneHomClass F M N]
  (f : F) : f 1 = 1
See note [hom simp lemma priority] ">map_one</span> _<span class="lean-bracket-2">)</span><span class="lean-bracket-1">]</span>
  <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-var" data-type="A_Q ^ k = 1" title="A_Q ^ k = 1">haeval</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Forward.lean#L48-L71" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:pow-eq-one-of-minpoly-dvd');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:minpoly-dvd-X-pow-sub-one">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.2</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:minpoly-dvd-X-pow-sub-one">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000045"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Matrix.minpoly_dvd_X_pow_sub_one_of_pow_eq_one" class="lean_decl">Matrix.minpoly_dvd_X_pow_sub_one_of_pow_eq_one</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       If \(A^m = I\), then \(\mu _A \mid X^m - 1\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000045">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p>The polynomial \(X^m - 1\) annihilates \(A\) since \((A_{\mathbb {Q}})^m - I = 0\). The minimal polynomial divides any annihilating polynomial by definition. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Matrix.minpoly_dvd_X_pow_sub_one_of_pow_eq_one" data-signature="Matrix.minpoly_dvd_X_pow_sub_one_of_pow_eq_one {N : â„•} (A : Matrix (Fin N) (Fin N) â„¤) (m : â„•) (hpow : A ^ m = 1) :
  minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1" data-docs="If A^m = 1, then the minimal polynomial of A divides X^m - 1.
This is because X^m - 1 annihilates A, and the minimal polynomial divides any annihilating polynomial. " title="Matrix.minpoly_dvd_X_pow_sub_one_of_pow_eq_one {N : â„•} (A : Matrix (Fin N) (Fin N) â„¤) (m : â„•) (hpow : A ^ m = 1) :
  minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1
If A^m = 1, then the minimal polynomial of A divides X^m - 1....">minpoly_dvd_X_pow_sub_one_of_pow_eq_one</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="â„•" title="â„•">N</span> : â„•<span class="lean-bracket-1">}</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> : <span class="lean-const" data-name="Matrix" data-signature="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (Î± : Type v) : Type (max u u&#x27; v)" data-docs="`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`
and whose columns are indexed by `n`. " title="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (Î± : Type v) : Type (max u u&#x27; v)
`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`...">Matrix</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : â„•) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : â„•) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : â„•) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : â„•) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-2">)</span> â„¤<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">m</span> : â„•<span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="A ^ m = 1" title="A ^ m = 1">hpow</span> : <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> ^ <span class="lean-var" data-type="â„•" title="â„•">m</span> = <span class="lean-expr" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">1</span><span class="lean-bracket-1">)</span> : <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span> âˆ£ <span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-var" data-type="â„•" title="â„•">m</span> - <span class="lean-expr" data-type="â„š[X]" title="â„š[X]">1</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.
" title="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.">apply</span> <span class="lean-const" data-name="minpoly.dvd" data-signature="minpoly.dvd.{u_1, u_2} (A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {p : A[X]}
  (hp : (aeval x) p = 0) : minpoly A x âˆ£ p" data-docs="If an element `x` is a root of a polynomial `p`, then the minimal polynomial of `x` divides `p`.
See also `minpoly.isIntegrallyClosed_dvd` which relaxes the assumptions on `A` in exchange for
stronger assumptions on `B`. " title="minpoly.dvd.{u_1, u_2} (A : Type u_1) {B : Type u_2} [Field A] [Ring B] [Algebra A B] (x : B) {p : A[X]}
  (hp : (aeval x) p = 0) : minpoly A x âˆ£ p
If an element `x` is a root of a polynomial `p`, then the minimal polynomial of `x` divides `p`....">minpoly.dvd</span>
  <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="map_sub" data-signature="map_sub.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [AddGroup G] [SubtractionMonoid H]
  [AddMonoidHomClass F G H] (f : F) (a b : G) : f (a - b) = f a - f b" data-docs="Additive group homomorphisms preserve subtraction. " title="map_sub.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [AddGroup G] [SubtractionMonoid H]
  [AddMonoidHomClass F G H] (f : F) (a b : G) : f (a - b) = f a - f b
Additive group homomorphisms preserve subtraction. ">map_sub</span>, <span class="lean-const" data-name="map_pow" data-signature="map_pow.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [Monoid G] [Monoid H]
  [MonoidHomClass F G H] (f : F) (a : G) (n : â„•) : f (a ^ n) = f a ^ n" data-docs="See note [hom simp lemma priority] " title="map_pow.{u_7, u_8, u_9} {G : Type u_7} {H : Type u_8} {F : Type u_9} [FunLike F G H] [Monoid G] [Monoid H]
  [MonoidHomClass F G H] (f : F) (a : G) (n : â„•) : f (a ^ n) = f a ^ n
See note [hom simp lemma priority] ">map_pow</span>, <span class="lean-const" data-name="Polynomial.aeval_X" data-signature="Polynomial.aeval_X.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) :
  (aeval x) X = x" title="Polynomial.aeval_X.{u, z} {R : Type u} {A : Type z} [CommSemiring R] [Semiring A] [Algebra R A] (x : A) :
  (aeval x) X = x">aeval_X</span>, <span class="lean-const" data-name="map_one" data-signature="map_one.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [One M] [One N] [FunLike F M N] [OneHomClass F M N]
  (f : F) : f 1 = 1" data-docs="See note [hom simp lemma priority] " title="map_one.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [One M] [One N] [FunLike F M N] [OneHomClass F M N]
  (f : F) : f 1 = 1
See note [hom simp lemma priority] ">map_one</span><span class="lean-bracket-1">]</span>
  <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-operator">â†</span> <span class="lean-const" data-name="Matrix.map_pow" data-signature="Matrix.map_pow.{u_2, u_14, u_15} {m : Type u_2} [Fintype m] [DecidableEq m] {Î± : Type u_14} {Î² : Type u_15} [Semiring Î±]
  [Semiring Î²] (M : Matrix m m Î±) (f : Î± â†’+* Î²) (a : â„•) : (M ^ a).map â‡‘f = M.map â‡‘f ^ a" title="Matrix.map_pow.{u_2, u_14, u_15} {m : Type u_2} [Fintype m] [DecidableEq m] {Î± : Type u_14} {Î² : Type u_15} [Semiring Î±]
  [Semiring Î²] (M : Matrix m m Î±) (f : Î± â†’+* Î²) (a : â„•) : (M ^ a).map â‡‘f = M.map â‡‘f ^ a">Matrix.map_pow</span>, <span class="lean-var" data-type="A ^ m = 1" title="A ^ m = 1">hpow</span>,
    <span class="lean-const" data-name="Matrix.map_one" data-signature="Matrix.map_one.{v, w, u_3} {n : Type u_3} {Î± : Type v} {Î² : Type w} [DecidableEq n] [Zero Î±] [One Î±] [Zero Î²] [One Î²]
  (f : Î± â†’ Î²) (hâ‚€ : f 0 = 0) (hâ‚ : f 1 = 1) : map 1 f = 1" title="Matrix.map_one.{v, w, u_3} {n : Type u_3} {Î± : Type v} {Î² : Type w} [DecidableEq n] [Zero Î±] [One Î±] [Zero Î²] [One Î²]
  (f : Î± â†’ Î²) (hâ‚€ : f 0 = 0) (hâ‚ : f 1 = 1) : map 1 f = 1">Matrix.map_one</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="map_zero" data-signature="map_zero.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [Zero M] [Zero N] [FunLike F M N]
  [ZeroHomClass F M N] (f : F) : f 0 = 0" title="map_zero.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [Zero M] [Zero N] [FunLike F M N]
  [ZeroHomClass F M N] (f : F) : f 0 = 0">map_zero</span> _<span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="map_one" data-signature="map_one.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [One M] [One N] [FunLike F M N] [OneHomClass F M N]
  (f : F) : f 1 = 1" data-docs="See note [hom simp lemma priority] " title="map_one.{u_4, u_5, u_9} {M : Type u_4} {N : Type u_5} {F : Type u_9} [One M] [One N] [FunLike F M N] [OneHomClass F M N]
  (f : F) : f 1 = 1
See note [hom simp lemma priority] ">map_one</span> _<span class="lean-bracket-2">)</span>, <span class="lean-const" data-name="sub_self" data-signature="sub_self.{u_1} {G : Type u_1} [AddGroup G] (a : G) : a - a = 0" title="sub_self.{u_1} {G : Type u_1} [AddGroup G] (a : G) : a - a = 0">sub_self</span><span class="lean-bracket-1">]</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Forward.lean#L73-L85" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:minpoly-dvd-X-pow-sub-one');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:cyclotomic-finset-product-dvd">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.3</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:cyclotomic-finset-product-dvd">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000046"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.cyclotomic_finset_product_dvd" class="lean_decl">Crystallographic.cyclotomic_finset_product_dvd</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       If \(\Phi _d \mid f\) for all \(d \in S\), then \(\prod _{d \in S} \Phi _d \mid f\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000046">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p>By induction on \(S\). The empty product divides everything. For the insert case, use that cyclotomic polynomials with distinct indices are coprime over \(\mathbb {Q}\), so \(\Phi _d\) is coprime to \(\prod _{x \in s} \Phi _x\) when \(d \notin s\). Then apply coprime divisibility: if \(a, b\) are coprime and both divide \(f\), then \(ab \mid f\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Crystallographic.cyclotomic_finset_product_dvd" data-signature="Crystallographic.cyclotomic_finset_product_dvd {target : â„š[X]} (S : Finset â„•)
  (hdvd_each : âˆ€ d âˆˆ S, cyclotomic d â„š âˆ£ target) : âˆ d âˆˆ S, cyclotomic d â„š âˆ£ target" data-docs="If each cyclotomic polynomial in a finset divides a target polynomial,
then their product also divides the target. " title="Crystallographic.cyclotomic_finset_product_dvd {target : â„š[X]} (S : Finset â„•)
  (hdvd_each : âˆ€ d âˆˆ S, cyclotomic d â„š âˆ£ target) : âˆ d âˆˆ S, cyclotomic d â„š âˆ£ target
If each cyclotomic polynomial in a finset divides a target polynomial,...">cyclotomic_finset_product_dvd</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="â„š[X]" title="â„š[X]">target</span> : â„š<span class="lean-bracket-2">[</span>X<span class="lean-bracket-2">]</span><span class="lean-bracket-1">}</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> : <span class="lean-const" data-name="Finset" data-signature="Finset.{u_4} (Î± : Type u_4) : Type u_4" data-docs="`Finset Î±` is the type of finite sets of elements of `Î±`. It is implemented
as a multiset (a list up to permutation) which has no duplicate elements. " title="Finset.{u_4} (Î± : Type u_4) : Type u_4
`Finset Î±` is the type of finite sets of elements of `Î±`. It is implemented...">Finset</span> â„•<span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="âˆ€ d âˆˆ S, cyclotomic d â„š âˆ£ target" title="âˆ€ d âˆˆ S, cyclotomic d â„š âˆ£ target">hdvd_each</span> : <span class="lean-operator">âˆ€</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>, <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š âˆ£ <span class="lean-var" data-type="â„š[X]" title="â„š[X]">target</span><span class="lean-bracket-1">)</span> :
    <span class="lean-bracket-1">(</span><span class="lean-operator">âˆ</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>, <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š<span class="lean-bracket-1">)</span> âˆ£ <span class="lean-var" data-type="â„š[X]" title="â„š[X]">target</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="Assuming `x` is a variable in the local context with an inductive type,
`induction x` applies induction on `x` to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on `x`,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,
`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,
and one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.
Here the names `a` and `ihâ‚` are chosen automatically and are not accessible.
You can use `with` to provide the variables names for each constructor.
- `induction e`, where `e` is an expression instead of a variable,
  generalizes `e` in the goal, and then performs induction on the resulting variable.
- `induction e using r` allows the user to specify the principle of induction that should be used.
  Here `r` should be a term whose result type must be of the form `C t`,
  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables
- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,
  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.
  In other words, the net effect is that each inductive hypothesis is generalized.
- Given `x : Nat`, `induction x with | zero =&gt; tacâ‚ | succ x&#x27; ih =&gt; tacâ‚‚`
  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.
" title="Assuming `x` is a variable in the local context with an inductive type,">induction</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> <span class="lean-keyword">using</span> <span class="lean-const" data-name="Finset.induction" data-signature="Finset.induction.{u_3} {Î± : Type u_3} {motive : Finset Î± â†’ Prop} [DecidableEq Î±] (empty : motive âˆ…)
  (insert : âˆ€ (a : Î±) (s : Finset Î±), a âˆ‰ s â†’ motive s â†’ motive (insert a s)) (s : Finset Î±) : motive s" title="Finset.induction.{u_3} {Î± : Type u_3} {motive : Finset Î± â†’ Prop} [DecidableEq Î±] (empty : motive âˆ…)
  (insert : âˆ€ (a : Î±) (s : Finset Î±), a âˆ‰ s â†’ motive s â†’ motive (insert a s)) (s : Finset Î±) : motive s">Finset.induction</span> <span class="lean-keyword" data-docs="After `with`, there is an optional tactic that runs on all branches, and
then a list of alternatives.
" title="After `with`, there is an optional tactic that runs on all branches, and">with</span>
  | <span class="lean-const" data-name="Finset.empty" data-signature="Finset.empty.{u_1} {Î± : Type u_1} : Finset Î±" data-docs="The empty finset " title="Finset.empty.{u_1} {Î± : Type u_1} : Finset Î±
The empty finset ">empty</span> =&gt; <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Finset.prod_empty" data-signature="Finset.prod_empty.{u_1, u_3} {Î¹ : Type u_1} {M : Type u_3} {f : Î¹ â†’ M} [CommMonoid M] : âˆ x âˆˆ âˆ…, f x = 1" title="Finset.prod_empty.{u_1, u_3} {Î¹ : Type u_1} {M : Type u_3} {f : Î¹ â†’ M} [CommMonoid M] : âˆ x âˆˆ âˆ…, f x = 1">Finset.prod_empty</span>, <span class="lean-const" data-name="one_dvd" data-signature="one_dvd.{u_1} {Î± : Type u_1} [Monoid Î±] (a : Î±) : 1 âˆ£ a" title="one_dvd.{u_1} {Î± : Type u_1} [Monoid Î±] (a : Î±) : 1 âˆ£ a">one_dvd</span><span class="lean-bracket-1">]</span>
  | @insert <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">s</span> <span class="lean-var" data-type="d âˆ‰ s" title="d âˆ‰ s">hd_notin</span> <span class="lean-var" data-type="(âˆ€ d âˆˆ s, cyclotomic d â„š âˆ£ target) â†’ âˆ d âˆˆ s, cyclotomic d â„š âˆ£ target" title="(âˆ€ d âˆˆ s, cyclotomic d â„š âˆ£ target) â†’ âˆ d âˆˆ s, cyclotomic d â„š âˆ£ target">IH</span> =&gt;
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Finset.prod_insert" data-signature="Finset.prod_insert.{u_1, u_4} {Î¹ : Type u_1} {M : Type u_4} {s : Finset Î¹} {a : Î¹} [CommMonoid M] {f : Î¹ â†’ M}
  [DecidableEq Î¹] : a âˆ‰ s â†’ âˆ x âˆˆ insert a s, f x = f a * âˆ x âˆˆ s, f x" title="Finset.prod_insert.{u_1, u_4} {Î¹ : Type u_1} {M : Type u_4} {s : Finset Î¹} {a : Î¹} [CommMonoid M] {f : Î¹ â†’ M}
  [DecidableEq Î¹] : a âˆ‰ s â†’ âˆ x âˆˆ insert a s, f x = f a * âˆ x âˆˆ s, f x">Finset.prod_insert</span> <span class="lean-var" data-type="d âˆ‰ s" title="d âˆ‰ s">hd_notin</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="cyclotomic d â„š âˆ£ target" title="cyclotomic d â„š âˆ£ target">hdvd_d</span> : <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š âˆ£ <span class="lean-var" data-type="â„š[X]" title="â„š[X]">target</span> := <span class="lean-var" data-type="âˆ€ d_1 âˆˆ insert d s, cyclotomic d_1 â„š âˆ£ target" title="âˆ€ d_1 âˆˆ insert d s, cyclotomic d_1 â„š âˆ£ target">hdvd_each</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_insert_self" data-signature="Finset.mem_insert_self.{u_1} {Î± : Type u_1} [DecidableEq Î±] (a : Î±) (s : Finset Î±) : a âˆˆ insert a s" title="Finset.mem_insert_self.{u_1} {Î± : Type u_1} [DecidableEq Î±] (a : Î±) (s : Finset Î±) : a âˆˆ insert a s">Finset.mem_insert_self</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">s</span><span class="lean-bracket-1">)</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="âˆ x âˆˆ s, cyclotomic x â„š âˆ£ target" title="âˆ x âˆˆ s, cyclotomic x â„š âˆ£ target">hdvd_prod</span> : <span class="lean-bracket-1">(</span><span class="lean-operator">âˆ</span> <span class="lean-var" data-type="â„•" title="â„•">x</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">s</span>, <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">x</span> â„š<span class="lean-bracket-1">)</span> âˆ£ <span class="lean-var" data-type="â„š[X]" title="â„š[X]">target</span> :=
        <span class="lean-var" data-type="(âˆ€ d âˆˆ s, cyclotomic d â„š âˆ£ target) â†’ âˆ d âˆˆ s, cyclotomic d â„š âˆ£ target" title="(âˆ€ d âˆˆ s, cyclotomic d â„š âˆ£ target) â†’ âˆ d âˆˆ s, cyclotomic d â„š âˆ£ target">IH</span> <span class="lean-bracket-1">(</span><span class="lean-keyword">fun</span> <span class="lean-var" data-type="â„•" title="â„•">x</span> <span class="lean-var" data-type="x âˆˆ s" title="x âˆˆ s">hx</span> =&gt; <span class="lean-var" data-type="âˆ€ d_1 âˆˆ insert d s, cyclotomic d_1 â„š âˆ£ target" title="âˆ€ d_1 âˆˆ insert d s, cyclotomic d_1 â„š âˆ£ target">hdvd_each</span> <span class="lean-var" data-type="â„•" title="â„•">x</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Finset.mem_insert_of_mem" data-signature="Finset.mem_insert_of_mem.{u_1} {Î± : Type u_1} [DecidableEq Î±] {s : Finset Î±} {a b : Î±} (h : a âˆˆ s) : a âˆˆ insert b s" title="Finset.mem_insert_of_mem.{u_1} {Î± : Type u_1} [DecidableEq Î±] {s : Finset Î±} {a b : Î±} (h : a âˆˆ s) : a âˆˆ insert b s">Finset.mem_insert_of_mem</span> <span class="lean-var" data-type="x âˆˆ s" title="x âˆˆ s">hx</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="IsCoprime (cyclotomic d â„š) (âˆ x âˆˆ s, cyclotomic x â„š)" title="IsCoprime (cyclotomic d â„š) (âˆ x âˆˆ s, cyclotomic x â„š)">hcop</span> : <span class="lean-const" data-name="IsCoprime" data-signature="IsCoprime.{u} {R : Type u} [CommSemiring R] (x y : R) : Prop" data-docs="The proposition that `x` and `y` are coprime, defined to be the existence of `a` and `b` such
that `a * x + b * y = 1`. Note that elements with no common divisors are not necessarily coprime,
e.g., the multivariate polynomials `xâ‚` and `xâ‚‚` are not coprime. " title="IsCoprime.{u} {R : Type u} [CommSemiring R] (x y : R) : Prop
The proposition that `x` and `y` are coprime, defined to be the existence of `a` and `b` such...">IsCoprime</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-operator">âˆ</span> <span class="lean-var" data-type="â„•" title="â„•">x</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">s</span>, <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">x</span> â„š<span class="lean-bracket-1">)</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
      <span class="lean-keyword" data-docs="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.
" title="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.">apply</span> <span class="lean-const" data-name="IsCoprime.prod_right" data-signature="IsCoprime.prod_right.{u, v} {R : Type u} {I : Type v} [CommSemiring R] {x : R} {s : I â†’ R} {t : Finset I} :
  (âˆ€ i âˆˆ t, IsCoprime x (s i)) â†’ IsCoprime x (âˆ i âˆˆ t, s i)" title="IsCoprime.prod_right.{u, v} {R : Type u} {I : Type v} [CommSemiring R] {x : R} {s : I â†’ R} {t : Finset I} :
  (âˆ€ i âˆˆ t, IsCoprime x (s i)) â†’ IsCoprime x (âˆ i âˆˆ t, s i)">IsCoprime.prod_right</span>
      <span class="lean-keyword" data-docs="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal&#x27;s target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`. It is equivalent to `intro _`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, given a type ascription, or matched against a pattern:
  ```lean
  -- ... âŠ¢ Î± Ã— Î² â†’ ...
  intro (a, b)
  -- ..., a : Î±, b : Î² âŠ¢ ...
  ```
* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side
  is a variable.
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
" title="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.">intro</span> <span class="lean-var" data-type="â„•" title="â„•">x</span> <span class="lean-var" data-type="x âˆˆ s" title="x âˆˆ s">hx</span>
      <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Polynomial.cyclotomic.isCoprime_rat" data-signature="Polynomial.cyclotomic.isCoprime_rat {n m : â„•} (h : n â‰  m) : IsCoprime (cyclotomic n â„š) (cyclotomic m â„š)" data-docs="If `n â‰  m`, then `(cyclotomic n â„š)` and `(cyclotomic m â„š)` are coprime. " title="Polynomial.cyclotomic.isCoprime_rat {n m : â„•} (h : n â‰  m) : IsCoprime (cyclotomic n â„š) (cyclotomic m â„š)
If `n â‰  m`, then `(cyclotomic n â„š)` and `(cyclotomic m â„š)` are coprime. ">cyclotomic.isCoprime_rat</span> <span class="lean-bracket-1">(</span><span class="lean-keyword">fun</span> <span class="lean-var" data-type="d = x" title="d = x">heq</span> =&gt; <span class="lean-var" data-type="d âˆ‰ s" title="d âˆ‰ s">hd_notin</span> <span class="lean-bracket-2">(</span><span class="lean-var" data-type="d = x" title="d = x">heq</span> â–¸ <span class="lean-var" data-type="x âˆˆ s" title="x âˆˆ s">hx</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span>
    <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-var" data-type="IsCoprime (cyclotomic d â„š) (âˆ x âˆˆ s, cyclotomic x â„š)" title="IsCoprime (cyclotomic d â„š) (âˆ x âˆˆ s, cyclotomic x â„š)">hcop</span>.<span class="lean-const" data-name="IsCoprime.mul_dvd" data-signature="IsCoprime.mul_dvd.{u} {R : Type u} [CommSemiring R] {x y z : R} (H : IsCoprime x y) (H1 : x âˆ£ z) (H2 : y âˆ£ z) :
  x * y âˆ£ z" title="IsCoprime.mul_dvd.{u} {R : Type u} [CommSemiring R] {x y z : R} (H : IsCoprime x y) (H1 : x âˆ£ z) (H2 : y âˆ£ z) :
  x * y âˆ£ z">mul_dvd</span> <span class="lean-var" data-type="cyclotomic d â„š âˆ£ target" title="cyclotomic d â„š âˆ£ target">hdvd_d</span> <span class="lean-var" data-type="âˆ x âˆˆ s, cyclotomic x â„š âˆ£ target" title="âˆ x âˆˆ s, cyclotomic x â„š âˆ£ target">hdvd_prod</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Forward.lean#L93-L115" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:cyclotomic-finset-product-dvd');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:minpoly-dvd-prod-cyclotomic">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.4</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:minpoly-dvd-prod-cyclotomic">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000047"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0005.html#lem:cyclotomic-finset-product-dvd">Theorem 5.0.3</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.minpoly_dvd_prod_cyclotomic_of_dvd_X_pow_sub_one" class="lean_decl">Crystallographic.minpoly_dvd_prod_cyclotomic_of_dvd_X_pow_sub_one</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       If \(\mu _A \mid X^m - 1\) and \(S = \{ d \mid m : \Phi _d \mid \mu _A\} \), then \(\mu _A \mid \prod _{d \in S} \Phi _d\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000047">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p>Split \(X^m - 1 = (\prod _{d \in S} \Phi _d) \cdot (\prod _{d \notin S} \Phi _d)\). Since \(\Phi _d\) is irreducible and does not divide \(\mu _A\) for \(d \notin S\), we have \(\gcd (\mu _A, \Phi _d) = 1\). Thus \(\mu _A\) is coprime to \(\prod _{d \notin S} \Phi _d\). Since \(\mu _A \mid X^m - 1\), it must divide \(\prod _{d \in S} \Phi _d\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Crystallographic.minpoly_dvd_prod_cyclotomic_of_dvd_X_pow_sub_one" data-signature="Crystallographic.minpoly_dvd_prod_cyclotomic_of_dvd_X_pow_sub_one {N : â„•} [NeZero N] (A : Matrix (Fin N) (Fin N) â„¤)
  (m : â„•) (hm : 0 &lt; m) (S : Finset â„•) (hS_sub : S âŠ† m.divisors)
  (hS_def : âˆ€ d âˆˆ m.divisors, d âˆˆ S â†” cyclotomic d â„š âˆ£ minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)))
  (hminpoly_dvd : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1) :
  minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ âˆ d âˆˆ S, cyclotomic d â„š" data-docs="If the minimal polynomial divides X^m - 1, then it divides the product of cyclotomic
polynomials for divisors d where Î¦_d divides the minimal polynomial.

The proof uses coprimality: minpoly is coprime to Î¦_d when Î¦_d does not divide it
(since Î¦_d is irreducible), hence minpoly is coprime to the product of such Î¦_d.
Since X^m - 1 = (âˆ_{dâˆˆS} Î¦_d) * (âˆ_{dâˆ‰S} Î¦_d) and minpoly divides the LHS while
being coprime to the second factor, it must divide the first factor. " title="Crystallographic.minpoly_dvd_prod_cyclotomic_of_dvd_X_pow_sub_one {N : â„•} [NeZero N] (A : Matrix (Fin N) (Fin N) â„¤)
  (m : â„•) (hm : 0 &lt; m) (S : Finset â„•) (hS_sub : S âŠ† m.divisors)
  (hS_def : âˆ€ d âˆˆ m.divisors, d âˆˆ S â†” cyclotomic d â„š âˆ£ minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)))
  (hminpoly_dvd : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1) :
  minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ âˆ d âˆˆ S, cyclotomic d â„š
If the minimal polynomial divides X^m - 1, then it divides the product of cyclotomic...">minpoly_dvd_prod_cyclotomic_of_dvd_X_pow_sub_one</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="â„•" title="â„•">N</span> : â„•<span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="NeZero" data-signature="NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop" data-docs="A type-class version of `n â‰  0`.  " title="NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop
A type-class version of `n â‰  0`.  ">NeZero</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-1">]</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> : <span class="lean-const" data-name="Matrix" data-signature="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (Î± : Type v) : Type (max u u&#x27; v)" data-docs="`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`
and whose columns are indexed by `n`. " title="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (Î± : Type v) : Type (max u u&#x27; v)
`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`...">Matrix</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : â„•) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : â„•) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : â„•) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : â„•) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-2">)</span> â„¤<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">m</span> : â„•<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span> : <span class="lean-expr" data-type="â„•" title="â„•">0</span> &lt; <span class="lean-var" data-type="â„•" title="â„•">m</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> : <span class="lean-const" data-name="Finset" data-signature="Finset.{u_4} (Î± : Type u_4) : Type u_4" data-docs="`Finset Î±` is the type of finite sets of elements of `Î±`. It is implemented
as a multiset (a list up to permutation) which has no duplicate elements. " title="Finset.{u_4} (Î± : Type u_4) : Type u_4
`Finset Î±` is the type of finite sets of elements of `Î±`. It is implemented...">Finset</span> â„•<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="S âŠ† m.divisors" title="S âŠ† m.divisors">hS_sub</span> : <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> <span class="lean-operator">âŠ†</span> <span class="lean-var" data-type="â„•" title="â„•">m</span>.<span class="lean-const" data-name="Nat.divisors" data-signature="Nat.divisors (n : â„•) : Finset â„•" data-docs="`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. " title="Nat.divisors (n : â„•) : Finset â„•
`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. ">divisors</span><span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="âˆ€ d âˆˆ m.divisors, d âˆˆ S â†” cyclotomic d â„š âˆ£ minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š))" title="âˆ€ d âˆˆ m.divisors, d âˆˆ S â†” cyclotomic d â„š âˆ£ minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š))">hS_def</span> : <span class="lean-operator">âˆ€</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="â„•" title="â„•">m</span>.<span class="lean-const" data-name="Nat.divisors" data-signature="Nat.divisors (n : â„•) : Finset â„•" data-docs="`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. " title="Nat.divisors (n : â„•) : Finset â„•
`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. ">divisors</span>, <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> <span class="lean-operator">â†”</span> <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š âˆ£ <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-bracket-2">(</span><span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-3">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-3">)</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1" title="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1">hminpoly_dvd</span> : <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-bracket-2">(</span><span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-3">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-3">)</span><span class="lean-bracket-2">)</span> âˆ£ <span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-var" data-type="â„•" title="â„•">m</span> - <span class="lean-expr" data-type="â„š[X]" title="â„š[X]">1</span><span class="lean-bracket-1">)</span> :
    <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span> âˆ£ <span class="lean-operator">âˆ</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>, <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="The `let` tactic is for adding definitions to the local context of the main goal.
The definition can be unfolded, unlike definitions introduced by `have`.

* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.
* `let x := e` uses the type of `e` for `t`.
* `let : t := e` and `let := e` use `this` for the name of the hypothesis.
* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that let only one applicable constructor.
  For example, given `p : Î± Ã— Î² Ã— Î³`, `let âŸ¨x, y, zâŸ© := p` produces the
  local variables `x : Î±`, `y : Î²`, and `z : Î³`.
* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `let` term.

## Properties and relations

* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics
  such as `simp`, `dsimp`, `unfold`, and `subst`.
* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.
  The tactic might fail if the local context depends on the value of the variable.
* The `let` tactic is preferred for data (non-propositions).
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
" title="The `let` tactic is for adding definitions to the local context of the main goal.">let</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span> := <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-1">)</span>
  <span class="lean-comment">-- Key: </span><span class="lean-bracket-1">{</span>x <span class="lean-operator">âˆˆ</span> m.divisors | x <span class="lean-operator">âˆˆ</span> S<span class="lean-bracket-1">}</span> = S since S <span class="lean-operator">âŠ†</span> m.divisors
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="{x âˆˆ m.divisors | x âˆˆ S} = S" title="{x âˆˆ m.divisors | x âˆˆ S} = S">hS_eq</span> : <span class="lean-var" data-type="â„•" title="â„•">m</span>.<span class="lean-const" data-name="Nat.divisors" data-signature="Nat.divisors (n : â„•) : Finset â„•" data-docs="`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. " title="Nat.divisors (n : â„•) : Finset â„•
`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. ">divisors</span>.<span class="lean-const" data-name="Finset.filter" data-signature="Finset.filter.{u_1} {Î± : Type u_1} (p : Î± â†’ Prop) [DecidablePred p] (s : Finset Î±) : Finset Î±" data-docs="`Finset.filter p s` is the set of elements of `s` that satisfy `p`.

For example, one can use `s.filter (Â· âˆˆ t)` to get the intersection of `s` with `t : Set Î±`
as a `Finset Î±` (when a `DecidablePred (Â· âˆˆ t)` instance is available). " title="Finset.filter.{u_1} {Î± : Type u_1} (p : Î± â†’ Prop) [DecidablePred p] (s : Finset Î±) : Finset Î±
`Finset.filter p s` is the set of elements of `s` that satisfy `p`....">filter</span> <span class="lean-bracket-1">(</span><span class="lean-operator">Â·</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span><span class="lean-bracket-1">)</span> = <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
    <span class="lean-keyword" data-docs="Applies extensionality lemmas that are registered with the `@[ext]` attribute.
* `ext pat*` applies extensionality theorems as much as possible,
  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.
  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.
* Without patterns,`ext` applies extensionality lemmas as much
  as possible but introduces anonymous hypotheses whenever needed.
* `ext pat* : n` applies ext theorems only up to depth `n`.

The `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.

Unused patterns will generate warning.
Patterns that don&#x27;t match the variables will typically result in the introduction of anonymous hypotheses.
" title="Applies extensionality lemmas that are registered with the `@[ext]` attribute.">ext</span> <span class="lean-var" data-type="â„•" title="â„•">d</span>
    <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Finset.mem_filter" data-signature="Finset.mem_filter.{u_1} {Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} {a : Î±} :
  a âˆˆ Finset.filter p s â†” a âˆˆ s âˆ§ p a" title="Finset.mem_filter.{u_1} {Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} {a : Î±} :
  a âˆˆ Finset.filter p s â†” a âˆˆ s âˆ§ p a">Finset.mem_filter</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-signature="Iff.intro {a b : Prop} (mp : a â†’ b) (mpr : b â†’ a) : a â†” b" data-docs="If `a â†’ b` and `b â†’ a` then `a` and `b` are equivalent. " title="Iff.intro {a b : Prop} (mp : a â†’ b) (mpr : b â†’ a) : a â†” b">âŸ¨</span><span class="lean-keyword">fun</span> <span class="lean-bracket-1">âŸ¨</span>_, <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hd</span><span class="lean-bracket-1">âŸ©</span> =&gt; <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hd</span><span class="lean-const" data-signature="Iff.intro {a b : Prop} (mp : a â†’ b) (mpr : b â†’ a) : a â†” b" data-docs="If `a â†’ b` and `b â†’ a` then `a` and `b` are equivalent. " title="Iff.intro {a b : Prop} (mp : a â†’ b) (mpr : b â†’ a) : a â†” b">,</span> <span class="lean-keyword">fun</span> <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hd</span> =&gt; <span class="lean-const" data-signature="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b" data-docs="`And.intro : a â†’ b â†’ a âˆ§ b` is the constructor for the And operation. " title="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b">âŸ¨</span><span class="lean-var" data-type="S âŠ† m.divisors" title="S âŠ† m.divisors">hS_sub</span> <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hd</span><span class="lean-const" data-signature="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b" data-docs="`And.intro : a â†’ b â†’ a âˆ§ b` is the constructor for the And operation. " title="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b">,</span> <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hd</span><span class="lean-const" data-signature="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b" data-docs="`And.intro : a â†’ b â†’ a âˆ§ b` is the constructor for the And operation. " title="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b">âŸ©</span><span class="lean-const" data-signature="Iff.intro {a b : Prop} (mp : a â†’ b) (mpr : b â†’ a) : a â†” b" data-docs="If `a â†’ b` and `b â†’ a` then `a` and `b` are equivalent. " title="Iff.intro {a b : Prop} (mp : a â†’ b) (mpr : b â†’ a) : a â†” b">âŸ©</span>
  <span class="lean-comment">-- minpoly is coprime to the product of cyclotomics NOT in S</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="IsCoprime (minpoly â„š A_Q) (âˆ d âˆˆ m.divisors with d âˆ‰ S, cyclotomic d â„š)" title="IsCoprime (minpoly â„š A_Q) (âˆ d âˆˆ m.divisors with d âˆ‰ S, cyclotomic d â„š)">hcoprime_with_complement</span> : <span class="lean-const" data-name="IsCoprime" data-signature="IsCoprime.{u} {R : Type u} [CommSemiring R] (x y : R) : Prop" data-docs="The proposition that `x` and `y` are coprime, defined to be the existence of `a` and `b` such
that `a * x + b * y = 1`. Note that elements with no common divisors are not necessarily coprime,
e.g., the multivariate polynomials `xâ‚` and `xâ‚‚` are not coprime. " title="IsCoprime.{u} {R : Type u} [CommSemiring R] (x y : R) : Prop
The proposition that `x` and `y` are coprime, defined to be the existence of `a` and `b` such...">IsCoprime</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span><span class="lean-bracket-1">)</span>
      <span class="lean-bracket-1">(</span><span class="lean-operator">âˆ</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="â„•" title="â„•">m</span>.<span class="lean-const" data-name="Nat.divisors" data-signature="Nat.divisors (n : â„•) : Finset â„•" data-docs="`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. " title="Nat.divisors (n : â„•) : Finset â„•
`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. ">divisors</span>.<span class="lean-const" data-name="Finset.filter" data-signature="Finset.filter.{u_1} {Î± : Type u_1} (p : Î± â†’ Prop) [DecidablePred p] (s : Finset Î±) : Finset Î±" data-docs="`Finset.filter p s` is the set of elements of `s` that satisfy `p`.

For example, one can use `s.filter (Â· âˆˆ t)` to get the intersection of `s` with `t : Set Î±`
as a `Finset Î±` (when a `DecidablePred (Â· âˆˆ t)` instance is available). " title="Finset.filter.{u_1} {Î± : Type u_1} (p : Î± â†’ Prop) [DecidablePred p] (s : Finset Î±) : Finset Î±
`Finset.filter p s` is the set of elements of `s` that satisfy `p`....">filter</span> <span class="lean-bracket-2">(</span><span class="lean-operator">Â·</span> <span class="lean-operator">âˆ‰</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span><span class="lean-bracket-2">)</span>, <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š<span class="lean-bracket-1">)</span> :=
    <span class="lean-const" data-name="IsCoprime.prod_right" data-signature="IsCoprime.prod_right.{u, v} {R : Type u} {I : Type v} [CommSemiring R] {x : R} {s : I â†’ R} {t : Finset I} :
  (âˆ€ i âˆˆ t, IsCoprime x (s i)) â†’ IsCoprime x (âˆ i âˆˆ t, s i)" title="IsCoprime.prod_right.{u, v} {R : Type u} {I : Type v} [CommSemiring R] {x : R} {s : I â†’ R} {t : Finset I} :
  (âˆ€ i âˆˆ t, IsCoprime x (s i)) â†’ IsCoprime x (âˆ i âˆˆ t, s i)">IsCoprime.prod_right</span> <span class="lean-keyword">fun</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-var" data-type="d âˆˆ {x âˆˆ m.divisors | x âˆ‰ S}" title="d âˆˆ {x âˆˆ m.divisors | x âˆ‰ S}">hd</span> =&gt; <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="d âˆˆ m.divisors" title="d âˆˆ m.divisors">hd_div</span> := <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_filter" data-signature="Finset.mem_filter.{u_1} {Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} {a : Î±} :
  a âˆˆ Finset.filter p s â†” a âˆˆ s âˆ§ p a" title="Finset.mem_filter.{u_1} {Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} {a : Î±} :
  a âˆˆ Finset.filter p s â†” a âˆˆ s âˆ§ p a">Finset.mem_filter</span>.<span class="lean-const" data-name="Iff.mp" data-signature="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b" data-docs="Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. " title="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b
Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. ">mp</span> <span class="lean-var" data-type="d âˆˆ {x âˆˆ m.divisors | x âˆ‰ S}" title="d âˆˆ {x âˆˆ m.divisors | x âˆ‰ S}">hd</span><span class="lean-bracket-1">)</span>.<span class="lean-number">1</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="d âˆ‰ S" title="d âˆ‰ S">hd_not_in_S</span> := <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_filter" data-signature="Finset.mem_filter.{u_1} {Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} {a : Î±} :
  a âˆˆ Finset.filter p s â†” a âˆˆ s âˆ§ p a" title="Finset.mem_filter.{u_1} {Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} {a : Î±} :
  a âˆˆ Finset.filter p s â†” a âˆˆ s âˆ§ p a">Finset.mem_filter</span>.<span class="lean-const" data-name="Iff.mp" data-signature="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b" data-docs="Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. " title="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b
Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. ">mp</span> <span class="lean-var" data-type="d âˆˆ {x âˆˆ m.divisors | x âˆ‰ S}" title="d âˆˆ {x âˆˆ m.divisors | x âˆ‰ S}">hd</span><span class="lean-bracket-1">)</span>.<span class="lean-number">2</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="Â¬cyclotomic d â„š âˆ£ minpoly â„š A_Q" title="Â¬cyclotomic d â„š âˆ£ minpoly â„š A_Q">hndvd</span> : <span class="lean-operator">Â¬</span><span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š âˆ£ <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span> := <span class="lean-keyword">fun</span> <span class="lean-var" data-type="cyclotomic d â„š âˆ£ minpoly â„š A_Q" title="cyclotomic d â„š âˆ£ minpoly â„š A_Q">hdvd</span> =&gt;
        <span class="lean-var" data-type="d âˆ‰ S" title="d âˆ‰ S">hd_not_in_S</span> <span class="lean-bracket-1">(</span><span class="lean-bracket-2">(</span><span class="lean-var" data-type="âˆ€ d âˆˆ m.divisors, d âˆˆ S â†” cyclotomic d â„š âˆ£ minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š))" title="âˆ€ d âˆˆ m.divisors, d âˆˆ S â†” cyclotomic d â„š âˆ£ minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š))">hS_def</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-var" data-type="d âˆˆ m.divisors" title="d âˆˆ m.divisors">hd_div</span><span class="lean-bracket-2">)</span>.<span class="lean-const" data-name="Iff.mpr" data-signature="Iff.mpr {a b : Prop} (self : a â†” b) : b â†’ a" data-docs="Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. " title="Iff.mpr {a b : Prop} (self : a â†” b) : b â†’ a
Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. ">mpr</span> <span class="lean-var" data-type="cyclotomic d â„š âˆ£ minpoly â„š A_Q" title="cyclotomic d â„š âˆ£ minpoly â„š A_Q">hdvd</span><span class="lean-bracket-1">)</span>
      <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.cyclotomic_coprime_minpoly_of_not_mem" data-signature="Crystallographic.cyclotomic_coprime_minpoly_of_not_mem {N : â„•} [NeZero N] (A : Matrix (Fin N) (Fin N) â„¤) (d : â„•)
  (hd_pos : 0 &lt; d) (hndvd : Â¬cyclotomic d â„š âˆ£ minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š))) :
  IsCoprime (cyclotomic d â„š) (minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)))" data-docs="For a divisor d not in the cyclotomic divisor set S of the minimal polynomial,
the cyclotomic polynomial Î¦_d is coprime to the minimal polynomial. " title="Crystallographic.cyclotomic_coprime_minpoly_of_not_mem {N : â„•} [NeZero N] (A : Matrix (Fin N) (Fin N) â„¤) (d : â„•)
  (hd_pos : 0 &lt; d) (hndvd : Â¬cyclotomic d â„š âˆ£ minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š))) :
  IsCoprime (cyclotomic d â„š) (minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)))
For a divisor d not in the cyclotomic divisor set S of the minimal polynomial,...">cyclotomic_coprime_minpoly_of_not_mem</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Nat.pos_of_mem_divisors" data-signature="Nat.pos_of_mem_divisors {n m : â„•} (h : m âˆˆ n.divisors) : 0 &lt; m" title="Nat.pos_of_mem_divisors {n m : â„•} (h : m âˆˆ n.divisors) : 0 &lt; m">Nat.pos_of_mem_divisors</span> <span class="lean-var" data-type="d âˆˆ m.divisors" title="d âˆˆ m.divisors">hd_div</span><span class="lean-bracket-2">)</span> <span class="lean-var" data-type="Â¬cyclotomic d â„š âˆ£ minpoly â„š A_Q" title="Â¬cyclotomic d â„š âˆ£ minpoly â„š A_Q">hndvd</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="IsCoprime.symm" data-signature="IsCoprime.symm.{u} {R : Type u} [CommSemiring R] {x y : R} (H : IsCoprime x y) : IsCoprime y x" title="IsCoprime.symm.{u} {R : Type u} [CommSemiring R] {x y : R} (H : IsCoprime x y) : IsCoprime y x">symm</span>
  <span class="lean-comment">-- Split X^m - <span class="lean-number">1</span> = </span><span class="lean-bracket-1">(</span><span class="lean-operator">âˆ</span>_<span class="lean-bracket-2">{</span>d<span class="lean-operator">âˆˆ</span>S<span class="lean-bracket-2">}</span> Î¦_d<span class="lean-bracket-1">)</span> * <span class="lean-bracket-1">(</span><span class="lean-operator">âˆ</span>_<span class="lean-bracket-2">{</span>d<span class="lean-operator">âˆ‰</span>S<span class="lean-bracket-2">}</span> Î¦_d<span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="âˆ d âˆˆ m.divisors, cyclotomic d â„š = (âˆ d âˆˆ S, cyclotomic d â„š) * âˆ d âˆˆ m.divisors with d âˆ‰ S, cyclotomic d â„š" title="âˆ d âˆˆ m.divisors, cyclotomic d â„š = (âˆ d âˆˆ S, cyclotomic d â„š) * âˆ d âˆˆ m.divisors with d âˆ‰ S, cyclotomic d â„š">hprod_split</span> : <span class="lean-operator">âˆ</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="â„•" title="â„•">m</span>.<span class="lean-const" data-name="Nat.divisors" data-signature="Nat.divisors (n : â„•) : Finset â„•" data-docs="`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. " title="Nat.divisors (n : â„•) : Finset â„•
`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. ">divisors</span>, <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š =
      <span class="lean-bracket-1">(</span><span class="lean-operator">âˆ</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>, <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š<span class="lean-bracket-1">)</span> * <span class="lean-bracket-1">(</span><span class="lean-operator">âˆ</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="â„•" title="â„•">m</span>.<span class="lean-const" data-name="Nat.divisors" data-signature="Nat.divisors (n : â„•) : Finset â„•" data-docs="`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. " title="Nat.divisors (n : â„•) : Finset â„•
`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. ">divisors</span>.<span class="lean-const" data-name="Finset.filter" data-signature="Finset.filter.{u_1} {Î± : Type u_1} (p : Î± â†’ Prop) [DecidablePred p] (s : Finset Î±) : Finset Î±" data-docs="`Finset.filter p s` is the set of elements of `s` that satisfy `p`.

For example, one can use `s.filter (Â· âˆˆ t)` to get the intersection of `s` with `t : Set Î±`
as a `Finset Î±` (when a `DecidablePred (Â· âˆˆ t)` instance is available). " title="Finset.filter.{u_1} {Î± : Type u_1} (p : Î± â†’ Prop) [DecidablePred p] (s : Finset Î±) : Finset Î±
`Finset.filter p s` is the set of elements of `s` that satisfy `p`....">filter</span> <span class="lean-bracket-2">(</span><span class="lean-operator">Â·</span> <span class="lean-operator">âˆ‰</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span><span class="lean-bracket-2">)</span>, <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š<span class="lean-bracket-1">)</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-operator">â†</span> <span class="lean-const" data-name="Finset.prod_filter_mul_prod_filter_not" data-signature="Finset.prod_filter_mul_prod_filter_not.{u_1, u_4} {Î¹ : Type u_1} {M : Type u_4} [CommMonoid M] (s : Finset Î¹)
  (p : Î¹ â†’ Prop) [DecidablePred p] [(x : Î¹) â†’ Decidable Â¬p x] (f : Î¹ â†’ M) :
  (âˆ x âˆˆ s with p x, f x) * âˆ x âˆˆ s with Â¬p x, f x = âˆ x âˆˆ s, f x" title="Finset.prod_filter_mul_prod_filter_not.{u_1, u_4} {Î¹ : Type u_1} {M : Type u_4} [CommMonoid M] (s : Finset Î¹)
  (p : Î¹ â†’ Prop) [DecidablePred p] [(x : Î¹) â†’ Decidable Â¬p x] (f : Î¹ â†’ M) :
  (âˆ x âˆˆ s with p x, f x) * âˆ x âˆˆ s with Â¬p x, f x = âˆ x âˆˆ s, f x">Finset.prod_filter_mul_prod_filter_not</span> <span class="lean-var" data-type="â„•" title="â„•">m</span>.<span class="lean-const" data-name="Nat.divisors" data-signature="Nat.divisors (n : â„•) : Finset â„•" data-docs="`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. " title="Nat.divisors (n : â„•) : Finset â„•
`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. ">divisors</span> <span class="lean-bracket-2">(</span><span class="lean-operator">Â·</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span><span class="lean-bracket-2">)</span>, <span class="lean-var" data-type="{x âˆˆ m.divisors | x âˆˆ S} = S" title="{x âˆˆ m.divisors | x âˆˆ S} = S">hS_eq</span><span class="lean-bracket-1">]</span>
  <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-operator">â†</span> <span class="lean-const" data-name="Polynomial.prod_cyclotomic_eq_X_pow_sub_one" data-signature="Polynomial.prod_cyclotomic_eq_X_pow_sub_one.{u_1} {n : â„•} (hpos : 0 &lt; n) (R : Type u_1) [CommRing R] :
  âˆ i âˆˆ n.divisors, cyclotomic i R = X ^ n - 1" data-docs="`âˆ i âˆˆ Nat.divisors n, cyclotomic i R = X ^ n - 1`. " title="Polynomial.prod_cyclotomic_eq_X_pow_sub_one.{u_1} {n : â„•} (hpos : 0 &lt; n) (R : Type u_1) [CommRing R] :
  âˆ i âˆˆ n.divisors, cyclotomic i R = X ^ n - 1
`âˆ i âˆˆ Nat.divisors n, cyclotomic i R = X ^ n - 1`. ">prod_cyclotomic_eq_X_pow_sub_one</span> <span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span>, <span class="lean-var" data-type="âˆ d âˆˆ m.divisors, cyclotomic d â„š = (âˆ d âˆˆ S, cyclotomic d â„š) * âˆ d âˆˆ m.divisors with d âˆ‰ S, cyclotomic d â„š" title="âˆ d âˆˆ m.divisors, cyclotomic d â„š = (âˆ d âˆˆ S, cyclotomic d â„š) * âˆ d âˆˆ m.divisors with d âˆ‰ S, cyclotomic d â„š">hprod_split</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`
* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1" title="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1">hminpoly_dvd</span>
  <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-var" data-type="IsCoprime (minpoly â„š A_Q) (âˆ d âˆˆ m.divisors with d âˆ‰ S, cyclotomic d â„š)" title="IsCoprime (minpoly â„š A_Q) (âˆ d âˆˆ m.divisors with d âˆ‰ S, cyclotomic d â„š)">hcoprime_with_complement</span>.<span class="lean-const" data-name="IsCoprime.dvd_of_dvd_mul_right" data-signature="IsCoprime.dvd_of_dvd_mul_right.{u} {R : Type u} [CommSemiring R] {x y z : R} (H1 : IsCoprime x z) (H2 : x âˆ£ y * z) :
  x âˆ£ y" title="IsCoprime.dvd_of_dvd_mul_right.{u} {R : Type u} [CommSemiring R] {x y z : R} (H1 : IsCoprime x z) (H2 : x âˆ£ y * z) :
  x âˆ£ y">dvd_of_dvd_mul_right</span> <span class="lean-var" data-type="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ (âˆ d âˆˆ S, cyclotomic d â„š) * âˆ d âˆˆ m.divisors with d âˆ‰ S, cyclotomic d â„š" title="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ (âˆ d âˆˆ S, cyclotomic d â„š) * âˆ d âˆˆ m.divisors with d âˆ‰ S, cyclotomic d â„š">hminpoly_dvd</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Forward.lean#L125-L165" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:minpoly-dvd-prod-cyclotomic');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:minpoly-eq-prod-cyclotomic">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.5</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:minpoly-eq-prod-cyclotomic">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000048"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0005.html#lem:minpoly-dvd-prod-cyclotomic">Theorem 5.0.4</a></li>
          
          <li><a href="sect0005.html#lem:cyclotomic-finset-product-dvd">Theorem 5.0.3</a></li>
          
          <li><a href="sect0005.html#lem:cyclotomic-finset-product-dvd">Theorem 5.0.3</a></li>
          
          <li><a href="sect0005.html#lem:minpoly-dvd-prod-cyclotomic">Theorem 5.0.4</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.minpoly_eq_prod_cyclotomic_of_dvd_X_pow_sub_one" class="lean_decl">Crystallographic.minpoly_eq_prod_cyclotomic_of_dvd_X_pow_sub_one</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       If \(\mu _A \mid X^m - 1\), then there exists \(S \subseteq \mathrm{divisors}(m)\) such that \(\mu _A = \prod _{d \in S} \Phi _d\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000048">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p> Let \(S = \{ d \mid m : \Phi _d \mid \mu _A\} \). By the previous lemma, \(\mu _A \mid \prod _{d \in S} \Phi _d\). Conversely, by definition of \(S\), each \(\Phi _d\) for \(d \in S\) divides \(\mu _A\), so their coprime product divides \(\mu _A\). Mutual divisibility of monic polynomials implies equality. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Crystallographic.minpoly_eq_prod_cyclotomic_of_dvd_X_pow_sub_one" data-signature="Crystallographic.minpoly_eq_prod_cyclotomic_of_dvd_X_pow_sub_one {N : â„•} [NeZero N] (A : Matrix (Fin N) (Fin N) â„¤)
  (m : â„•) (hm : 0 &lt; m) (hminpoly_dvd : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1) :
  âˆƒ S, (âˆ€ d âˆˆ S, d âˆ£ m) âˆ§ minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š" data-docs="For a polynomial that divides X^m - 1, we can characterize it as a product of cyclotomic
polynomials. Specifically, S = {d âˆˆ divisors(m) | Î¦_d âˆ£ p} gives minpoly = âˆ_{dâˆˆS} Î¦_d
when p is monic and irreducible factors are coprime. " title="Crystallographic.minpoly_eq_prod_cyclotomic_of_dvd_X_pow_sub_one {N : â„•} [NeZero N] (A : Matrix (Fin N) (Fin N) â„¤)
  (m : â„•) (hm : 0 &lt; m) (hminpoly_dvd : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1) :
  âˆƒ S, (âˆ€ d âˆˆ S, d âˆ£ m) âˆ§ minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š
For a polynomial that divides X^m - 1, we can characterize it as a product of cyclotomic...">minpoly_eq_prod_cyclotomic_of_dvd_X_pow_sub_one</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="â„•" title="â„•">N</span> : â„•<span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="NeZero" data-signature="NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop" data-docs="A type-class version of `n â‰  0`.  " title="NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop
A type-class version of `n â‰  0`.  ">NeZero</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-1">]</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> : <span class="lean-const" data-name="Matrix" data-signature="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (Î± : Type v) : Type (max u u&#x27; v)" data-docs="`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`
and whose columns are indexed by `n`. " title="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (Î± : Type v) : Type (max u u&#x27; v)
`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`...">Matrix</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : â„•) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : â„•) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : â„•) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : â„•) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-2">)</span> â„¤<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">m</span> : â„•<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span> : <span class="lean-expr" data-type="â„•" title="â„•">0</span> &lt; <span class="lean-var" data-type="â„•" title="â„•">m</span><span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1" title="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1">hminpoly_dvd</span> : <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-bracket-2">(</span><span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-3">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-3">)</span><span class="lean-bracket-2">)</span> âˆ£ <span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-var" data-type="â„•" title="â„•">m</span> - <span class="lean-expr" data-type="â„š[X]" title="â„š[X]">1</span><span class="lean-bracket-1">)</span> :
    <span class="lean-operator">âˆƒ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> : <span class="lean-const" data-name="Finset" data-signature="Finset.{u_4} (Î± : Type u_4) : Type u_4" data-docs="`Finset Î±` is the type of finite sets of elements of `Î±`. It is implemented
as a multiset (a list up to permutation) which has no duplicate elements. " title="Finset.{u_4} (Î± : Type u_4) : Type u_4
`Finset Î±` is the type of finite sets of elements of `Î±`. It is implemented...">Finset</span> â„•, <span class="lean-bracket-1">(</span><span class="lean-operator">âˆ€</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>, <span class="lean-var" data-type="â„•" title="â„•">d</span> âˆ£ <span class="lean-var" data-type="â„•" title="â„•">m</span><span class="lean-bracket-1">)</span> <span class="lean-operator">âˆ§</span>
      <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span> = <span class="lean-operator">âˆ</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>, <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="`classical tacs` runs `tacs` in a scope where `Classical.propDecidable` is a low priority
local instance.

Note that `classical` is a scoping tactic: it adds the instance only within the
scope of the tactic.
" title="`classical tacs` runs `tacs` in a scope where `Classical.propDecidable` is a low priority">classical</span>
  <span class="lean-keyword" data-docs="The `let` tactic is for adding definitions to the local context of the main goal.
The definition can be unfolded, unlike definitions introduced by `have`.

* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.
* `let x := e` uses the type of `e` for `t`.
* `let : t := e` and `let := e` use `this` for the name of the hypothesis.
* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that let only one applicable constructor.
  For example, given `p : Î± Ã— Î² Ã— Î³`, `let âŸ¨x, y, zâŸ© := p` produces the
  local variables `x : Î±`, `y : Î²`, and `z : Î³`.
* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `let` term.

## Properties and relations

* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics
  such as `simp`, `dsimp`, `unfold`, and `subst`.
* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.
  The tactic might fail if the local context depends on the value of the variable.
* The `let` tactic is preferred for data (non-propositions).
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
" title="The `let` tactic is for adding definitions to the local context of the main goal.">let</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span> := <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="The `let` tactic is for adding definitions to the local context of the main goal.
The definition can be unfolded, unlike definitions introduced by `have`.

* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.
* `let x := e` uses the type of `e` for `t`.
* `let : t := e` and `let := e` use `this` for the name of the hypothesis.
* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that let only one applicable constructor.
  For example, given `p : Î± Ã— Î² Ã— Î³`, `let âŸ¨x, y, zâŸ© := p` produces the
  local variables `x : Î±`, `y : Î²`, and `z : Î³`.
* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `let` term.

## Properties and relations

* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics
  such as `simp`, `dsimp`, `unfold`, and `subst`.
* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.
  The tactic might fail if the local context depends on the value of the variable.
* The `let` tactic is preferred for data (non-propositions).
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
" title="The `let` tactic is for adding definitions to the local context of the main goal.">let</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> := <span class="lean-var" data-type="â„•" title="â„•">m</span>.<span class="lean-const" data-name="Nat.divisors" data-signature="Nat.divisors (n : â„•) : Finset â„•" data-docs="`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. " title="Nat.divisors (n : â„•) : Finset â„•
`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. ">divisors</span>.<span class="lean-const" data-name="Finset.filter" data-signature="Finset.filter.{u_1} {Î± : Type u_1} (p : Î± â†’ Prop) [DecidablePred p] (s : Finset Î±) : Finset Î±" data-docs="`Finset.filter p s` is the set of elements of `s` that satisfy `p`.

For example, one can use `s.filter (Â· âˆˆ t)` to get the intersection of `s` with `t : Set Î±`
as a `Finset Î±` (when a `DecidablePred (Â· âˆˆ t)` instance is available). " title="Finset.filter.{u_1} {Î± : Type u_1} (p : Î± â†’ Prop) [DecidablePred p] (s : Finset Î±) : Finset Î±
`Finset.filter p s` is the set of elements of `s` that satisfy `p`....">filter</span> <span class="lean-bracket-1">(</span><span class="lean-keyword">fun</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> =&gt; <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š âˆ£ <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span><span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="S âŠ† m.divisors" title="S âŠ† m.divisors">hS_sub</span> : <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> <span class="lean-operator">âŠ†</span> <span class="lean-var" data-type="â„•" title="â„•">m</span>.<span class="lean-const" data-name="Nat.divisors" data-signature="Nat.divisors (n : â„•) : Finset â„•" data-docs="`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. " title="Nat.divisors (n : â„•) : Finset â„•
`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. ">divisors</span> := <span class="lean-const" data-name="Finset.filter_subset" data-signature="Finset.filter_subset.{u_1} {Î± : Type u_1} (p : Î± â†’ Prop) [DecidablePred p] (s : Finset Î±) : Finset.filter p s âŠ† s" title="Finset.filter_subset.{u_1} {Î± : Type u_1} (p : Î± â†’ Prop) [DecidablePred p] (s : Finset Î±) : Finset.filter p s âŠ† s">Finset.filter_subset</span> _ _
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="âˆ€ d âˆˆ S, d âˆ£ m" title="âˆ€ d âˆˆ S, d âˆ£ m">hS_dvd</span> : <span class="lean-operator">âˆ€</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>, <span class="lean-var" data-type="â„•" title="â„•">d</span> âˆ£ <span class="lean-var" data-type="â„•" title="â„•">m</span> := <span class="lean-keyword">fun</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hd</span> =&gt;
    <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Nat.mem_divisors" data-signature="Nat.mem_divisors {n m : â„•} : n âˆˆ m.divisors â†” n âˆ£ m âˆ§ m â‰  0" title="Nat.mem_divisors {n m : â„•} : n âˆˆ m.divisors â†” n âˆ£ m âˆ§ m â‰  0">Nat.mem_divisors</span>.<span class="lean-const" data-name="Iff.mp" data-signature="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b" data-docs="Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. " title="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b
Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. ">mp</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Finset.mem_filter" data-signature="Finset.mem_filter.{u_1} {Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} {a : Î±} :
  a âˆˆ Finset.filter p s â†” a âˆˆ s âˆ§ p a" title="Finset.mem_filter.{u_1} {Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} {a : Î±} :
  a âˆˆ Finset.filter p s â†” a âˆˆ s âˆ§ p a">Finset.mem_filter</span>.<span class="lean-const" data-name="Iff.mp" data-signature="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b" data-docs="Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. " title="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b
Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. ">mp</span> <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hd</span><span class="lean-bracket-2">)</span>.<span class="lean-number">1</span><span class="lean-bracket-1">)</span>.<span class="lean-number">1</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="âˆ€ d âˆˆ m.divisors, d âˆˆ S â†” cyclotomic d â„š âˆ£ minpoly â„š A_Q" title="âˆ€ d âˆˆ m.divisors, d âˆˆ S â†” cyclotomic d â„š âˆ£ minpoly â„š A_Q">hS_def</span> : <span class="lean-operator">âˆ€</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="â„•" title="â„•">m</span>.<span class="lean-const" data-name="Nat.divisors" data-signature="Nat.divisors (n : â„•) : Finset â„•" data-docs="`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. " title="Nat.divisors (n : â„•) : Finset â„•
`divisors n` is the `Finset` of divisors of `n`. By convention, we set `divisors 0 = âˆ…`. ">divisors</span>, <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> <span class="lean-operator">â†”</span> <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š âˆ£ <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span> := <span class="lean-keyword">fun</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-var" data-type="d âˆˆ m.divisors" title="d âˆˆ m.divisors">hd</span> =&gt;
    <span class="lean-const" data-signature="Iff.intro {a b : Prop} (mp : a â†’ b) (mpr : b â†’ a) : a â†” b" data-docs="If `a â†’ b` and `b â†’ a` then `a` and `b` are equivalent. " title="Iff.intro {a b : Prop} (mp : a â†’ b) (mpr : b â†’ a) : a â†” b">âŸ¨</span><span class="lean-keyword">fun</span> <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hS</span> =&gt; <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Finset.mem_filter" data-signature="Finset.mem_filter.{u_1} {Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} {a : Î±} :
  a âˆˆ Finset.filter p s â†” a âˆˆ s âˆ§ p a" title="Finset.mem_filter.{u_1} {Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} {a : Î±} :
  a âˆˆ Finset.filter p s â†” a âˆˆ s âˆ§ p a">Finset.mem_filter</span>.<span class="lean-const" data-name="Iff.mp" data-signature="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b" data-docs="Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. " title="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b
Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. ">mp</span> <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hS</span><span class="lean-bracket-1">)</span>.<span class="lean-number">2</span><span class="lean-const" data-signature="Iff.intro {a b : Prop} (mp : a â†’ b) (mpr : b â†’ a) : a â†” b" data-docs="If `a â†’ b` and `b â†’ a` then `a` and `b` are equivalent. " title="Iff.intro {a b : Prop} (mp : a â†’ b) (mpr : b â†’ a) : a â†” b">,</span> <span class="lean-keyword">fun</span> <span class="lean-var" data-type="cyclotomic d â„š âˆ£ minpoly â„š A_Q" title="cyclotomic d â„š âˆ£ minpoly â„š A_Q">hdvd</span> =&gt; <span class="lean-const" data-name="Finset.mem_filter" data-signature="Finset.mem_filter.{u_1} {Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} {a : Î±} :
  a âˆˆ Finset.filter p s â†” a âˆˆ s âˆ§ p a" title="Finset.mem_filter.{u_1} {Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} {a : Î±} :
  a âˆˆ Finset.filter p s â†” a âˆˆ s âˆ§ p a">Finset.mem_filter</span>.<span class="lean-const" data-name="Iff.mpr" data-signature="Iff.mpr {a b : Prop} (self : a â†” b) : b â†’ a" data-docs="Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. " title="Iff.mpr {a b : Prop} (self : a â†” b) : b â†’ a
Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. ">mpr</span> <span class="lean-const" data-signature="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b" data-docs="`And.intro : a â†’ b â†’ a âˆ§ b` is the constructor for the And operation. " title="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b">âŸ¨</span><span class="lean-var" data-type="d âˆˆ m.divisors" title="d âˆˆ m.divisors">hd</span><span class="lean-const" data-signature="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b" data-docs="`And.intro : a â†’ b â†’ a âˆ§ b` is the constructor for the And operation. " title="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b">,</span> <span class="lean-var" data-type="cyclotomic d â„š âˆ£ minpoly â„š A_Q" title="cyclotomic d â„š âˆ£ minpoly â„š A_Q">hdvd</span><span class="lean-const" data-signature="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b" data-docs="`And.intro : a â†’ b â†’ a âˆ§ b` is the constructor for the And operation. " title="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b">âŸ©</span><span class="lean-const" data-signature="Iff.intro {a b : Prop} (mp : a â†’ b) (mpr : b â†’ a) : a â†” b" data-docs="If `a â†’ b` and `b â†’ a` then `a` and `b` are equivalent. " title="Iff.intro {a b : Prop} (mp : a â†’ b) (mpr : b â†’ a) : a â†” b">âŸ©</span>
  <span class="lean-comment">-- minpoly âˆ£ <span class="lean-operator">âˆ</span>_</span><span class="lean-bracket-1">{</span>d<span class="lean-operator">âˆˆ</span>S<span class="lean-bracket-1">}</span> Î¦_d <span class="lean-bracket-1">(</span>by coprimality argument<span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="minpoly â„š A_Q âˆ£ âˆ d âˆˆ S, cyclotomic d â„š" title="minpoly â„š A_Q âˆ£ âˆ d âˆˆ S, cyclotomic d â„š">hminpoly_dvd_prod</span> : <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span> âˆ£ <span class="lean-operator">âˆ</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>, <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š :=
    <span class="lean-const" data-name="Crystallographic.minpoly_dvd_prod_cyclotomic_of_dvd_X_pow_sub_one" data-signature="Crystallographic.minpoly_dvd_prod_cyclotomic_of_dvd_X_pow_sub_one {N : â„•} [NeZero N] (A : Matrix (Fin N) (Fin N) â„¤)
  (m : â„•) (hm : 0 &lt; m) (S : Finset â„•) (hS_sub : S âŠ† m.divisors)
  (hS_def : âˆ€ d âˆˆ m.divisors, d âˆˆ S â†” cyclotomic d â„š âˆ£ minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)))
  (hminpoly_dvd : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1) :
  minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ âˆ d âˆˆ S, cyclotomic d â„š" data-docs="If the minimal polynomial divides X^m - 1, then it divides the product of cyclotomic
polynomials for divisors d where Î¦_d divides the minimal polynomial.

The proof uses coprimality: minpoly is coprime to Î¦_d when Î¦_d does not divide it
(since Î¦_d is irreducible), hence minpoly is coprime to the product of such Î¦_d.
Since X^m - 1 = (âˆ_{dâˆˆS} Î¦_d) * (âˆ_{dâˆ‰S} Î¦_d) and minpoly divides the LHS while
being coprime to the second factor, it must divide the first factor. " title="Crystallographic.minpoly_dvd_prod_cyclotomic_of_dvd_X_pow_sub_one {N : â„•} [NeZero N] (A : Matrix (Fin N) (Fin N) â„¤)
  (m : â„•) (hm : 0 &lt; m) (S : Finset â„•) (hS_sub : S âŠ† m.divisors)
  (hS_def : âˆ€ d âˆˆ m.divisors, d âˆˆ S â†” cyclotomic d â„š âˆ£ minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)))
  (hminpoly_dvd : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1) :
  minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ âˆ d âˆˆ S, cyclotomic d â„š
If the minimal polynomial divides X^m - 1, then it divides the product of cyclotomic...">minpoly_dvd_prod_cyclotomic_of_dvd_X_pow_sub_one</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> <span class="lean-var" data-type="S âŠ† m.divisors" title="S âŠ† m.divisors">hS_sub</span> <span class="lean-var" data-type="âˆ€ d âˆˆ m.divisors, d âˆˆ S â†” cyclotomic d â„š âˆ£ minpoly â„š A_Q" title="âˆ€ d âˆˆ m.divisors, d âˆˆ S â†” cyclotomic d â„š âˆ£ minpoly â„š A_Q">hS_def</span> <span class="lean-var" data-type="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1" title="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1">hminpoly_dvd</span>
  <span class="lean-comment">-- <span class="lean-operator">âˆ</span>_</span><span class="lean-bracket-1">{</span>d<span class="lean-operator">âˆˆ</span>S<span class="lean-bracket-1">}</span> Î¦_d âˆ£ minpoly <span class="lean-bracket-1">(</span>by definition of S<span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="âˆ d âˆˆ S, cyclotomic d â„š âˆ£ minpoly â„š A_Q" title="âˆ d âˆˆ S, cyclotomic d â„š âˆ£ minpoly â„š A_Q">hprod_dvd_minpoly</span> : <span class="lean-bracket-1">(</span><span class="lean-operator">âˆ</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>, <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š<span class="lean-bracket-1">)</span> âˆ£ <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span> :=
    <span class="lean-const" data-name="Crystallographic.cyclotomic_finset_product_dvd" data-signature="Crystallographic.cyclotomic_finset_product_dvd {target : â„š[X]} (S : Finset â„•)
  (hdvd_each : âˆ€ d âˆˆ S, cyclotomic d â„š âˆ£ target) : âˆ d âˆˆ S, cyclotomic d â„š âˆ£ target" data-docs="If each cyclotomic polynomial in a finset divides a target polynomial,
then their product also divides the target. " title="Crystallographic.cyclotomic_finset_product_dvd {target : â„š[X]} (S : Finset â„•)
  (hdvd_each : âˆ€ d âˆˆ S, cyclotomic d â„š âˆ£ target) : âˆ d âˆˆ S, cyclotomic d â„š âˆ£ target
If each cyclotomic polynomial in a finset divides a target polynomial,...">cyclotomic_finset_product_dvd</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> <span class="lean-bracket-1">(</span><span class="lean-keyword">fun</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hd</span> =&gt; <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Finset.mem_filter" data-signature="Finset.mem_filter.{u_1} {Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} {a : Î±} :
  a âˆˆ Finset.filter p s â†” a âˆˆ s âˆ§ p a" title="Finset.mem_filter.{u_1} {Î± : Type u_1} {p : Î± â†’ Prop} [DecidablePred p] {s : Finset Î±} {a : Î±} :
  a âˆˆ Finset.filter p s â†” a âˆˆ s âˆ§ p a">Finset.mem_filter</span>.<span class="lean-const" data-name="Iff.mp" data-signature="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b" data-docs="Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. " title="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b
Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. ">mp</span> <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hd</span><span class="lean-bracket-2">)</span>.<span class="lean-number">2</span><span class="lean-bracket-1">)</span>
  <span class="lean-comment">-- Equality by mutual divisibility of monic polynomials</span>
  <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-signature="Exists.intro.{u} {Î± : Sort u} {p : Î± â†’ Prop} (w : Î±) (h : p w) : Exists p" data-docs="Existential introduction. If `a : Î±` and `h : p a`,
then `âŸ¨a, hâŸ©` is a proof that `âˆƒ x : Î±, p x`. " title="Exists.intro.{u} {Î± : Sort u} {p : Î± â†’ Prop} (w : Î±) (h : p w) : Exists p">âŸ¨</span><span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span><span class="lean-const" data-signature="Exists.intro.{u} {Î± : Sort u} {p : Î± â†’ Prop} (w : Î±) (h : p w) : Exists p" data-docs="Existential introduction. If `a : Î±` and `h : p a`,
then `âŸ¨a, hâŸ©` is a proof that `âˆƒ x : Î±, p x`. " title="Exists.intro.{u} {Î± : Sort u} {p : Î± â†’ Prop} (w : Î±) (h : p w) : Exists p">,</span> <span class="lean-var" data-type="âˆ€ d âˆˆ S, d âˆ£ m" title="âˆ€ d âˆˆ S, d âˆ£ m">hS_dvd</span><span class="lean-const" data-signature="Exists.intro.{u} {Î± : Sort u} {p : Î± â†’ Prop} (w : Î±) (h : p w) : Exists p" data-docs="Existential introduction. If `a : Î±` and `h : p a`,
then `âŸ¨a, hâŸ©` is a proof that `âˆƒ x : Î±, p x`. " title="Exists.intro.{u} {Î± : Sort u} {p : Î± â†’ Prop} (w : Î±) (h : p w) : Exists p">,</span> <span class="lean-const" data-name="Polynomial.eq_of_monic_of_associated" data-signature="Polynomial.eq_of_monic_of_associated.{u} {R : Type u} [Semiring R] {p q : R[X]} (hp : p.Monic) (hq : q.Monic)
  (hpq : Associated p q) : p = q" title="Polynomial.eq_of_monic_of_associated.{u} {R : Type u} [Semiring R] {p q : R[X]} (hp : p.Monic) (hq : q.Monic)
  (hpq : Associated p q) : p = q">Polynomial.eq_of_monic_of_associated</span>
    <span class="lean-bracket-1">(</span><span class="lean-const" data-name="minpoly.monic" data-signature="minpoly.monic.{u_1, u_2} {A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] {x : B}
  (hx : IsIntegral A x) : (minpoly A x).Monic" data-docs="A minimal polynomial is monic. " title="minpoly.monic.{u_1, u_2} {A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] {x : B}
  (hx : IsIntegral A x) : (minpoly A x).Monic
A minimal polynomial is monic. ">minpoly.monic</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Matrix.isIntegral" data-signature="Matrix.isIntegral.{u, v} {R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  IsIntegral R M" title="Matrix.isIntegral.{u, v} {R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  IsIntegral R M">Matrix.isIntegral</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Polynomial.monic_prod_of_monic" data-signature="Polynomial.monic_prod_of_monic.{u, y} {R : Type u} {Î¹ : Type y} [CommSemiring R] (s : Finset Î¹) (f : Î¹ â†’ R[X])
  (hs : âˆ€ i âˆˆ s, (f i).Monic) : (âˆ i âˆˆ s, f i).Monic" title="Polynomial.monic_prod_of_monic.{u, y} {R : Type u} {Î¹ : Type y} [CommSemiring R] (s : Finset Î¹) (f : Î¹ â†’ R[X])
  (hs : âˆ€ i âˆˆ s, (f i).Monic) : (âˆ i âˆˆ s, f i).Monic">Polynomial.monic_prod_of_monic</span> _ _ <span class="lean-bracket-2">(</span><span class="lean-keyword">fun</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> _ =&gt; <span class="lean-const" data-name="Polynomial.cyclotomic.monic" data-signature="Polynomial.cyclotomic.monic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : (cyclotomic n R).Monic" data-docs="`cyclotomic n` is monic. " title="Polynomial.cyclotomic.monic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : (cyclotomic n R).Monic
`cyclotomic n` is monic. ">cyclotomic.monic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š<span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-const" data-name="associated_of_dvd_dvd" data-signature="associated_of_dvd_dvd.{u_1} {M : Type u_1} [CancelMonoidWithZero M] {a b : M} (hab : a âˆ£ b) (hba : b âˆ£ a) :
  Associated a b" title="associated_of_dvd_dvd.{u_1} {M : Type u_1} [CancelMonoidWithZero M] {a b : M} (hab : a âˆ£ b) (hba : b âˆ£ a) :
  Associated a b">associated_of_dvd_dvd</span> <span class="lean-var" data-type="minpoly â„š A_Q âˆ£ âˆ d âˆˆ S, cyclotomic d â„š" title="minpoly â„š A_Q âˆ£ âˆ d âˆˆ S, cyclotomic d â„š">hminpoly_dvd_prod</span> <span class="lean-var" data-type="âˆ d âˆˆ S, cyclotomic d â„š âˆ£ minpoly â„š A_Q" title="âˆ d âˆˆ S, cyclotomic d â„š âˆ£ minpoly â„š A_Q">hprod_dvd_minpoly</span><span class="lean-bracket-1">)</span><span class="lean-const" data-signature="Exists.intro.{u} {Î± : Sort u} {p : Î± â†’ Prop} (w : Î±) (h : p w) : Exists p" data-docs="Existential introduction. If `a : Î±` and `h : p a`,
then `âŸ¨a, hâŸ©` is a proof that `âˆƒ x : Î±, p x`. " title="Exists.intro.{u} {Î± : Sort u} {p : Î± â†’ Prop} (w : Î±) (h : p w) : Exists p">âŸ©</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Forward.lean#L167-L201" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:minpoly-eq-prod-cyclotomic');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:cyclotomic-divisors-lcm-eq">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.6</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:cyclotomic-divisors-lcm-eq">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000049"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0005.html#lem:minpoly-eq-prod-cyclotomic">Theorem 5.0.5</a></li>
          
          <li><a href="sect0005.html#lem:pow-eq-one-of-minpoly-dvd">Theorem 5.0.1</a></li>
          
          <li><a href="sect0005.html#lem:cyclotomic-finset-product-dvd">Theorem 5.0.3</a></li>
          
          <li><a href="sect0005.html#lem:pow-eq-one-of-minpoly-dvd">Theorem 5.0.1</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.cyclotomic_divisors_lcm_eq_of_orderOf" class="lean_decl">Crystallographic.cyclotomic_divisors_lcm_eq_of_orderOf</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       If \(\mathrm{ord}(A) = m\) and \(\mu _A = \prod _{d \in S} \Phi _d\) with \(S \subseteq \mathrm{divisors}(m)\), then \(\mathrm{lcm}(S) = m\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000049">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p> Suppose \(\ell = \mathrm{lcm}(S) {\lt} m\). Then \(\mu _A = \prod _{d \in S} \Phi _d\) divides \(\prod _{d \mid \ell } \Phi _d = X^\ell - 1\), since each \(d \in S\) divides \(\ell \). By the transfer lemma, \(A^\ell = I\). But this contradicts \(\mathrm{ord}(A) = m {\gt} \ell \). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Crystallographic.cyclotomic_divisors_lcm_eq_of_orderOf" data-signature="Crystallographic.cyclotomic_divisors_lcm_eq_of_orderOf {N : â„•} [NeZero N] (A : Matrix (Fin N) (Fin N) â„¤) (m : â„•)
  (hm : 0 &lt; m) (hA_ord : orderOf A = m) (S : Finset â„•) (hS_sub : âˆ€ d âˆˆ S, d âˆ£ m)
  (hminpoly_eq_prod : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š) : S.lcm id = m" data-docs="If A has order m and minpoly = âˆ_{dâˆˆS} Î¦_d where S âŠ† divisors(m),
then S.lcm id = m. This is the key lemma: if lcm(S) &lt; m, then A^{lcm(S)} = 1,
contradicting that A has exact order m. " title="Crystallographic.cyclotomic_divisors_lcm_eq_of_orderOf {N : â„•} [NeZero N] (A : Matrix (Fin N) (Fin N) â„¤) (m : â„•)
  (hm : 0 &lt; m) (hA_ord : orderOf A = m) (S : Finset â„•) (hS_sub : âˆ€ d âˆˆ S, d âˆ£ m)
  (hminpoly_eq_prod : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š) : S.lcm id = m
If A has order m and minpoly = âˆ_{dâˆˆS} Î¦_d where S âŠ† divisors(m),...">cyclotomic_divisors_lcm_eq_of_orderOf</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="â„•" title="â„•">N</span> : â„•<span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="NeZero" data-signature="NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop" data-docs="A type-class version of `n â‰  0`.  " title="NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop
A type-class version of `n â‰  0`.  ">NeZero</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-1">]</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> : <span class="lean-const" data-name="Matrix" data-signature="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (Î± : Type v) : Type (max u u&#x27; v)" data-docs="`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`
and whose columns are indexed by `n`. " title="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (Î± : Type v) : Type (max u u&#x27; v)
`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`...">Matrix</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : â„•) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : â„•) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-2">)</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : â„•) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : â„•) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-2">)</span> â„¤<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">m</span> : â„•<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span> : <span class="lean-expr" data-type="â„•" title="â„•">0</span> &lt; <span class="lean-var" data-type="â„•" title="â„•">m</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="orderOf A = m" title="orderOf A = m">hA_ord</span> : <span class="lean-const" data-name="orderOf" data-signature="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : â„•" data-docs="`orderOf x` is the order of the element `x`, i.e. the `n â‰¥ 1`, s.t. `x ^ n = 1` if it exists.
Otherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. " title="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : â„•
`orderOf x` is the order of the element `x`, i.e. the `n â‰¥ 1`, s.t. `x ^ n = 1` if it exists....">orderOf</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> = <span class="lean-var" data-type="â„•" title="â„•">m</span><span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> : <span class="lean-const" data-name="Finset" data-signature="Finset.{u_4} (Î± : Type u_4) : Type u_4" data-docs="`Finset Î±` is the type of finite sets of elements of `Î±`. It is implemented
as a multiset (a list up to permutation) which has no duplicate elements. " title="Finset.{u_4} (Î± : Type u_4) : Type u_4
`Finset Î±` is the type of finite sets of elements of `Î±`. It is implemented...">Finset</span> â„•<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="âˆ€ d âˆˆ S, d âˆ£ m" title="âˆ€ d âˆˆ S, d âˆ£ m">hS_sub</span> : <span class="lean-operator">âˆ€</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>, <span class="lean-var" data-type="â„•" title="â„•">d</span> âˆ£ <span class="lean-var" data-type="â„•" title="â„•">m</span><span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š" title="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š">hminpoly_eq_prod</span> : <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-bracket-2">(</span><span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-3">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-3">)</span><span class="lean-bracket-2">)</span> = <span class="lean-operator">âˆ</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>, <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š<span class="lean-bracket-1">)</span> :
    <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±
Least common multiple of a finite set ">lcm</span> <span class="lean-const" data-name="id" data-signature="id.{u} {Î± : Sort u} (a : Î±) : Î±" data-docs="The identity function. `id` takes an implicit argument `Î± : Sort u`
(a type in any universe), and an argument `a : Î±`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T&#x27;` is definitionally equal to `T`, then `@id T&#x27; e` typechecks, and Lean
knows that this expression has type `T&#x27;` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T&#x27;` may have different
typeclass instances on them. `show T&#x27; from e` is sugar for an `@id T&#x27; e`
expression.
" title="id.{u} {Î± : Sort u} (a : Î±) : Î±
The identity function. `id` takes an implicit argument `Î± : Sort u`...">id</span> = <span class="lean-var" data-type="â„•" title="â„•">m</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="The `let` tactic is for adding definitions to the local context of the main goal.
The definition can be unfolded, unlike definitions introduced by `have`.

* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.
* `let x := e` uses the type of `e` for `t`.
* `let : t := e` and `let := e` use `this` for the name of the hypothesis.
* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that let only one applicable constructor.
  For example, given `p : Î± Ã— Î² Ã— Î³`, `let âŸ¨x, y, zâŸ© := p` produces the
  local variables `x : Î±`, `y : Î²`, and `z : Î³`.
* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `let` term.

## Properties and relations

* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics
  such as `simp`, `dsimp`, `unfold`, and `subst`.
* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.
  The tactic might fail if the local context depends on the value of the variable.
* The `let` tactic is preferred for data (non-propositions).
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
" title="The `let` tactic is for adding definitions to the local context of the main goal.">let</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span> := <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-1">)</span>
  <span class="lean-comment">-- If lcm</span><span class="lean-bracket-1">(</span>S<span class="lean-bracket-1">)</span> &lt; m, then minpoly | X^<span class="lean-bracket-1">{</span>lcm<span class="lean-bracket-2">(</span>S<span class="lean-bracket-2">)</span><span class="lean-bracket-1">}</span> - <span class="lean-number">1</span>, so A^<span class="lean-bracket-1">{</span>lcm<span class="lean-bracket-2">(</span>S<span class="lean-bracket-2">)</span><span class="lean-bracket-1">}</span> = <span class="lean-number">1</span>
  <span class="lean-comment">-- This contradicts orderOf A = m</span>
  <span class="lean-keyword" data-docs="`by_contra h` proves `âŠ¢ p` by contradiction,
introducing a hypothesis `h : Â¬p` and proving `False`.
* If `p` is a negation `Â¬q`, `h : q` will be introduced instead of `Â¬Â¬q`.
* If `p` is decidable, it uses `Decidable.byContradiction` instead of `Classical.byContradiction`.
* If `h` is omitted, the introduced variable will be called `this`.
" title="`by_contra h` proves `âŠ¢ p` by contradiction,">by_contra</span> <span class="lean-var" data-type="Â¬S.lcm id = m" title="Â¬S.lcm id = m">hne</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="S.lcm id âˆ£ m" title="S.lcm id âˆ£ m">hlcm_dvd_m</span> : <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±
Least common multiple of a finite set ">lcm</span> <span class="lean-const" data-name="id" data-signature="id.{u} {Î± : Sort u} (a : Î±) : Î±" data-docs="The identity function. `id` takes an implicit argument `Î± : Sort u`
(a type in any universe), and an argument `a : Î±`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T&#x27;` is definitionally equal to `T`, then `@id T&#x27; e` typechecks, and Lean
knows that this expression has type `T&#x27;` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T&#x27;` may have different
typeclass instances on them. `show T&#x27; from e` is sugar for an `@id T&#x27; e`
expression.
" title="id.{u} {Î± : Sort u} (a : Î±) : Î±
The identity function. `id` takes an implicit argument `Î± : Sort u`...">id</span> âˆ£ <span class="lean-var" data-type="â„•" title="â„•">m</span> := <span class="lean-const" data-name="Finset.lcm_dvd" data-signature="Finset.lcm_dvd.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±]
  {s : Finset Î²} {f : Î² â†’ Î±} {a : Î±} : (âˆ€ b âˆˆ s, f b âˆ£ a) â†’ s.lcm f âˆ£ a" title="Finset.lcm_dvd.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±]
  {s : Finset Î²} {f : Î² â†’ Î±} {a : Î±} : (âˆ€ b âˆˆ s, f b âˆ£ a) â†’ s.lcm f âˆ£ a">Finset.lcm_dvd</span> <span class="lean-bracket-1">(</span><span class="lean-keyword">fun</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hd</span> =&gt; <span class="lean-var" data-type="âˆ€ d âˆˆ S, d âˆ£ m" title="âˆ€ d âˆˆ S, d âˆ£ m">hS_sub</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hd</span><span class="lean-bracket-1">)</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="S.lcm id â‰¤ m" title="S.lcm id â‰¤ m">hlcm_le</span> : <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±
Least common multiple of a finite set ">lcm</span> <span class="lean-const" data-name="id" data-signature="id.{u} {Î± : Sort u} (a : Î±) : Î±" data-docs="The identity function. `id` takes an implicit argument `Î± : Sort u`
(a type in any universe), and an argument `a : Î±`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T&#x27;` is definitionally equal to `T`, then `@id T&#x27; e` typechecks, and Lean
knows that this expression has type `T&#x27;` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T&#x27;` may have different
typeclass instances on them. `show T&#x27; from e` is sugar for an `@id T&#x27; e`
expression.
" title="id.{u} {Î± : Sort u} (a : Î±) : Î±
The identity function. `id` takes an implicit argument `Î± : Sort u`...">id</span> <span class="lean-operator">â‰¤</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> := <span class="lean-const" data-name="Nat.le_of_dvd" data-signature="Nat.le_of_dvd {m n : â„•} (h : 0 &lt; n) : m âˆ£ n â†’ m â‰¤ n" title="Nat.le_of_dvd {m n : â„•} (h : 0 &lt; n) : m âˆ£ n â†’ m â‰¤ n">Nat.le_of_dvd</span> <span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span> <span class="lean-var" data-type="S.lcm id âˆ£ m" title="S.lcm id âˆ£ m">hlcm_dvd_m</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="S.lcm id &lt; m" title="S.lcm id &lt; m">hlcm_lt</span> : <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±
Least common multiple of a finite set ">lcm</span> <span class="lean-const" data-name="id" data-signature="id.{u} {Î± : Sort u} (a : Î±) : Î±" data-docs="The identity function. `id` takes an implicit argument `Î± : Sort u`
(a type in any universe), and an argument `a : Î±`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T&#x27;` is definitionally equal to `T`, then `@id T&#x27; e` typechecks, and Lean
knows that this expression has type `T&#x27;` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T&#x27;` may have different
typeclass instances on them. `show T&#x27; from e` is sugar for an `@id T&#x27; e`
expression.
" title="id.{u} {Î± : Sort u} (a : Î±) : Î±
The identity function. `id` takes an implicit argument `Î± : Sort u`...">id</span> &lt; <span class="lean-var" data-type="â„•" title="â„•">m</span> := <span class="lean-const" data-name="Nat.lt_of_le_of_ne" data-signature="Nat.lt_of_le_of_ne {n m : â„•} (hâ‚ : n â‰¤ m) (hâ‚‚ : Â¬n = m) : n &lt; m" title="Nat.lt_of_le_of_ne {n m : â„•} (hâ‚ : n â‰¤ m) (hâ‚‚ : Â¬n = m) : n &lt; m">Nat.lt_of_le_of_ne</span> <span class="lean-var" data-type="S.lcm id â‰¤ m" title="S.lcm id â‰¤ m">hlcm_le</span> <span class="lean-var" data-type="Â¬S.lcm id = m" title="Â¬S.lcm id = m">hne</span>
  <span class="lean-comment">-- minpoly | <span class="lean-operator">âˆ</span>_</span><span class="lean-bracket-1">{</span>d|lcm<span class="lean-bracket-2">(</span>S<span class="lean-bracket-2">)</span><span class="lean-bracket-1">}</span> Î¦_d = X^<span class="lean-bracket-1">{</span>lcm<span class="lean-bracket-2">(</span>S<span class="lean-bracket-2">)</span><span class="lean-bracket-1">}</span> - <span class="lean-number">1</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="0 &lt; S.lcm id" title="0 &lt; S.lcm id">hlcm_pos</span> : <span class="lean-expr" data-type="â„•" title="â„•">0</span> &lt; <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±
Least common multiple of a finite set ">lcm</span> <span class="lean-const" data-name="id" data-signature="id.{u} {Î± : Sort u} (a : Î±) : Î±" data-docs="The identity function. `id` takes an implicit argument `Î± : Sort u`
(a type in any universe), and an argument `a : Î±`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T&#x27;` is definitionally equal to `T`, then `@id T&#x27; e` typechecks, and Lean
knows that this expression has type `T&#x27;` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T&#x27;` may have different
typeclass instances on them. `show T&#x27; from e` is sugar for an `@id T&#x27; e`
expression.
" title="id.{u} {Î± : Sort u} (a : Î±) : Î±
The identity function. `id` takes an implicit argument `Î± : Sort u`...">id</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
    <span class="lean-keyword" data-docs="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : Â¬ p` in the second branch.
" title="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `">by_cases</span> <span class="lean-var" data-type="S = âˆ…" title="S = âˆ…">hS_empty</span> : <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> = <span class="lean-operator">âˆ…</span>
    <span class="lean-operator">Â·</span> <span class="lean-comment">-- If S = <span class="lean-operator">âˆ…</span>, then minpoly = <span class="lean-number">1</span> </span><span class="lean-bracket-1">(</span>empty product<span class="lean-bracket-1">)</span>, contradiction since
      <span class="lean-comment">-- minpoly has positive degree</span>
      <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="S = âˆ…" title="S = âˆ…">hS_empty</span>, <span class="lean-const" data-name="Finset.prod_empty" data-signature="Finset.prod_empty.{u_1, u_3} {Î¹ : Type u_1} {M : Type u_3} {f : Î¹ â†’ M} [CommMonoid M] : âˆ x âˆˆ âˆ…, f x = 1" title="Finset.prod_empty.{u_1, u_3} {Î¹ : Type u_1} {M : Type u_3} {f : Î¹ â†’ M} [CommMonoid M] : âˆ x âˆˆ âˆ…, f x = 1">Finset.prod_empty</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`
* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š" title="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š">hminpoly_eq_prod</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="0 &lt; (minpoly â„š A_Q).natDegree" title="0 &lt; (minpoly â„š A_Q).natDegree">hdeg</span> := <span class="lean-const" data-name="minpoly.natDegree_pos" data-signature="minpoly.natDegree_pos.{u_1, u_2} {A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] {x : B}
  [Nontrivial B] (hx : IsIntegral A x) : 0 &lt; (minpoly A x).natDegree" data-docs="The degree of a minimal polynomial, as a natural number, is positive. " title="minpoly.natDegree_pos.{u_1, u_2} {A : Type u_1} {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] {x : B}
  [Nontrivial B] (hx : IsIntegral A x) : 0 &lt; (minpoly A x).natDegree
The degree of a minimal polynomial, as a natural number, is positive. ">minpoly.natDegree_pos</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Matrix.isIntegral" data-signature="Matrix.isIntegral.{u, v} {R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  IsIntegral R M" title="Matrix.isIntegral.{u, v} {R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  IsIntegral R M">Matrix.isIntegral</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span><span class="lean-bracket-1">)</span>
      <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = 1" title="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = 1">hminpoly_eq_prod</span>, <span class="lean-const" data-name="Polynomial.natDegree_one" data-signature="Polynomial.natDegree_one.{u} {R : Type u} [Semiring R] : natDegree 1 = 0" title="Polynomial.natDegree_one.{u} {R : Type u} [Semiring R] : natDegree 1 = 0">natDegree_one</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`
* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="0 &lt; (minpoly â„š A_Q).natDegree" title="0 &lt; (minpoly â„š A_Q).natDegree">hdeg</span>
      <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span>
    <span class="lean-operator">Â·</span> <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="S.lcm id â‰  0" title="S.lcm id â‰  0">hne_zero</span> : <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±
Least common multiple of a finite set ">lcm</span> <span class="lean-const" data-name="id" data-signature="id.{u} {Î± : Sort u} (a : Î±) : Î±" data-docs="The identity function. `id` takes an implicit argument `Î± : Sort u`
(a type in any universe), and an argument `a : Î±`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T&#x27;` is definitionally equal to `T`, then `@id T&#x27; e` typechecks, and Lean
knows that this expression has type `T&#x27;` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T&#x27;` may have different
typeclass instances on them. `show T&#x27; from e` is sugar for an `@id T&#x27; e`
expression.
" title="id.{u} {Î± : Sort u} (a : Î±) : Î±
The identity function. `id` takes an implicit argument `Î± : Sort u`...">id</span> <span class="lean-operator">â‰ </span> <span class="lean-expr" data-type="â„•" title="â„•">0</span> := <span class="lean-const" data-name="Finset.lcm_ne_zero_iff" data-signature="Finset.lcm_ne_zero_iff.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±]
  {s : Finset Î²} {f : Î² â†’ Î±} [Nontrivial Î±] : s.lcm f â‰  0 â†” âˆ€ x âˆˆ s, f x â‰  0" title="Finset.lcm_ne_zero_iff.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±]
  {s : Finset Î²} {f : Î² â†’ Î±} [Nontrivial Î±] : s.lcm f â‰  0 â†” âˆ€ x âˆˆ s, f x â‰  0">Finset.lcm_ne_zero_iff</span>.<span class="lean-const" data-name="Iff.mpr" data-signature="Iff.mpr {a b : Prop} (self : a â†” b) : b â†’ a" data-docs="Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. " title="Iff.mpr {a b : Prop} (self : a â†” b) : b â†’ a
Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. ">mpr</span> <span class="lean-keyword">fun</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hd</span> =&gt;
        <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Nat.pos_of_mem_divisors" data-signature="Nat.pos_of_mem_divisors {n m : â„•} (h : m âˆˆ n.divisors) : 0 &lt; m" title="Nat.pos_of_mem_divisors {n m : â„•} (h : m âˆˆ n.divisors) : 0 &lt; m">Nat.pos_of_mem_divisors</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="Nat.mem_divisors" data-signature="Nat.mem_divisors {n m : â„•} : n âˆˆ m.divisors â†” n âˆ£ m âˆ§ m â‰  0" title="Nat.mem_divisors {n m : â„•} : n âˆˆ m.divisors â†” n âˆ£ m âˆ§ m â‰  0">Nat.mem_divisors</span>.<span class="lean-const" data-name="Iff.mpr" data-signature="Iff.mpr {a b : Prop} (self : a â†” b) : b â†’ a" data-docs="Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. " title="Iff.mpr {a b : Prop} (self : a â†” b) : b â†’ a
Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. ">mpr</span> <span class="lean-const" data-signature="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b" data-docs="`And.intro : a â†’ b â†’ a âˆ§ b` is the constructor for the And operation. " title="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b">âŸ¨</span><span class="lean-var" data-type="âˆ€ d âˆˆ S, d âˆ£ m" title="âˆ€ d âˆˆ S, d âˆ£ m">hS_sub</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hd</span><span class="lean-const" data-signature="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b" data-docs="`And.intro : a â†’ b â†’ a âˆ§ b` is the constructor for the And operation. " title="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b">,</span> <span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span>.<span class="lean-const" data-name="LT.lt.ne&#x27;" data-signature="LT.lt.ne&#x27;.{u_1} {Î± : Type u_1} [Preorder Î±] {a b : Î±} (h : b &lt; a) : a â‰  b" title="LT.lt.ne&#x27;.{u_1} {Î± : Type u_1} [Preorder Î±] {a b : Î±} (h : b &lt; a) : a â‰  b">ne&#x27;</span><span class="lean-const" data-signature="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b" data-docs="`And.intro : a â†’ b â†’ a âˆ§ b` is the constructor for the And operation. " title="And.intro {a b : Prop} (left : a) (right : b) : a âˆ§ b">âŸ©</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="LT.lt.ne&#x27;" data-signature="LT.lt.ne&#x27;.{u_1} {Î± : Type u_1} [Preorder Î±] {a b : Î±} (h : b &lt; a) : a â‰  b" title="LT.lt.ne&#x27;.{u_1} {Î± : Type u_1} [Preorder Î±] {a b : Î±} (h : b &lt; a) : a â‰  b">ne&#x27;</span>
      <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Nat.pos_of_ne_zero" data-signature="Nat.pos_of_ne_zero {n : â„•} : n â‰  0 â†’ 0 &lt; n" title="Nat.pos_of_ne_zero {n : â„•} : n â‰  0 â†’ 0 &lt; n">Nat.pos_of_ne_zero</span> <span class="lean-var" data-type="S.lcm id â‰  0" title="S.lcm id â‰  0">hne_zero</span>
  <span class="lean-comment">-- Helper: X^d - <span class="lean-number">1</span> | X^n - <span class="lean-number">1</span> when d | n</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="âˆ€ (d n : â„•), d âˆ£ n â†’ X ^ d - 1 âˆ£ X ^ n - 1" title="âˆ€ (d n : â„•), d âˆ£ n â†’ X ^ d - 1 âˆ£ X ^ n - 1">X_pow_sub_one_dvd</span> : <span class="lean-operator">âˆ€</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-var" data-type="â„•" title="â„•">n</span> : â„•<span class="lean-bracket-1">)</span>, <span class="lean-var" data-type="â„•" title="â„•">d</span> âˆ£ <span class="lean-var" data-type="â„•" title="â„•">n</span> <span class="lean-operator">â†’</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-var" data-type="â„•" title="â„•">d</span> - <span class="lean-expr" data-type="â„š[X]" title="â„š[X]">1</span> : â„š<span class="lean-bracket-2">[</span>X<span class="lean-bracket-2">]</span><span class="lean-bracket-1">)</span> âˆ£ <span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-var" data-type="â„•" title="â„•">n</span> - <span class="lean-expr" data-type="â„š[X]" title="â„š[X]">1</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
    <span class="lean-keyword" data-docs="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal&#x27;s target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`. It is equivalent to `intro _`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, given a type ascription, or matched against a pattern:
  ```lean
  -- ... âŠ¢ Î± Ã— Î² â†’ ...
  intro (a, b)
  -- ..., a : Î±, b : Î² âŠ¢ ...
  ```
* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side
  is a variable.
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
" title="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.">intro</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-var" data-type="â„•" title="â„•">n</span> <span class="lean-var" data-type="d âˆ£ n" title="d âˆ£ n">hdvd</span>
    <span class="lean-keyword" data-docs="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for
a description of supported patterns.

```lean
obtain âŸ¨pattâŸ© : type := proof
```
is equivalent to
```lean
have h : type := proof
rcases h with âŸ¨pattâŸ©
```

If `âŸ¨pattâŸ©` is omitted, `rcases` will try to infer the pattern.

If `type` is omitted, `:= proof` is required.
" title="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for">obtain</span> <span class="lean-bracket-1">âŸ¨</span><span class="lean-var" data-type="â„•" title="â„•">k</span>, <span class="lean-var" data-type="n = d * k" title="n = d * k">hk</span><span class="lean-bracket-1">âŸ©</span> := <span class="lean-var" data-type="d âˆ£ n" title="d âˆ£ n">hdvd</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="n = d * k" title="n = d * k">hk</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="pow_one_sub_dvd_pow_mul_sub_one" data-signature="pow_one_sub_dvd_pow_mul_sub_one.{u_1} {R : Type u_1} [Ring R] (x : R) (m n : â„•) : x ^ m - 1 âˆ£ x ^ (m * n) - 1" title="pow_one_sub_dvd_pow_mul_sub_one.{u_1} {R : Type u_1} [Ring R] (x : R) (m n : â„•) : x ^ m - 1 âˆ£ x ^ (m * n) - 1">pow_one_sub_dvd_pow_mul_sub_one</span> <span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-var" data-type="â„•" title="â„•">k</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="minpoly â„š A_Q âˆ£ X ^ S.lcm id - 1" title="minpoly â„š A_Q âˆ£ X ^ S.lcm id - 1">hminpoly_dvd_lcm</span> : <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span> âˆ£ <span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±
Least common multiple of a finite set ">lcm</span> <span class="lean-const" data-name="id" data-signature="id.{u} {Î± : Sort u} (a : Î±) : Î±" data-docs="The identity function. `id` takes an implicit argument `Î± : Sort u`
(a type in any universe), and an argument `a : Î±`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T&#x27;` is definitionally equal to `T`, then `@id T&#x27; e` typechecks, and Lean
knows that this expression has type `T&#x27;` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T&#x27;` may have different
typeclass instances on them. `show T&#x27; from e` is sugar for an `@id T&#x27; e`
expression.
" title="id.{u} {Î± : Sort u} (a : Î±) : Î±
The identity function. `id` takes an implicit argument `Î± : Sort u`...">id</span><span class="lean-bracket-1">)</span> - <span class="lean-expr" data-type="â„š[X]" title="â„š[X]">1</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š" title="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š">hminpoly_eq_prod</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.
" title="`apply e` tries to match the current goal against the conclusion of `e`&#x27;s type.">apply</span> <span class="lean-const" data-name="Crystallographic.cyclotomic_finset_product_dvd" data-signature="Crystallographic.cyclotomic_finset_product_dvd {target : â„š[X]} (S : Finset â„•)
  (hdvd_each : âˆ€ d âˆˆ S, cyclotomic d â„š âˆ£ target) : âˆ d âˆˆ S, cyclotomic d â„š âˆ£ target" data-docs="If each cyclotomic polynomial in a finset divides a target polynomial,
then their product also divides the target. " title="Crystallographic.cyclotomic_finset_product_dvd {target : â„š[X]} (S : Finset â„•)
  (hdvd_each : âˆ€ d âˆˆ S, cyclotomic d â„š âˆ£ target) : âˆ d âˆˆ S, cyclotomic d â„š âˆ£ target
If each cyclotomic polynomial in a finset divides a target polynomial,...">cyclotomic_finset_product_dvd</span>
    <span class="lean-keyword" data-docs="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal&#x27;s target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`. It is equivalent to `intro _`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, given a type ascription, or matched against a pattern:
  ```lean
  -- ... âŠ¢ Î± Ã— Î² â†’ ...
  intro (a, b)
  -- ..., a : Î±, b : Î² âŠ¢ ...
  ```
* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side
  is a variable.
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
" title="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.">intro</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hd</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="d âˆ£ S.lcm id" title="d âˆ£ S.lcm id">hd_dvd_lcm</span> : <span class="lean-var" data-type="â„•" title="â„•">d</span> âˆ£ <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±
Least common multiple of a finite set ">lcm</span> <span class="lean-const" data-name="id" data-signature="id.{u} {Î± : Sort u} (a : Î±) : Î±" data-docs="The identity function. `id` takes an implicit argument `Î± : Sort u`
(a type in any universe), and an argument `a : Î±`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T&#x27;` is definitionally equal to `T`, then `@id T&#x27; e` typechecks, and Lean
knows that this expression has type `T&#x27;` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T&#x27;` may have different
typeclass instances on them. `show T&#x27; from e` is sugar for an `@id T&#x27; e`
expression.
" title="id.{u} {Î± : Sort u} (a : Î±) : Î±
The identity function. `id` takes an implicit argument `Î± : Sort u`...">id</span> := <span class="lean-const" data-name="Finset.dvd_lcm" data-signature="Finset.dvd_lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±]
  {s : Finset Î²} {f : Î² â†’ Î±} {b : Î²} (hb : b âˆˆ s) : f b âˆ£ s.lcm f" title="Finset.dvd_lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±]
  {s : Finset Î²} {f : Î² â†’ Î±} {b : Î²} (hb : b âˆˆ s) : f b âˆ£ s.lcm f">Finset.dvd_lcm</span> <span class="lean-var" data-type="d âˆˆ S" title="d âˆˆ S">hd</span>
    <span class="lean-keyword" data-docs="Step-wise reasoning over transitive relations.
```
calc
  a = b := pab
  b = c := pbc
  ...
  y = z := pyz
```
proves `a = z` from the given step-wise proofs. `=` can be replaced with any
relation implementing the typeclass `Trans`. Instead of repeating the right-
hand sides, subsequent left-hand sides can be replaced with `_`.
```
calc
  a = b := pab
  _ = c := pbc
  ...
  _ = z := pyz
```
It is also possible to write the *first* relation as `&lt;lhs&gt;\n  _ = &lt;rhs&gt; :=
&lt;proof&gt;`. This is useful for aligning relation symbols, especially on longer:
identifiers:
```
calc abc
  _ = bce := pabce
  _ = cef := pbcef
  ...
  _ = xyz := pwxyz
```

`calc` works as a term, as a tactic or as a `conv` tactic.

See [Theorem Proving in Lean 4][tpil4] for more information.

[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs
" title="Step-wise reasoning over transitive relations.">calc</span> <span class="lean-const" data-name="Polynomial.cyclotomic" data-signature="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]" data-docs="The `n`-th cyclotomic polynomial with coefficients in `R`. " title="Polynomial.cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] : R[X]
The `n`-th cyclotomic polynomial with coefficients in `R`. ">cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š âˆ£ <span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-var" data-type="â„•" title="â„•">d</span> - <span class="lean-expr" data-type="â„š[X]" title="â„š[X]">1</span> := <span class="lean-const" data-name="Polynomial.cyclotomic.dvd_X_pow_sub_one" data-signature="Polynomial.cyclotomic.dvd_X_pow_sub_one.{u_1} (n : â„•) (R : Type u_1) [Ring R] : cyclotomic n R âˆ£ X ^ n - 1" title="Polynomial.cyclotomic.dvd_X_pow_sub_one.{u_1} (n : â„•) (R : Type u_1) [Ring R] : cyclotomic n R âˆ£ X ^ n - 1">cyclotomic.dvd_X_pow_sub_one</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š
      _ âˆ£ <span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±
Least common multiple of a finite set ">lcm</span> <span class="lean-const" data-name="id" data-signature="id.{u} {Î± : Sort u} (a : Î±) : Î±" data-docs="The identity function. `id` takes an implicit argument `Î± : Sort u`
(a type in any universe), and an argument `a : Î±`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T&#x27;` is definitionally equal to `T`, then `@id T&#x27; e` typechecks, and Lean
knows that this expression has type `T&#x27;` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T&#x27;` may have different
typeclass instances on them. `show T&#x27; from e` is sugar for an `@id T&#x27; e`
expression.
" title="id.{u} {Î± : Sort u} (a : Î±) : Î±
The identity function. `id` takes an implicit argument `Î± : Sort u`...">id</span><span class="lean-bracket-1">)</span> - <span class="lean-expr" data-type="â„š[X]" title="â„š[X]">1</span> := <span class="lean-var" data-type="âˆ€ (d n : â„•), d âˆ£ n â†’ X ^ d - 1 âˆ£ X ^ n - 1" title="âˆ€ (d n : â„•), d âˆ£ n â†’ X ^ d - 1 âˆ£ X ^ n - 1">X_pow_sub_one_dvd</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±
Least common multiple of a finite set ">lcm</span> <span class="lean-const" data-name="id" data-signature="id.{u} {Î± : Sort u} (a : Î±) : Î±" data-docs="The identity function. `id` takes an implicit argument `Î± : Sort u`
(a type in any universe), and an argument `a : Î±`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T&#x27;` is definitionally equal to `T`, then `@id T&#x27; e` typechecks, and Lean
knows that this expression has type `T&#x27;` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T&#x27;` may have different
typeclass instances on them. `show T&#x27; from e` is sugar for an `@id T&#x27; e`
expression.
" title="id.{u} {Î± : Sort u} (a : Î±) : Î±
The identity function. `id` takes an implicit argument `Î± : Sort u`...">id</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="d âˆ£ S.lcm id" title="d âˆ£ S.lcm id">hd_dvd_lcm</span>
  <span class="lean-comment">-- Therefore A^</span><span class="lean-bracket-1">{</span>lcm<span class="lean-bracket-2">(</span>S<span class="lean-bracket-2">)</span><span class="lean-bracket-1">}</span> = <span class="lean-number">1</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="A ^ S.lcm id = 1" title="A ^ S.lcm id = 1">hpow_lcm</span> : <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> ^ <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±
Least common multiple of a finite set ">lcm</span> <span class="lean-const" data-name="id" data-signature="id.{u} {Î± : Sort u} (a : Î±) : Î±" data-docs="The identity function. `id` takes an implicit argument `Î± : Sort u`
(a type in any universe), and an argument `a : Î±`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T&#x27;` is definitionally equal to `T`, then `@id T&#x27; e` typechecks, and Lean
knows that this expression has type `T&#x27;` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T&#x27;` may have different
typeclass instances on them. `show T&#x27; from e` is sugar for an `@id T&#x27; e`
expression.
" title="id.{u} {Î± : Sort u} (a : Î±) : Î±
The identity function. `id` takes an implicit argument `Î± : Sort u`...">id</span><span class="lean-bracket-1">)</span> = <span class="lean-expr" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">1</span> :=
    <span class="lean-const" data-name="Matrix.pow_eq_one_of_minpoly_dvd_X_pow_sub_one" data-signature="Matrix.pow_eq_one_of_minpoly_dvd_X_pow_sub_one {N : â„•} (A : Matrix (Fin N) (Fin N) â„¤) (k : â„•)
  (hdvd : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ k - 1) : A ^ k = 1" data-docs="If the minimal polynomial of an integer matrix A divides X^k - 1, then A^k = 1.
This transfers the polynomial identity back to the matrix via the ring homomorphism. " title="Matrix.pow_eq_one_of_minpoly_dvd_X_pow_sub_one {N : â„•} (A : Matrix (Fin N) (Fin N) â„¤) (k : â„•)
  (hdvd : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ k - 1) : A ^ k = 1
If the minimal polynomial of an integer matrix A divides X^k - 1, then A^k = 1....">Matrix.pow_eq_one_of_minpoly_dvd_X_pow_sub_one</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±
Least common multiple of a finite set ">lcm</span> <span class="lean-const" data-name="id" data-signature="id.{u} {Î± : Sort u} (a : Î±) : Î±" data-docs="The identity function. `id` takes an implicit argument `Î± : Sort u`
(a type in any universe), and an argument `a : Î±`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T&#x27;` is definitionally equal to `T`, then `@id T&#x27; e` typechecks, and Lean
knows that this expression has type `T&#x27;` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T&#x27;` may have different
typeclass instances on them. `show T&#x27; from e` is sugar for an `@id T&#x27; e`
expression.
" title="id.{u} {Î± : Sort u} (a : Î±) : Î±
The identity function. `id` takes an implicit argument `Î± : Sort u`...">id</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="minpoly â„š A_Q âˆ£ X ^ S.lcm id - 1" title="minpoly â„š A_Q âˆ£ X ^ S.lcm id - 1">hminpoly_dvd_lcm</span>
  <span class="lean-comment">-- But orderOf A = m &gt; lcm</span><span class="lean-bracket-1">(</span>S<span class="lean-bracket-1">)</span>, so orderOf A | lcm<span class="lean-bracket-1">(</span>S<span class="lean-bracket-1">)</span> is false
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="orderOf A âˆ£ S.lcm id" title="orderOf A âˆ£ S.lcm id">hord_dvd</span> := <span class="lean-const" data-name="orderOf_dvd_of_pow_eq_one" data-signature="orderOf_dvd_of_pow_eq_one.{u_1} {G : Type u_1} [Monoid G] {x : G} {n : â„•} (h : x ^ n = 1) : orderOf x âˆ£ n" title="orderOf_dvd_of_pow_eq_one.{u_1} {G : Type u_1} [Monoid G] {x : G} {n : â„•} (h : x ^ n = 1) : orderOf x âˆ£ n">orderOf_dvd_of_pow_eq_one</span> <span class="lean-var" data-type="A ^ S.lcm id = 1" title="A ^ S.lcm id = 1">hpow_lcm</span>
  <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="orderOf A = m" title="orderOf A = m">hA_ord</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`
* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="orderOf A âˆ£ S.lcm id" title="orderOf A âˆ£ S.lcm id">hord_dvd</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> := <span class="lean-const" data-name="Nat.le_of_dvd" data-signature="Nat.le_of_dvd {m n : â„•} (h : 0 &lt; n) : m âˆ£ n â†’ m â‰¤ n" title="Nat.le_of_dvd {m n : â„•} (h : 0 &lt; n) : m âˆ£ n â†’ m â‰¤ n">Nat.le_of_dvd</span> <span class="lean-var" data-type="0 &lt; S.lcm id" title="0 &lt; S.lcm id">hlcm_pos</span> <span class="lean-var" data-type="m âˆ£ S.lcm id" title="m âˆ£ S.lcm id">hord_dvd</span>
  <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Forward.lean#L203-L257" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:cyclotomic-divisors-lcm-eq');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:forward-direction">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.7</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#thm:forward-direction">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000050"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0003.html#integerMatrixOrders-def">Definition 3.0.1</a></li>
          
          <li><a href="sect0002.html#psi-def">Definition 2.0.2</a></li>
          
          <li><a href="sect0002.html#lem:sum-totient-ge-psi">Theorem 2.0.12</a></li>
          
          <li><a href="sect0005.html#lem:minpoly-eq-prod-cyclotomic">Theorem 5.0.5</a></li>
          
          <li><a href="sect0002.html#psiPrimePow-def">Definition 2.0.1</a></li>
          
          <li><a href="sect0005.html#lem:cyclotomic-divisors-lcm-eq">Theorem 5.0.6</a></li>
          
          <li><a href="sect0002.html#lem:sum-totient-ge-psi">Theorem 2.0.12</a></li>
          
          <li><a href="sect0005.html#lem:minpoly-dvd-X-pow-sub-one">Theorem 5.0.2</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.psi_le_of_mem_integerMatrixOrders" class="lean_decl">Crystallographic.psi_le_of_mem_integerMatrixOrders</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>        <b class="bfseries">Forward Direction:</b> If \(m \in \mathrm{Ord}_N\), then \(\psi (m) \leq N\). </p>
<p><b class="bfseries">Mathematical context:</b> The key insight is that integer matrices with finite order have constrained eigenvalues: if \(A^m = I\), all eigenvalues are \(m\)-th roots of unity. The minimal polynomial over \(\mathbb {Q}\) factors into cyclotomic polynomials \(\Phi _d\) for various divisors \(d\) of \(m\). The requirement that \(\mathrm{ord}(A) = m\) (not some proper divisor) forces the set of cyclotomic factors to have \(\mathrm{lcm} = m\), which constrains the total degree. </p>
<p><b class="bfseries">Proof outline:</b> </p>
<ol class="enumerate">
  <li><p>Let \(A\) be an \(N \times N\) integer matrix with \(\mathrm{ord}(A) = m\). </p>
</li>
  <li><p>The minimal polynomial of \(A\) over \(\mathbb {Q}\) divides \(X^m - 1 = \prod _{d \mid m} \Phi _d\). </p>
</li>
  <li><p>Since \(\Phi _d\) are irreducible and pairwise coprime over \(\mathbb {Q}\), the minimal polynomial equals \(\prod _{d \in S} \Phi _d\) for some \(S \subseteq \mathrm{divisors}(m)\). </p>
</li>
  <li><p>The condition \(\mathrm{ord}(A) = m\) forces \(\mathrm{lcm}(S) = m\): if \(\mathrm{lcm}(S) {\lt} m\), then \(A^{\mathrm{lcm}(S)} = I\), contradicting \(\mathrm{ord}(A) = m\). </p>
</li>
  <li><p>The degree of the minimal polynomial is \(\sum _{d \in S} \varphi (d)\). </p>
</li>
  <li><p>By the sum-totient lemma (applied to any \(S\) with \(\mathrm{lcm}(S) = m\)), \(\psi (m) \leq \sum _{d \in S} \varphi (d) = \deg (\mathrm{minpoly}) \leq \deg (\mathrm{charpoly}) = N\). </p>
</li>
</ol>


    </div>
    <div class="proof_wrapper proof_inline" id="a0000000050">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p> Let \(A\) be an \(N \times N\) integer matrix with \(A^m = I\). The minimal polynomial \(\mu _A\) over \(\mathbb {Q}\) divides \(X^m - 1\) and factors into cyclotomic polynomials \(\Phi _d\) for various \(d \mid m\). Each factor contributes \(\varphi (d)\) to \(\deg (\mu _A) \leq N\). Since distinct \(\Phi _d\) are coprime and their lcm must be \(m\), summing the totients of appearing divisors gives \(\psi (m) \leq N\). - </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">theorem</span> <span class="lean-const lean-def" data-name="Crystallographic.psi_le_of_mem_integerMatrixOrders" data-signature="Crystallographic.psi_le_of_mem_integerMatrixOrders (N m : â„•) (hm : 0 &lt; m) (hord : m âˆˆ integerMatrixOrders N) : psi m â‰¤ N" data-docs="If an N x N integer matrix has finite order m, then psi(m) &lt;= N.

This is the forward direction of the crystallographic restriction theorem.
The proof uses eigenvalue theory: primitive m-th roots of unity must appear
as eigenvalues, and their algebraic degree constrains the matrix dimension.

**Proof outline:**
1. An integer matrix A with A^m = 1 has minimal polynomial dividing X^m - 1
2. If orderOf A = m, then the minimal polynomial is lcm of cyclotomic polynomials
   Î¦_d for some divisors d of m with lcm(d) = m
3. The primitive m-th roots have minimal polynomial Phi_m (the cyclotomic polynomial)
4. These eigenvalues require dimension &gt;= phi(d) for each d in the set
5. By sum_totient_ge_psi_of_lcm_eq, the sum of Ï†(d) &gt;= psi(m)
6. Therefore psi(m) &lt;= deg(minpoly) &lt;= deg(charpoly) = N
" title="Crystallographic.psi_le_of_mem_integerMatrixOrders (N m : â„•) (hm : 0 &lt; m) (hord : m âˆˆ integerMatrixOrders N) : psi m â‰¤ N
If an N x N integer matrix has finite order m, then psi(m) &lt;= N....">psi_le_of_mem_integerMatrixOrders</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">N</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> : â„•<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span> : <span class="lean-expr" data-type="â„•" title="â„•">0</span> &lt; <span class="lean-var" data-type="â„•" title="â„•">m</span><span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="m âˆˆ integerMatrixOrders N" title="m âˆˆ integerMatrixOrders N">hord</span> : <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-operator">âˆˆ</span> <span class="lean-const" data-name="Crystallographic.integerMatrixOrders" data-signature="Crystallographic.integerMatrixOrders (N : â„•) : Set â„•" data-docs="The set of possible orders for NÃ—N integer matrices with finite order.
An integer `m` is in this set if there exists an NÃ—N integer matrix `A` such that
`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). " title="Crystallographic.integerMatrixOrders (N : â„•) : Set â„•
The set of possible orders for NÃ—N integer matrices with finite order....">integerMatrixOrders</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-1">)</span> : <span class="lean-const" data-name="Crystallographic.psi" data-signature="Crystallographic.psi (m : â„•) : â„•" data-docs="The psi function for crystallographic restriction.
psi(m) is the minimum dimension N such that an NÃ—N integer matrix can have order m.

Defined as the sum over prime power factors: if m = prod p_i^{k_i}, then
psi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) " title="Crystallographic.psi (m : â„•) : â„•
The psi function for crystallographic restriction....">Crystallographic.psi</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-operator">â‰¤</span> N := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-comment">-- Extract the matrix A with orderOf A = m</span>
  <span class="lean-keyword" data-docs="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for
a description of supported patterns.

```lean
obtain âŸ¨pattâŸ© : type := proof
```
is equivalent to
```lean
have h : type := proof
rcases h with âŸ¨pattâŸ©
```

If `âŸ¨pattâŸ©` is omitted, `rcases` will try to infer the pattern.

If `type` is omitted, `:= proof` is required.
" title="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for">obtain</span> <span class="lean-bracket-1">âŸ¨</span><span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span>, <span class="lean-var" data-type="orderOf A = m" title="orderOf A = m">hA_ord</span>, _<span class="lean-bracket-1">âŸ©</span> := <span class="lean-var" data-type="m âˆˆ integerMatrixOrders N" title="m âˆˆ integerMatrixOrders N">hord</span>
  <span class="lean-comment">-- Handle the case N = <span class="lean-number">0</span> separately</span>
  <span class="lean-keyword" data-docs="`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to
destructure hypotheses or expressions composed of inductive types like `h1 : a âˆ§ b âˆ§ c âˆ¨ d` or
`h2 : âˆƒ x y, trans_rel R x y`. Usual usage might be `rcases h1 with âŸ¨ha, hb, hcâŸ© | hd` or
`rcases h2 with âŸ¨x, y, _ | âŸ¨z, hxz, hzyâŸ©âŸ©` for these examples.

Each element of an `rcases` pattern is matched against a particular local hypothesis (most of which
are generated during the execution of `rcases` and represent individual elements destructured from
the input expression). An `rcases` pattern has the following grammar:

* A name like `x`, which names the active hypothesis as `x`.
* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the
  hypothesis).
* A hyphen `-`, which clears the active hypothesis and any dependents.
* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the
  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).
* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it
  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)
* A tuple pattern `âŸ¨p1, p2, p3âŸ©`, which matches a constructor with many arguments, or a series
  of nested conjunctions or existentials. For example if the active hypothesis is `a âˆ§ b âˆ§ c`,
  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`
  and so on.
* A `@` before a tuple pattern as in `@âŸ¨p1, p2, p3âŸ©` will bind all arguments in the constructor,
  while leaving the `@` off will only use the patterns on the explicit arguments.
* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,
  or a nested disjunction like `a âˆ¨ b âˆ¨ c`.

A pattern like `âŸ¨a, b, câŸ© | âŸ¨d, eâŸ©` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `âŸ¨âŸ¨aâŸ©, b | câŸ© | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `âŸ¨a, b, câŸ©` for splitting on
`âˆƒ x, âˆƒ y, p x`, then it will be treated as `âŸ¨a, âŸ¨b, câŸ©âŸ©`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an
assumption `h : e = PAT` will be added to the context.
" title="`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to">rcases</span> <span class="lean-const" data-name="Nat.eq_zero_or_pos" data-signature="Nat.eq_zero_or_pos (n : â„•) : n = 0 âˆ¨ n &gt; 0" title="Nat.eq_zero_or_pos (n : â„•) : n = 0 âˆ¨ n &gt; 0">Nat.eq_zero_or_pos</span> <span class="lean-var" data-type="â„•" title="â„•">N</span> <span class="lean-keyword">with</span> <span class="lean-var" data-type="N = 0" title="N = 0">rfl</span> | <span class="lean-var" data-type="N &gt; 0" title="N &gt; 0">hN_pos</span>
  <span class="lean-operator">Â·</span> <span class="lean-comment">-- N = <span class="lean-number">0</span>: The only <span class="lean-number">0</span><span class="lean-operator">Ã—</span><span class="lean-number">0</span> matrix is empty, with order <span class="lean-number">1</span></span>
    <span class="lean-keyword" data-docs="`haveI` behaves like `have`, but inlines the value instead of producing a `have` term. " title="`haveI` behaves like `have`, but inlines the value instead of producing a `have` term. ">haveI</span> : <span class="lean-const" data-name="IsEmpty" data-signature="IsEmpty.{u_4} (Î± : Sort u_4) : Prop" data-docs="`IsEmpty Î±` expresses that `Î±` is empty. " title="IsEmpty.{u_4} (Î± : Sort u_4) : Prop
`IsEmpty Î±` expresses that `Î±` is empty. ">IsEmpty</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : â„•) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : â„•) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-expr" data-type="â„•" title="â„•">0</span><span class="lean-bracket-1">)</span> := <span class="lean-const" data-name="Fin.isEmpty" data-signature="Fin.isEmpty : IsEmpty (Fin 0)" title="Fin.isEmpty : IsEmpty (Fin 0)">Fin.isEmpty</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="A = 1" title="A = 1">hA_eq_1</span> : <span class="lean-var" data-type="Matrix (Fin 0) (Fin 0) â„¤" title="Matrix (Fin 0) (Fin 0) â„¤">A</span> = <span class="lean-expr" data-type="Matrix (Fin 0) (Fin 0) â„¤" title="Matrix (Fin 0) (Fin 0) â„¤">1</span> := <span class="lean-const" data-name="Matrix.ext" data-signature="Matrix.ext.{v, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {M N : Matrix m n Î±} :
  (âˆ€ (i : m) (j : n), M i j = N i j) â†’ M = N" title="Matrix.ext.{v, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {M N : Matrix m n Î±} :
  (âˆ€ (i : m) (j : n), M i j = N i j) â†’ M = N">Matrix.ext</span> <span class="lean-keyword">fun</span> <span class="lean-var" data-type="Fin 0" title="Fin 0">i</span> =&gt; <span class="lean-const" data-name="Fin.elim0" data-signature="Fin.elim0.{u} {Î± : Sort u} : Fin 0 â†’ Î±" data-docs="The type `Fin 0` is uninhabited, so it can be used to derive any result whatsoever.

This is similar to `Empty.elim`. It can be thought of as a compiler-checked assertion that a code
path is unreachable, or a logical contradiction from which `False` and thus anything else could be
derived.
" title="Fin.elim0.{u} {Î± : Sort u} : Fin 0 â†’ Î±
The type `Fin 0` is uninhabited, so it can be used to derive any result whatsoever....">Fin.elim0</span> <span class="lean-var" data-type="Fin 0" title="Fin 0">i</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="A = 1" title="A = 1">hA_eq_1</span>, <span class="lean-const" data-name="orderOf_one" data-signature="orderOf_one.{u_1} {G : Type u_1} [Monoid G] : orderOf 1 = 1" title="orderOf_one.{u_1} {G : Type u_1} [Monoid G] : orderOf 1 = 1">orderOf_one</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`
* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="orderOf A = m" title="orderOf A = m">hA_ord</span>
    <span class="lean-keyword" data-docs="`subst x...` substitutes each hypothesis `x` with a definition found in the local context,
then eliminates the hypothesis.
- If `x` is a local definition, then its definition is used.
- Otherwise, if there is a hypothesis of the form `x = e` or `e = x`,
  then `e` is used for the definition of `x`.

If `h : a = b`, then `subst h` may be used if either `a` or `b` unfolds to a local hypothesis.
This is similar to the `cases h` tactic.

See also: `subst_vars` for substituting all local hypotheses that have a defining equation.
" title="`subst x...` substitutes each hypothesis `x` with a definition found in the local context,">subst</span> <span class="lean-var" data-type="1 = m" title="1 = m">hA_ord</span>
    <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Crystallographic.psi_one" data-signature="Crystallographic.psi_one : psi 1 = 0" data-docs="`psi 1 = 0`: The identity matrix has order 1 in any dimension. " title="Crystallographic.psi_one : psi 1 = 0
`psi 1 = 0`: The identity matrix has order 1 in any dimension. ">Crystallographic.psi_one</span><span class="lean-bracket-1">]</span>
  <span class="lean-operator">Â·</span> <span class="lean-comment">-- N &gt; <span class="lean-number">0</span>: Use psi <span class="lean-operator">â‰¤</span> deg</span><span class="lean-bracket-1">(</span>minpoly<span class="lean-bracket-1">)</span> <span class="lean-operator">â‰¤</span> deg<span class="lean-bracket-1">(</span>charpoly<span class="lean-bracket-1">)</span> = N
    <span class="lean-keyword" data-docs="`haveI` behaves like `have`, but inlines the value instead of producing a `have` term. " title="`haveI` behaves like `have`, but inlines the value instead of producing a `have` term. ">haveI</span> : <span class="lean-const" data-name="NeZero" data-signature="NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop" data-docs="A type-class version of `n â‰  0`.  " title="NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop
A type-class version of `n â‰  0`.  ">NeZero</span> <span class="lean-var" data-type="â„•" title="â„•">N</span> := <span class="lean-const" data-signature="NeZero.mk.{u_1} {R : Type u_1} [Zero R] {n : R} (out : n â‰  0) : NeZero n" title="NeZero.mk.{u_1} {R : Type u_1} [Zero R] {n : R} (out : n â‰  0) : NeZero n">âŸ¨</span><span class="lean-const" data-name="Nat.pos_iff_ne_zero" data-signature="Nat.pos_iff_ne_zero {n : â„•} : 0 &lt; n â†” n â‰  0" title="Nat.pos_iff_ne_zero {n : â„•} : 0 &lt; n â†” n â‰  0">Nat.pos_iff_ne_zero</span>.<span class="lean-const" data-name="Iff.mp" data-signature="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b" data-docs="Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. " title="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b
Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. ">mp</span> <span class="lean-var" data-type="N &gt; 0" title="N &gt; 0">hN_pos</span><span class="lean-const" data-signature="NeZero.mk.{u_1} {R : Type u_1} [Zero R] {n : R} (out : n â‰  0) : NeZero n" title="NeZero.mk.{u_1} {R : Type u_1} [Zero R] {n : R} (out : n â‰  0) : NeZero n">âŸ©</span>
    <span class="lean-keyword" data-docs="The `let` tactic is for adding definitions to the local context of the main goal.
The definition can be unfolded, unlike definitions introduced by `have`.

* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.
* `let x := e` uses the type of `e` for `t`.
* `let : t := e` and `let := e` use `this` for the name of the hypothesis.
* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that let only one applicable constructor.
  For example, given `p : Î± Ã— Î² Ã— Î³`, `let âŸ¨x, y, zâŸ© := p` produces the
  local variables `x : Î±`, `y : Î²`, and `z : Î³`.
* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `let` term.

## Properties and relations

* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics
  such as `simp`, `dsimp`, `unfold`, and `subst`.
* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.
  The tactic might fail if the local context depends on the value of the variable.
* The `let` tactic is preferred for data (non-propositions).
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
" title="The `let` tactic is for adding definitions to the local context of the main goal.">let</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span> := <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span>.<span class="lean-const" data-name="Matrix.map" data-signature="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²" data-docs="`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.

This is available in bundled forms as:
* `AddMonoidHom.mapMatrix`
* `LinearMap.mapMatrix`
* `RingHom.mapMatrix`
* `AlgHom.mapMatrix`
* `Equiv.mapMatrix`
* `AddEquiv.mapMatrix`
* `LinearEquiv.mapMatrix`
* `RingEquiv.mapMatrix`
* `AlgEquiv.mapMatrix`
" title="Matrix.map.{v, w, u_2, u_3} {m : Type u_2} {n : Type u_3} {Î± : Type v} {Î² : Type w} (M : Matrix m n Î±) (f : Î± â†’ Î²) :
  Matrix m n Î²
`M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`....">map</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="algebraMap" data-signature="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A" data-docs="Embedding `R â†’+* A` given by `Algebra` structure. " title="algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R â†’+* A
Embedding `R â†’+* A` given by `Algebra` structure. ">algebraMap</span> â„¤ â„š<span class="lean-bracket-1">)</span>
    <span class="lean-comment">-- The minimal polynomial degree is at most N</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(minpoly â„š A_Q).natDegree â‰¤ N" title="(minpoly â„š A_Q).natDegree â‰¤ N">hminpoly_deg_le</span> : <span class="lean-bracket-1">(</span><span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : â„•" data-docs="`natDegree p` forces `degree p` to â„•, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : â„•
`natDegree p` forces `degree p` to â„•, by defining `natDegree 0 = 0`. ">natDegree</span> <span class="lean-operator">â‰¤</span> <span class="lean-var" data-type="â„•" title="â„•">N</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="minpoly â„š A_Q âˆ£ A_Q.charpoly" title="minpoly â„š A_Q âˆ£ A_Q.charpoly">hdvd</span> := <span class="lean-const" data-name="Matrix.minpoly_dvd_charpoly" data-signature="Matrix.minpoly_dvd_charpoly.{v, u_1} {n : Type v} [DecidableEq n] [Fintype n] {K : Type u_1} [Field K]
  (M : Matrix n n K) : minpoly K M âˆ£ M.charpoly" title="Matrix.minpoly_dvd_charpoly.{v, u_1} {n : Type v} [DecidableEq n] [Fintype n] {K : Type u_1} [Field K]
  (M : Matrix n n K) : minpoly K M âˆ£ M.charpoly">Matrix.minpoly_dvd_charpoly</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="A_Q.charpoly â‰  0" title="A_Q.charpoly â‰  0">hne</span> : <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span>.<span class="lean-const" data-name="Matrix.charpoly" data-signature="Matrix.charpoly.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  R[X]" data-docs="The characteristic polynomial of a matrix `M` is given by $\det (t I - M)$. " title="Matrix.charpoly.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  R[X]
The characteristic polynomial of a matrix `M` is given by $\det (t I - M)$. ">charpoly</span> <span class="lean-operator">â‰ </span> <span class="lean-expr" data-type="â„š[X]" title="â„š[X]">0</span> := <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Matrix.charpoly_monic" data-signature="Matrix.charpoly_monic.{u, v} {R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  M.charpoly.Monic" title="Matrix.charpoly_monic.{u, v} {R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  M.charpoly.Monic">Matrix.charpoly_monic</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Polynomial.Monic.ne_zero" data-signature="Polynomial.Monic.ne_zero.{u} {R : Type u} [Semiring R] [Nontrivial R] {p : R[X]} (hp : p.Monic) : p â‰  0" title="Polynomial.Monic.ne_zero.{u} {R : Type u} [Semiring R] [Nontrivial R] {p : R[X]} (hp : p.Monic) : p â‰  0">ne_zero</span>
      <span class="lean-keyword" data-docs="Step-wise reasoning over transitive relations.
```
calc
  a = b := pab
  b = c := pbc
  ...
  y = z := pyz
```
proves `a = z` from the given step-wise proofs. `=` can be replaced with any
relation implementing the typeclass `Trans`. Instead of repeating the right-
hand sides, subsequent left-hand sides can be replaced with `_`.
```
calc
  a = b := pab
  _ = c := pbc
  ...
  _ = z := pyz
```
It is also possible to write the *first* relation as `&lt;lhs&gt;\n  _ = &lt;rhs&gt; :=
&lt;proof&gt;`. This is useful for aligning relation symbols, especially on longer:
identifiers:
```
calc abc
  _ = bce := pabce
  _ = cef := pbcef
  ...
  _ = xyz := pwxyz
```

`calc` works as a term, as a tactic or as a `conv` tactic.

See [Theorem Proving in Lean 4][tpil4] for more information.

[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs
" title="Step-wise reasoning over transitive relations.">calc</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : â„•" data-docs="`natDegree p` forces `degree p` to â„•, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : â„•
`natDegree p` forces `degree p` to â„•, by defining `natDegree 0 = 0`. ">natDegree</span> <span class="lean-operator">â‰¤</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span>.<span class="lean-const" data-name="Matrix.charpoly" data-signature="Matrix.charpoly.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  R[X]" data-docs="The characteristic polynomial of a matrix `M` is given by $\det (t I - M)$. " title="Matrix.charpoly.{u_1, u_4} {R : Type u_1} [CommRing R] {n : Type u_4} [DecidableEq n] [Fintype n] (M : Matrix n n R) :
  R[X]
The characteristic polynomial of a matrix `M` is given by $\det (t I - M)$. ">charpoly</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : â„•" data-docs="`natDegree p` forces `degree p` to â„•, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : â„•
`natDegree p` forces `degree p` to â„•, by defining `natDegree 0 = 0`. ">natDegree</span> :=
          <span class="lean-const" data-name="Polynomial.natDegree_le_of_dvd" data-signature="Polynomial.natDegree_le_of_dvd.{u} {R : Type u} [Semiring R] [NoZeroDivisors R] {p q : R[X]} (h1 : p âˆ£ q) (h2 : q â‰  0) :
  p.natDegree â‰¤ q.natDegree" title="Polynomial.natDegree_le_of_dvd.{u} {R : Type u} [Semiring R] [NoZeroDivisors R] {p q : R[X]} (h1 : p âˆ£ q) (h2 : q â‰  0) :
  p.natDegree â‰¤ q.natDegree">Polynomial.natDegree_le_of_dvd</span> <span class="lean-var" data-type="minpoly â„š A_Q âˆ£ A_Q.charpoly" title="minpoly â„š A_Q âˆ£ A_Q.charpoly">hdvd</span> <span class="lean-var" data-type="A_Q.charpoly â‰  0" title="A_Q.charpoly â‰  0">hne</span>
        _ = <span class="lean-const" data-name="Fintype.card" data-signature="Fintype.card.{u_4} (Î± : Type u_4) [Fintype Î±] : â„•" data-docs="`card Î±` is the number of elements in `Î±`, defined when `Î±` is a fintype. " title="Fintype.card.{u_4} (Î± : Type u_4) [Fintype Î±] : â„•
`card Î±` is the number of elements in `Î±`, defined when `Î±` is a fintype. ">Fintype.card</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Fin" data-signature="Fin (n : â„•) : Type" data-docs="Natural numbers less than some upper bound.

In particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the
canonical type with `n` elements.
" title="Fin (n : â„•) : Type
Natural numbers less than some upper bound....">Fin</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-1">)</span> := <span class="lean-const" data-name="Matrix.charpoly_natDegree_eq_dim" data-signature="Matrix.charpoly_natDegree_eq_dim.{u, v} {R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n]
  [Nontrivial R] (M : Matrix n n R) : M.charpoly.natDegree = Fintype.card n" title="Matrix.charpoly_natDegree_eq_dim.{u, v} {R : Type u} [CommRing R] {n : Type v} [DecidableEq n] [Fintype n]
  [Nontrivial R] (M : Matrix n n R) : M.charpoly.natDegree = Fintype.card n">Matrix.charpoly_natDegree_eq_dim</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span>
        _ = <span class="lean-var" data-type="â„•" title="â„•">N</span> := <span class="lean-const" data-name="Fintype.card_fin" data-signature="Fintype.card_fin (n : â„•) : Fintype.card (Fin n) = n" title="Fintype.card_fin (n : â„•) : Fintype.card (Fin n) = n">Fintype.card_fin</span> <span class="lean-var" data-type="â„•" title="â„•">N</span>
    <span class="lean-comment">-- minpoly | X^m - <span class="lean-number">1</span> since A^m = <span class="lean-number">1</span></span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="A ^ m = 1" title="A ^ m = 1">hpow</span> : <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> ^ <span class="lean-var" data-type="â„•" title="â„•">m</span> = <span class="lean-expr" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">1</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-operator">â†</span> <span class="lean-var" data-type="orderOf A = m" title="orderOf A = m">hA_ord</span><span class="lean-bracket-1">]</span>; <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="pow_orderOf_eq_one" data-signature="pow_orderOf_eq_one.{u_1} {G : Type u_1} [Monoid G] (x : G) : x ^ orderOf x = 1" title="pow_orderOf_eq_one.{u_1} {G : Type u_1} [Monoid G] (x : G) : x ^ orderOf x = 1">pow_orderOf_eq_one</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="minpoly â„š A_Q âˆ£ X ^ m - 1" title="minpoly â„š A_Q âˆ£ X ^ m - 1">hminpoly_dvd</span> : <span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span> âˆ£ <span class="lean-const" data-name="Polynomial.X" data-signature="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]" data-docs="`X` is the polynomial variable (aka indeterminate). " title="Polynomial.X.{u} {R : Type u} [Semiring R] : R[X]
`X` is the polynomial variable (aka indeterminate). ">X</span> ^ <span class="lean-var" data-type="â„•" title="â„•">m</span> - <span class="lean-expr" data-type="â„š[X]" title="â„š[X]">1</span> :=
      <span class="lean-const" data-name="Matrix.minpoly_dvd_X_pow_sub_one_of_pow_eq_one" data-signature="Matrix.minpoly_dvd_X_pow_sub_one_of_pow_eq_one {N : â„•} (A : Matrix (Fin N) (Fin N) â„¤) (m : â„•) (hpow : A ^ m = 1) :
  minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1" data-docs="If A^m = 1, then the minimal polynomial of A divides X^m - 1.
This is because X^m - 1 annihilates A, and the minimal polynomial divides any annihilating polynomial. " title="Matrix.minpoly_dvd_X_pow_sub_one_of_pow_eq_one {N : â„•} (A : Matrix (Fin N) (Fin N) â„¤) (m : â„•) (hpow : A ^ m = 1) :
  minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1
If A^m = 1, then the minimal polynomial of A divides X^m - 1....">Matrix.minpoly_dvd_X_pow_sub_one_of_pow_eq_one</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-var" data-type="A ^ m = 1" title="A ^ m = 1">hpow</span>
    <span class="lean-comment">-- Get S and the product decomposition from helper lemma</span>
    <span class="lean-keyword" data-docs="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for
a description of supported patterns.

```lean
obtain âŸ¨pattâŸ© : type := proof
```
is equivalent to
```lean
have h : type := proof
rcases h with âŸ¨pattâŸ©
```

If `âŸ¨pattâŸ©` is omitted, `rcases` will try to infer the pattern.

If `type` is omitted, `:= proof` is required.
" title="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for">obtain</span> <span class="lean-bracket-1">âŸ¨</span><span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>, <span class="lean-var" data-type="âˆ€ d âˆˆ S, d âˆ£ m" title="âˆ€ d âˆˆ S, d âˆ£ m">hS_sub</span>, <span class="lean-var" data-type="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š" title="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š">hminpoly_eq_prod</span><span class="lean-bracket-1">âŸ©</span> :=
      <span class="lean-const" data-name="Crystallographic.minpoly_eq_prod_cyclotomic_of_dvd_X_pow_sub_one" data-signature="Crystallographic.minpoly_eq_prod_cyclotomic_of_dvd_X_pow_sub_one {N : â„•} [NeZero N] (A : Matrix (Fin N) (Fin N) â„¤)
  (m : â„•) (hm : 0 &lt; m) (hminpoly_dvd : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1) :
  âˆƒ S, (âˆ€ d âˆˆ S, d âˆ£ m) âˆ§ minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š" data-docs="For a polynomial that divides X^m - 1, we can characterize it as a product of cyclotomic
polynomials. Specifically, S = {d âˆˆ divisors(m) | Î¦_d âˆ£ p} gives minpoly = âˆ_{dâˆˆS} Î¦_d
when p is monic and irreducible factors are coprime. " title="Crystallographic.minpoly_eq_prod_cyclotomic_of_dvd_X_pow_sub_one {N : â„•} [NeZero N] (A : Matrix (Fin N) (Fin N) â„¤)
  (m : â„•) (hm : 0 &lt; m) (hminpoly_dvd : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) âˆ£ X ^ m - 1) :
  âˆƒ S, (âˆ€ d âˆˆ S, d âˆ£ m) âˆ§ minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š
For a polynomial that divides X^m - 1, we can characterize it as a product of cyclotomic...">minpoly_eq_prod_cyclotomic_of_dvd_X_pow_sub_one</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span> <span class="lean-var" data-type="minpoly â„š A_Q âˆ£ X ^ m - 1" title="minpoly â„š A_Q âˆ£ X ^ m - 1">hminpoly_dvd</span>
    <span class="lean-comment">-- The lcm of S equals m </span><span class="lean-bracket-1">(</span>otherwise order would be smaller<span class="lean-bracket-1">)</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="S.lcm id = m" title="S.lcm id = m">hS_lcm</span> : <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>.<span class="lean-const" data-name="Finset.lcm" data-signature="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±" data-docs="Least common multiple of a finite set " title="Finset.lcm.{u_2, u_3} {Î± : Type u_2} {Î² : Type u_3} [CancelCommMonoidWithZero Î±] [NormalizedGCDMonoid Î±] (s : Finset Î²)
  (f : Î² â†’ Î±) : Î±
Least common multiple of a finite set ">lcm</span> <span class="lean-const" data-name="id" data-signature="id.{u} {Î± : Sort u} (a : Î±) : Î±" data-docs="The identity function. `id` takes an implicit argument `Î± : Sort u`
(a type in any universe), and an argument `a : Î±`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T&#x27;` is definitionally equal to `T`, then `@id T&#x27; e` typechecks, and Lean
knows that this expression has type `T&#x27;` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T&#x27;` may have different
typeclass instances on them. `show T&#x27; from e` is sugar for an `@id T&#x27; e`
expression.
" title="id.{u} {Î± : Sort u} (a : Î±) : Î±
The identity function. `id` takes an implicit argument `Î± : Sort u`...">id</span> = <span class="lean-var" data-type="â„•" title="â„•">m</span> :=
      <span class="lean-const" data-name="Crystallographic.cyclotomic_divisors_lcm_eq_of_orderOf" data-signature="Crystallographic.cyclotomic_divisors_lcm_eq_of_orderOf {N : â„•} [NeZero N] (A : Matrix (Fin N) (Fin N) â„¤) (m : â„•)
  (hm : 0 &lt; m) (hA_ord : orderOf A = m) (S : Finset â„•) (hS_sub : âˆ€ d âˆˆ S, d âˆ£ m)
  (hminpoly_eq_prod : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š) : S.lcm id = m" data-docs="If A has order m and minpoly = âˆ_{dâˆˆS} Î¦_d where S âŠ† divisors(m),
then S.lcm id = m. This is the key lemma: if lcm(S) &lt; m, then A^{lcm(S)} = 1,
contradicting that A has exact order m. " title="Crystallographic.cyclotomic_divisors_lcm_eq_of_orderOf {N : â„•} [NeZero N] (A : Matrix (Fin N) (Fin N) â„¤) (m : â„•)
  (hm : 0 &lt; m) (hA_ord : orderOf A = m) (S : Finset â„•) (hS_sub : âˆ€ d âˆˆ S, d âˆ£ m)
  (hminpoly_eq_prod : minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š) : S.lcm id = m
If A has order m and minpoly = âˆ_{dâˆˆS} Î¦_d where S âŠ† divisors(m),...">cyclotomic_divisors_lcm_eq_of_orderOf</span> <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„¤" title="Matrix (Fin N) (Fin N) â„¤">A</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span> <span class="lean-var" data-type="orderOf A = m" title="orderOf A = m">hA_ord</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> <span class="lean-var" data-type="âˆ€ d âˆˆ S, d âˆ£ m" title="âˆ€ d âˆˆ S, d âˆ£ m">hS_sub</span> <span class="lean-var" data-type="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š" title="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š">hminpoly_eq_prod</span>
    <span class="lean-comment">-- Compute the degree as sum of totients</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(minpoly â„š A_Q).natDegree = âˆ‘ d âˆˆ S, d.totient" title="(minpoly â„š A_Q).natDegree = âˆ‘ d âˆˆ S, d.totient">hdeg_eq</span> : <span class="lean-bracket-1">(</span><span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : â„•" data-docs="`natDegree p` forces `degree p` to â„•, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : â„•
`natDegree p` forces `degree p` to â„•, by defining `natDegree 0 = 0`. ">natDegree</span> = <span class="lean-operator">âˆ‘</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>, <span class="lean-const" data-name="Nat.totient" data-signature="Nat.totient (n : â„•) : â„•" data-docs="Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are
coprime with `n`. " title="Nat.totient (n : â„•) : â„•
Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are...">Nat.totient</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
      <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š" title="minpoly â„š (A.map â‡‘(algebraMap â„¤ â„š)) = âˆ d âˆˆ S, cyclotomic d â„š">hminpoly_eq_prod</span>, <span class="lean-const" data-name="Polynomial.natDegree_prod" data-signature="Polynomial.natDegree_prod.{u, w} {R : Type u} {Î¹ : Type w} (s : Finset Î¹) [CommSemiring R] [NoZeroDivisors R]
  (f : Î¹ â†’ R[X]) (h : âˆ€ i âˆˆ s, f i â‰  0) : (âˆ i âˆˆ s, f i).natDegree = âˆ‘ i âˆˆ s, (f i).natDegree" data-docs="The degree of a product of polynomials is equal to
the sum of the degrees.

See `Polynomial.natDegree_prod&#x27;` (with a `&#x27;`) for a version for commutative semirings,
where additionally, the product of the leading coefficients must be nonzero.
" title="Polynomial.natDegree_prod.{u, w} {R : Type u} {Î¹ : Type w} (s : Finset Î¹) [CommSemiring R] [NoZeroDivisors R]
  (f : Î¹ â†’ R[X]) (h : âˆ€ i âˆˆ s, f i â‰  0) : (âˆ i âˆˆ s, f i).natDegree = âˆ‘ i âˆˆ s, (f i).natDegree
The degree of a product of polynomials is equal to...">Polynomial.natDegree_prod</span> _ _ <span class="lean-bracket-2">(</span><span class="lean-keyword">fun</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> _ =&gt; <span class="lean-const" data-name="Polynomial.cyclotomic_ne_zero" data-signature="Polynomial.cyclotomic_ne_zero.{u_1} (n : â„•) (R : Type u_1) [Ring R] [Nontrivial R] : cyclotomic n R â‰  0" data-docs="`cyclotomic n R` is different from `0`. " title="Polynomial.cyclotomic_ne_zero.{u_1} (n : â„•) (R : Type u_1) [Ring R] [Nontrivial R] : cyclotomic n R â‰  0
`cyclotomic n R` is different from `0`. ">cyclotomic_ne_zero</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š<span class="lean-bracket-2">)</span><span class="lean-bracket-1">]</span>
      <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Finset.sum_congr" data-signature="Finset.sum_congr.{u_1, u_4} {Î¹ : Type u_1} {M : Type u_4} {sâ‚ sâ‚‚ : Finset Î¹} [AddCommMonoid M] {f g : Î¹ â†’ M}
  (h : sâ‚ = sâ‚‚) : (âˆ€ x âˆˆ sâ‚‚, f x = g x) â†’ sâ‚.sum f = sâ‚‚.sum g" title="Finset.sum_congr.{u_1, u_4} {Î¹ : Type u_1} {M : Type u_4} {sâ‚ sâ‚‚ : Finset Î¹} [AddCommMonoid M] {f g : Î¹ â†’ M}
  (h : sâ‚ = sâ‚‚) : (âˆ€ x âˆˆ sâ‚‚, f x = g x) â†’ sâ‚.sum f = sâ‚‚.sum g">Finset.sum_congr</span> <span class="lean-const" data-name="rfl" data-signature="rfl.{u} {Î± : Sort u} {a : Î±} : a = a" data-docs="`rfl : a = a` is the unique constructor of the equality type. This is the
same as `Eq.refl` except that it takes `a` implicitly instead of explicitly.

This is a more powerful theorem than it may appear at first, because although
the statement of the theorem is `a = a`, Lean will allow anything that is
definitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in
Lean by `rfl`, because both sides are the same up to definitional equality.
" title="rfl.{u} {Î± : Sort u} {a : Î±} : a = a
`rfl : a = a` is the unique constructor of the equality type. This is the...">rfl</span> <span class="lean-bracket-1">(</span><span class="lean-keyword">fun</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> _ =&gt; <span class="lean-const" data-name="Polynomial.natDegree_cyclotomic" data-signature="Polynomial.natDegree_cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] [Nontrivial R] :
  (cyclotomic n R).natDegree = n.totient" data-docs="The natural degree of `cyclotomic n` is `totient n`. " title="Polynomial.natDegree_cyclotomic.{u_1} (n : â„•) (R : Type u_1) [Ring R] [Nontrivial R] :
  (cyclotomic n R).natDegree = n.totient
The natural degree of `cyclotomic n` is `totient n`. ">natDegree_cyclotomic</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> â„š<span class="lean-bracket-1">)</span>
    <span class="lean-comment">-- Apply sum_totient_ge_psi_of_lcm_eq</span>
    <span class="lean-keyword" data-docs="Step-wise reasoning over transitive relations.
```
calc
  a = b := pab
  b = c := pbc
  ...
  y = z := pyz
```
proves `a = z` from the given step-wise proofs. `=` can be replaced with any
relation implementing the typeclass `Trans`. Instead of repeating the right-
hand sides, subsequent left-hand sides can be replaced with `_`.
```
calc
  a = b := pab
  _ = c := pbc
  ...
  _ = z := pyz
```
It is also possible to write the *first* relation as `&lt;lhs&gt;\n  _ = &lt;rhs&gt; :=
&lt;proof&gt;`. This is useful for aligning relation symbols, especially on longer:
identifiers:
```
calc abc
  _ = bce := pabce
  _ = cef := pbcef
  ...
  _ = xyz := pwxyz
```

`calc` works as a term, as a tactic or as a `conv` tactic.

See [Theorem Proving in Lean 4][tpil4] for more information.

[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs
" title="Step-wise reasoning over transitive relations.">calc</span> <span class="lean-const" data-name="Crystallographic.psi" data-signature="Crystallographic.psi (m : â„•) : â„•" data-docs="The psi function for crystallographic restriction.
psi(m) is the minimum dimension N such that an NÃ—N integer matrix can have order m.

Defined as the sum over prime power factors: if m = prod p_i^{k_i}, then
psi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) " title="Crystallographic.psi (m : â„•) : â„•
The psi function for crystallographic restriction....">Crystallographic.psi</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-operator">â‰¤</span> <span class="lean-operator">âˆ‘</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> <span class="lean-operator">âˆˆ</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span>, <span class="lean-const" data-name="Nat.totient" data-signature="Nat.totient (n : â„•) : â„•" data-docs="Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are
coprime with `n`. " title="Nat.totient (n : â„•) : â„•
Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are...">Nat.totient</span> <span class="lean-var" data-type="â„•" title="â„•">d</span> :=
        <span class="lean-const" data-name="Crystallographic.sum_totient_ge_psi_of_lcm_eq" data-signature="Crystallographic.sum_totient_ge_psi_of_lcm_eq (m : â„•) (hm : 0 &lt; m) (S : Finset â„•) (hS_sub : âˆ€ d âˆˆ S, d âˆ£ m)
  (hS_lcm : S.lcm id = m) : psi m â‰¤ âˆ‘ d âˆˆ S, d.totient" data-docs="Key lemma: For any S âŠ† m.divisors with lcm(S) = m, we have Î£_{dâˆˆS} Ï†(d) â‰¥ psi(m).

This is the combinatorial heart of the forward direction. The minimum is achieved when
S consists of one prime power for each distinct prime in m&#x27;s factorization, giving psi(m).

The proof proceeds by showing that any other choice of S either:
1. Includes redundant elements (increasing the sum), or
2. Uses a composite element d covering multiple prime powers, which costs
   Ï†(d) = Î  Ï†(p^k) â‰¥ Î£ Ï†(p^k) when each Ï†(p^k) â‰¥ 2. " title="Crystallographic.sum_totient_ge_psi_of_lcm_eq (m : â„•) (hm : 0 &lt; m) (S : Finset â„•) (hS_sub : âˆ€ d âˆˆ S, d âˆ£ m)
  (hS_lcm : S.lcm id = m) : psi m â‰¤ âˆ‘ d âˆˆ S, d.totient
Key lemma: For any S âŠ† m.divisors with lcm(S) = m, we have Î£_{dâˆˆS} Ï†(d) â‰¥ psi(m)....">sum_totient_ge_psi_of_lcm_eq</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span> <span class="lean-var" data-type="Finset â„•" title="Finset â„•">S</span> <span class="lean-var" data-type="âˆ€ d âˆˆ S, d âˆ£ m" title="âˆ€ d âˆˆ S, d âˆ£ m">hS_sub</span> <span class="lean-var" data-type="S.lcm id = m" title="S.lcm id = m">hS_lcm</span>
      _ = <span class="lean-bracket-1">(</span><span class="lean-const" data-name="minpoly" data-signature="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]" data-docs="Suppose `x : B`, where `B` is an `A`-algebra.

The minimal polynomial `minpoly A x` of `x`
is a monic polynomial with coefficients in `A` of smallest degree that has `x` as its root,
if such exists (`IsIntegral A x`) or zero otherwise.

For example, if `V` is a `ð•œ`-vector space for some field `ð•œ` and `f : V â†’â‚—[ð•œ] V` then
the minimal polynomial of `f` is `minpoly ð•œ f`.
" title="minpoly.{u_1, u_2} (A : Type u_1) {B : Type u_2} [CommRing A] [Ring B] [Algebra A B] (x : B) : A[X]
Suppose `x : B`, where `B` is an `A`-algebra....">minpoly</span> â„š <span class="lean-var" data-type="Matrix (Fin N) (Fin N) â„š" title="Matrix (Fin N) (Fin N) â„š">A_Q</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Polynomial.natDegree" data-signature="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : â„•" data-docs="`natDegree p` forces `degree p` to â„•, by defining `natDegree 0 = 0`. " title="Polynomial.natDegree.{u} {R : Type u} [Semiring R] (p : R[X]) : â„•
`natDegree p` forces `degree p` to â„•, by defining `natDegree 0 = 0`. ">natDegree</span> := <span class="lean-var" data-type="(minpoly â„š A_Q).natDegree = âˆ‘ d âˆˆ S, d.totient" title="(minpoly â„š A_Q).natDegree = âˆ‘ d âˆˆ S, d.totient">hdeg_eq</span>.<span class="lean-const" data-name="Eq.symm" data-signature="Eq.symm.{u} {Î± : Sort u} {a b : Î±} (h : a = b) : b = a" data-docs="Equality is symmetric: if `a = b` then `b = a`.

Because this is in the `Eq` namespace, if you have a variable `h : a = b`,
`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.

For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
" title="Eq.symm.{u} {Î± : Sort u} {a b : Î±} (h : a = b) : b = a
Equality is symmetric: if `a = b` then `b = a`....">symm</span>
      _ <span class="lean-operator">â‰¤</span> <span class="lean-var" data-type="â„•" title="â„•">N</span> := <span class="lean-var" data-type="(minpoly â„š A_Q).natDegree â‰¤ N" title="(minpoly â„š A_Q).natDegree â‰¤ N">hminpoly_deg_le</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Forward.lean#L259-L346" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:forward-direction');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:permMatrix-one">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.8</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:permMatrix-one">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000051"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Equiv.Perm.permMatrix_one" class="lean_decl">Crystallographic.Equiv.Perm.permMatrix_one</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       The permutation matrix of the identity is the identity matrix: \(P_{\mathrm{id}} = I\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000051">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p>Direct computation using \(\mathrm{toPEquiv}(\mathrm{id}) = \mathrm{refl}\) and \(\mathrm{toMatrix}(\mathrm{refl}) = I\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Crystallographic.Equiv.Perm.permMatrix_one" data-signature="Crystallographic.Equiv.Perm.permMatrix_one.{u_1, u_2} {n : Type u_1} [DecidableEq n] {R : Type u_2} [Zero R] [One R] :
  Equiv.Perm.permMatrix R 1 = 1" data-docs="The permutation matrix of the identity permutation is the identity matrix. " title="Crystallographic.Equiv.Perm.permMatrix_one.{u_1, u_2} {n : Type u_1} [DecidableEq n] {R : Type u_2} [Zero R] [One R] :
  Equiv.Perm.permMatrix R 1 = 1
The permutation matrix of the identity permutation is the identity matrix. ">permMatrix_one</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="Type u_1" title="Type u_1">n</span> : <span class="lean-sort" data-docs="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable
`&gt; 0` for each variable in the sequence. " title="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable">Type*</span><span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="DecidableEq" data-signature="DecidableEq.{u} (Î± : Sort u) : Sort (max 1 u)" data-docs="Propositional equality is `Decidable` for all elements of a type.

In other words, an instance of `DecidableEq Î±` is a means of deciding the proposition `a = b` is
for all `a b : Î±`.
" title="DecidableEq.{u} (Î± : Sort u) : Sort (max 1 u)
Propositional equality is `Decidable` for all elements of a type....">DecidableEq</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="Type u_2" title="Type u_2">R</span> : <span class="lean-sort" data-docs="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable
`&gt; 0` for each variable in the sequence. " title="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable">Type*</span><span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Zero" data-signature="Zero.{u} (Î± : Type u) : Type u" data-docs="A type with a zero element. " title="Zero.{u} (Î± : Type u) : Type u
A type with a zero element. ">Zero</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="One" data-signature="One.{u} (Î± : Type u) : Type u" data-docs="A type with a &quot;one&quot; element. " title="One.{u} (Î± : Type u) : Type u
A type with a &quot;one&quot; element. ">One</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span><span class="lean-bracket-1">]</span> :
    <span class="lean-bracket-1">(</span><span class="lean-expr" data-type="Equiv.Perm n" title="Equiv.Perm n">1</span> : <span class="lean-const" data-name="Equiv.Perm" data-signature="Equiv.Perm.{u_1} (Î± : Sort u_1) : Sort (max 1 u_1)" data-docs="`Perm Î±` is the type of bijections from `Î±` to itself. " title="Equiv.Perm.{u_1} (Î± : Sort u_1) : Sort (max 1 u_1)
`Perm Î±` is the type of bijections from `Î±` to itself. ">Equiv.Perm</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">permMatrix</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span> = <span class="lean-bracket-1">(</span><span class="lean-expr" data-type="Matrix n n R" title="Matrix n n R">1</span> : <span class="lean-const" data-name="Matrix" data-signature="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (Î± : Type v) : Type (max u u&#x27; v)" data-docs="`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`
and whose columns are indexed by `n`. " title="Matrix.{u, u&#x27;, v} (m : Type u) (n : Type u&#x27;) (Î± : Type v) : Type (max u u&#x27; v)
`Matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m`...">Matrix</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span><span class="lean-bracket-1">)</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">Equiv.Perm.permMatrix</span>, <span class="lean-const" data-name="Equiv.Perm.one_def" data-signature="Equiv.Perm.one_def.{u_4} {Î± : Type u_4} : 1 = Equiv.refl Î±" title="Equiv.Perm.one_def.{u_4} {Î± : Type u_4} : 1 = Equiv.refl Î±">Equiv.Perm.one_def</span>, <span class="lean-const" data-name="Equiv.toPEquiv_refl" data-signature="Equiv.toPEquiv_refl.{u_1} {Î± : Type u_1} : (Equiv.refl Î±).toPEquiv = PEquiv.refl Î±" title="Equiv.toPEquiv_refl.{u_1} {Î± : Type u_1} : (Equiv.refl Î±).toPEquiv = PEquiv.refl Î±">Equiv.toPEquiv_refl</span>, <span class="lean-const" data-name="PEquiv.toMatrix_refl" data-signature="PEquiv.toMatrix_refl.{u_4, u_5} {n : Type u_4} {Î± : Type u_5} [DecidableEq n] [Zero Î±] [One Î±] :
  (PEquiv.refl n).toMatrix = 1" title="PEquiv.toMatrix_refl.{u_4, u_5} {n : Type u_4} {Î± : Type u_5} [DecidableEq n] [Zero Î±] [One Î±] :
  (PEquiv.refl n).toMatrix = 1">PEquiv.toMatrix_refl</span><span class="lean-bracket-1">]</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L67-L74" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:permMatrix-one');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:permMatrix-mul">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.9</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:permMatrix-mul">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000052"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Equiv.Perm.permMatrix_mul" class="lean_decl">Crystallographic.Equiv.Perm.permMatrix_mul</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       Permutation matrices satisfy \(P_{\sigma \cdot \tau } = P_\tau \cdot P_\sigma \) (contravariant homomorphism). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000052">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p>Follows from \(\mathrm{toPEquiv}(\sigma \circ \tau ) = \mathrm{toPEquiv}(\tau ) \cdot \mathrm{toPEquiv}(\sigma )\) and the corresponding property for partial equivalence matrices. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Crystallographic.Equiv.Perm.permMatrix_mul" data-signature="Crystallographic.Equiv.Perm.permMatrix_mul.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] (Ïƒ Ï„ : Equiv.Perm n) :
  Equiv.Perm.permMatrix R (Ïƒ * Ï„) = Equiv.Perm.permMatrix R Ï„ * Equiv.Perm.permMatrix R Ïƒ" data-docs="Permutation matrices compose: (Ïƒ * Ï„).permMatrix = Ï„.permMatrix * Ïƒ.permMatrix " title="Crystallographic.Equiv.Perm.permMatrix_mul.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] (Ïƒ Ï„ : Equiv.Perm n) :
  Equiv.Perm.permMatrix R (Ïƒ * Ï„) = Equiv.Perm.permMatrix R Ï„ * Equiv.Perm.permMatrix R Ïƒ
Permutation matrices compose: (Ïƒ * Ï„).permMatrix = Ï„.permMatrix * Ïƒ.permMatrix ">permMatrix_mul</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="Type u_1" title="Type u_1">n</span> : <span class="lean-sort" data-docs="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable
`&gt; 0` for each variable in the sequence. " title="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable">Type*</span><span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="DecidableEq" data-signature="DecidableEq.{u} (Î± : Sort u) : Sort (max 1 u)" data-docs="Propositional equality is `Decidable` for all elements of a type.

In other words, an instance of `DecidableEq Î±` is a means of deciding the proposition `a = b` is
for all `a b : Î±`.
" title="DecidableEq.{u} (Î± : Sort u) : Sort (max 1 u)
Propositional equality is `Decidable` for all elements of a type....">DecidableEq</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Fintype" data-signature="Fintype.{u_4} (Î± : Type u_4) : Type u_4" data-docs="`Fintype Î±` means that `Î±` is finite, i.e. there are only
finitely many distinct elements of type `Î±`. The evidence of this
is a finset `elems` (a list up to permutation without duplicates),
together with a proof that everything of type `Î±` is in the list. " title="Fintype.{u_4} (Î± : Type u_4) : Type u_4
`Fintype Î±` means that `Î±` is finite, i.e. there are only...">Fintype</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="Type u_2" title="Type u_2">R</span> : <span class="lean-sort" data-docs="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable
`&gt; 0` for each variable in the sequence. " title="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable">Type*</span><span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Semiring" data-signature="Semiring.{u} (Î± : Type u) : Type u" data-docs="A `Semiring` is a type with addition, multiplication, a `0` and a `1` where addition is
commutative and associative, multiplication is associative and left and right distributive over
addition, and `0` and `1` are additive and multiplicative identities. " title="Semiring.{u} (Î± : Type u) : Type u
A `Semiring` is a type with addition, multiplication, a `0` and a `1` where addition is...">Semiring</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span><span class="lean-bracket-1">]</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span> <span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ï„</span> : <span class="lean-const" data-name="Equiv.Perm" data-signature="Equiv.Perm.{u_1} (Î± : Sort u_1) : Sort (max 1 u_1)" data-docs="`Perm Î±` is the type of bijections from `Î±` to itself. " title="Equiv.Perm.{u_1} (Î± : Sort u_1) : Sort (max 1 u_1)
`Perm Î±` is the type of bijections from `Î±` to itself. ">Equiv.Perm</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span><span class="lean-bracket-1">)</span> :
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span> * <span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ï„</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">permMatrix</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span> = <span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ï„</span>.<span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">permMatrix</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span> * <span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span>.<span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">permMatrix</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">Equiv.Perm.permMatrix</span><span class="lean-bracket-1">]</span>
  <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Equiv.Perm.mul_def" data-signature="Equiv.Perm.mul_def.{u_4} {Î± : Type u_4} (f g : Equiv.Perm Î±) : f * g = Equiv.trans g f" title="Equiv.Perm.mul_def.{u_4} {Î± : Type u_4} (f g : Equiv.Perm Î±) : f * g = Equiv.trans g f">Equiv.Perm.mul_def</span>, <span class="lean-const" data-name="Equiv.toPEquiv_trans" data-signature="Equiv.toPEquiv_trans.{u_1, u_2, u_3} {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (f : Î± â‰ƒ Î²) (g : Î² â‰ƒ Î³) :
  (f.trans g).toPEquiv = f.toPEquiv.trans g.toPEquiv" title="Equiv.toPEquiv_trans.{u_1, u_2, u_3} {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (f : Î± â‰ƒ Î²) (g : Î² â‰ƒ Î³) :
  (f.trans g).toPEquiv = f.toPEquiv.trans g.toPEquiv">Equiv.toPEquiv_trans</span>, <span class="lean-const" data-name="PEquiv.toMatrix_trans" data-signature="PEquiv.toMatrix_trans.{u_2, u_3, u_4, u_5} {l : Type u_2} {m : Type u_3} {n : Type u_4} {Î± : Type u_5} [Fintype m]
  [DecidableEq m] [DecidableEq n] [NonAssocSemiring Î±] (f : l â‰ƒ. m) (g : m â‰ƒ. n) :
  (f.trans g).toMatrix = f.toMatrix * g.toMatrix" title="PEquiv.toMatrix_trans.{u_2, u_3, u_4, u_5} {l : Type u_2} {m : Type u_3} {n : Type u_4} {Î± : Type u_5} [Fintype m]
  [DecidableEq m] [DecidableEq n] [NonAssocSemiring Î±] (f : l â‰ƒ. m) (g : m â‰ƒ. n) :
  (f.trans g).toMatrix = f.toMatrix * g.toMatrix">PEquiv.toMatrix_trans</span><span class="lean-bracket-1">]</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L76-L86" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:permMatrix-mul');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:permMatrix-pow">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.10</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:permMatrix-pow">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000053"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0005.html#lem:permMatrix-one">Theorem 5.0.8</a></li>
          
          <li><a href="sect0005.html#lem:permMatrix-mul">Theorem 5.0.9</a></li>
          
          <li><a href="sect0005.html#lem:permMatrix-one">Theorem 5.0.8</a></li>
          
          <li><a href="sect0005.html#lem:permMatrix-mul">Theorem 5.0.9</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Equiv.Perm.permMatrix_pow" class="lean_decl">Crystallographic.Equiv.Perm.permMatrix_pow</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       Powers of permutation matrices satisfy \(P_{\sigma ^k} = P_\sigma ^k\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000053">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p> By induction on \(k\): the base case uses \(P_{\mathrm{id}} = I\), and the inductive step uses \(P_{\sigma \cdot \tau } = P_\tau \cdot P_\sigma \) together with commutativity of powers. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Crystallographic.Equiv.Perm.permMatrix_pow" data-signature="Crystallographic.Equiv.Perm.permMatrix_pow.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] (Ïƒ : Equiv.Perm n) (k : â„•) : Equiv.Perm.permMatrix R (Ïƒ ^ k) = Equiv.Perm.permMatrix R Ïƒ ^ k" data-docs="Permutation matrices power correctly: (Ïƒ^k).permMatrix = (Ïƒ.permMatrix)^k " title="Crystallographic.Equiv.Perm.permMatrix_pow.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] (Ïƒ : Equiv.Perm n) (k : â„•) : Equiv.Perm.permMatrix R (Ïƒ ^ k) = Equiv.Perm.permMatrix R Ïƒ ^ k
Permutation matrices power correctly: (Ïƒ^k).permMatrix = (Ïƒ.permMatrix)^k ">permMatrix_pow</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="Type u_1" title="Type u_1">n</span> : <span class="lean-sort" data-docs="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable
`&gt; 0` for each variable in the sequence. " title="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable">Type*</span><span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="DecidableEq" data-signature="DecidableEq.{u} (Î± : Sort u) : Sort (max 1 u)" data-docs="Propositional equality is `Decidable` for all elements of a type.

In other words, an instance of `DecidableEq Î±` is a means of deciding the proposition `a = b` is
for all `a b : Î±`.
" title="DecidableEq.{u} (Î± : Sort u) : Sort (max 1 u)
Propositional equality is `Decidable` for all elements of a type....">DecidableEq</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Fintype" data-signature="Fintype.{u_4} (Î± : Type u_4) : Type u_4" data-docs="`Fintype Î±` means that `Î±` is finite, i.e. there are only
finitely many distinct elements of type `Î±`. The evidence of this
is a finset `elems` (a list up to permutation without duplicates),
together with a proof that everything of type `Î±` is in the list. " title="Fintype.{u_4} (Î± : Type u_4) : Type u_4
`Fintype Î±` means that `Î±` is finite, i.e. there are only...">Fintype</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="Type u_2" title="Type u_2">R</span> : <span class="lean-sort" data-docs="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable
`&gt; 0` for each variable in the sequence. " title="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable">Type*</span><span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Semiring" data-signature="Semiring.{u} (Î± : Type u) : Type u" data-docs="A `Semiring` is a type with addition, multiplication, a `0` and a `1` where addition is
commutative and associative, multiplication is associative and left and right distributive over
addition, and `0` and `1` are additive and multiplicative identities. " title="Semiring.{u} (Î± : Type u) : Type u
A `Semiring` is a type with addition, multiplication, a `0` and a `1` where addition is...">Semiring</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span><span class="lean-bracket-1">]</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span> : <span class="lean-const" data-name="Equiv.Perm" data-signature="Equiv.Perm.{u_1} (Î± : Sort u_1) : Sort (max 1 u_1)" data-docs="`Perm Î±` is the type of bijections from `Î±` to itself. " title="Equiv.Perm.{u_1} (Î± : Sort u_1) : Sort (max 1 u_1)
`Perm Î±` is the type of bijections from `Î±` to itself. ">Equiv.Perm</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">k</span> : â„•<span class="lean-bracket-1">)</span> :
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span> ^ <span class="lean-var" data-type="â„•" title="â„•">k</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">permMatrix</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span> = <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span>.<span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">permMatrix</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span><span class="lean-bracket-1">)</span> ^ <span class="lean-var" data-type="â„•" title="â„•">k</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="Assuming `x` is a variable in the local context with an inductive type,
`induction x` applies induction on `x` to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on `x`,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,
`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,
and one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.
Here the names `a` and `ihâ‚` are chosen automatically and are not accessible.
You can use `with` to provide the variables names for each constructor.
- `induction e`, where `e` is an expression instead of a variable,
  generalizes `e` in the goal, and then performs induction on the resulting variable.
- `induction e using r` allows the user to specify the principle of induction that should be used.
  Here `r` should be a term whose result type must be of the form `C t`,
  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables
- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,
  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.
  In other words, the net effect is that each inductive hypothesis is generalized.
- Given `x : Nat`, `induction x with | zero =&gt; tacâ‚ | succ x&#x27; ih =&gt; tacâ‚‚`
  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.
" title="Assuming `x` is a variable in the local context with an inductive type,">induction</span> <span class="lean-var" data-type="â„•" title="â„•">k</span> <span class="lean-keyword" data-docs="After `with`, there is an optional tactic that runs on all branches, and
then a list of alternatives.
" title="After `with`, there is an optional tactic that runs on all branches, and">with</span>
  | <span class="lean-const" data-name="Nat.zero" data-signature="Nat.zero : â„•" data-docs="Zero, the smallest natural number.

Using `Nat.zero` explicitly should usually be avoided in favor of the literal `0`, which is the
[simp normal form](https://lean-lang.org/doc/reference/4.27.0-rc1/find/?domain=Verso.Genre.Manual.section&amp;name=simp-normal-forms).
" title="Nat.zero : â„•
Zero, the smallest natural number....">zero</span> =&gt; <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Crystallographic.Equiv.Perm.permMatrix_one" data-signature="Crystallographic.Equiv.Perm.permMatrix_one.{u_1, u_2} {n : Type u_1} [DecidableEq n] {R : Type u_2} [Zero R] [One R] :
  Equiv.Perm.permMatrix R 1 = 1" data-docs="The permutation matrix of the identity permutation is the identity matrix. " title="Crystallographic.Equiv.Perm.permMatrix_one.{u_1, u_2} {n : Type u_1} [DecidableEq n] {R : Type u_2} [Zero R] [One R] :
  Equiv.Perm.permMatrix R 1 = 1
The permutation matrix of the identity permutation is the identity matrix. ">permMatrix_one</span><span class="lean-bracket-1">]</span>
  | <span class="lean-const" data-name="Nat.succ" data-signature="Nat.succ (n : â„•) : â„•" data-docs="The successor of a natural number `n`.

Using `Nat.succ n` should usually be avoided in favor of `n + 1`, which is the [simp normal
form](https://lean-lang.org/doc/reference/4.27.0-rc1/find/?domain=Verso.Genre.Manual.section&amp;name=simp-normal-forms).
" title="Nat.succ (n : â„•) : â„•
The successor of a natural number `n`....">succ</span> <span class="lean-var" data-type="â„•" title="â„•">k</span> <span class="lean-var" data-type="Equiv.Perm.permMatrix R (Ïƒ ^ k) = Equiv.Perm.permMatrix R Ïƒ ^ k" title="Equiv.Perm.permMatrix R (Ïƒ ^ k) = Equiv.Perm.permMatrix R Ïƒ ^ k">ih</span> =&gt;
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="pow_succ" data-signature="pow_succ.{u_2} {M : Type u_2} [Monoid M] (a : M) (n : â„•) : a ^ (n + 1) = a ^ n * a" title="pow_succ.{u_2} {M : Type u_2} [Monoid M] (a : M) (n : â„•) : a ^ (n + 1) = a ^ n * a">pow_succ</span>, <span class="lean-const" data-name="pow_succ" data-signature="pow_succ.{u_2} {M : Type u_2} [Monoid M] (a : M) (n : â„•) : a ^ (n + 1) = a ^ n * a" title="pow_succ.{u_2} {M : Type u_2} [Monoid M] (a : M) (n : â„•) : a ^ (n + 1) = a ^ n * a">pow_succ</span>, <span class="lean-const" data-name="Crystallographic.Equiv.Perm.permMatrix_mul" data-signature="Crystallographic.Equiv.Perm.permMatrix_mul.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] (Ïƒ Ï„ : Equiv.Perm n) :
  Equiv.Perm.permMatrix R (Ïƒ * Ï„) = Equiv.Perm.permMatrix R Ï„ * Equiv.Perm.permMatrix R Ïƒ" data-docs="Permutation matrices compose: (Ïƒ * Ï„).permMatrix = Ï„.permMatrix * Ïƒ.permMatrix " title="Crystallographic.Equiv.Perm.permMatrix_mul.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] (Ïƒ Ï„ : Equiv.Perm n) :
  Equiv.Perm.permMatrix R (Ïƒ * Ï„) = Equiv.Perm.permMatrix R Ï„ * Equiv.Perm.permMatrix R Ïƒ
Permutation matrices compose: (Ïƒ * Ï„).permMatrix = Ï„.permMatrix * Ïƒ.permMatrix ">permMatrix_mul</span>, <span class="lean-var" data-type="Equiv.Perm.permMatrix R (Ïƒ ^ k) = Equiv.Perm.permMatrix R Ïƒ ^ k" title="Equiv.Perm.permMatrix R (Ïƒ ^ k) = Equiv.Perm.permMatrix R Ïƒ ^ k">ih</span><span class="lean-bracket-1">]</span>
    <span class="lean-comment">-- Goal: Ïƒ.permMatrix * </span><span class="lean-bracket-1">(</span>Ïƒ.permMatrix<span class="lean-bracket-1">)</span>^k = <span class="lean-bracket-1">(</span>Ïƒ.permMatrix<span class="lean-bracket-1">)</span>^k * Ïƒ.permMatrix
    <span class="lean-comment">-- Use SemiconjBy or direct equality - both sides are equal</span>
    <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Commute.pow_self" data-signature="Commute.pow_self.{u_2} {M : Type u_2} [Monoid M] (a : M) (n : â„•) : Commute (a ^ n) a" title="Commute.pow_self.{u_2} {M : Type u_2} [Monoid M] (a : M) (n : â„•) : Commute (a ^ n) a">Commute.pow_self</span> <span class="lean-bracket-2">(</span><span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span>.<span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">permMatrix</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span><span class="lean-bracket-2">)</span> <span class="lean-var" data-type="â„•" title="â„•">k</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Commute.eq" data-signature="Commute.eq.{u_3} {S : Type u_3} [Mul S] {a b : S} (h : Commute a b) : a * b = b * a" data-docs="Equality behind `Commute a b`; useful for rewriting. " title="Commute.eq.{u_3} {S : Type u_3} [Mul S] {a b : S} (h : Commute a b) : a * b = b * a
Equality behind `Commute a b`; useful for rewriting. ">eq</span>.<span class="lean-const" data-name="Eq.symm" data-signature="Eq.symm.{u} {Î± : Sort u} {a b : Î±} (h : a = b) : b = a" data-docs="Equality is symmetric: if `a = b` then `b = a`.

Because this is in the `Eq` namespace, if you have a variable `h : a = b`,
`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.

For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
" title="Eq.symm.{u} {Î± : Sort u} {a b : Î±} (h : a = b) : b = a
Equality is symmetric: if `a = b` then `b = a`....">symm</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L88-L103" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:permMatrix-pow');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:permMatrix-eq-one-iff">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.11</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:permMatrix-eq-one-iff">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000054"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0005.html#lem:permMatrix-one">Theorem 5.0.8</a></li>
          
          <li><a href="sect0005.html#lem:permMatrix-one">Theorem 5.0.8</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Equiv.Perm.permMatrix_eq_one_iff" class="lean_decl">Crystallographic.Equiv.Perm.permMatrix_eq_one_iff</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       \(P_\sigma = I\) if and only if \(\sigma = \mathrm{id}\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000054">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p> The forward direction shows that if \(P_\sigma = I\) then for each \(x\), the entry \((P_\sigma )_{x, \sigma (x)} = 1\) forces \(\sigma (x) = x\). The reverse is immediate from \(P_{\mathrm{id}} = I\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Crystallographic.Equiv.Perm.permMatrix_eq_one_iff" data-signature="Crystallographic.Equiv.Perm.permMatrix_eq_one_iff.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] [Nontrivial R] (Ïƒ : Equiv.Perm n) : Equiv.Perm.permMatrix R Ïƒ = 1 â†” Ïƒ = 1" data-docs="Permutation matrix is identity iff permutation is identity. " title="Crystallographic.Equiv.Perm.permMatrix_eq_one_iff.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] [Nontrivial R] (Ïƒ : Equiv.Perm n) : Equiv.Perm.permMatrix R Ïƒ = 1 â†” Ïƒ = 1
Permutation matrix is identity iff permutation is identity. ">permMatrix_eq_one_iff</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="Type u_1" title="Type u_1">n</span> : <span class="lean-sort" data-docs="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable
`&gt; 0` for each variable in the sequence. " title="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable">Type*</span><span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="DecidableEq" data-signature="DecidableEq.{u} (Î± : Sort u) : Sort (max 1 u)" data-docs="Propositional equality is `Decidable` for all elements of a type.

In other words, an instance of `DecidableEq Î±` is a means of deciding the proposition `a = b` is
for all `a b : Î±`.
" title="DecidableEq.{u} (Î± : Sort u) : Sort (max 1 u)
Propositional equality is `Decidable` for all elements of a type....">DecidableEq</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Fintype" data-signature="Fintype.{u_4} (Î± : Type u_4) : Type u_4" data-docs="`Fintype Î±` means that `Î±` is finite, i.e. there are only
finitely many distinct elements of type `Î±`. The evidence of this
is a finset `elems` (a list up to permutation without duplicates),
together with a proof that everything of type `Î±` is in the list. " title="Fintype.{u_4} (Î± : Type u_4) : Type u_4
`Fintype Î±` means that `Î±` is finite, i.e. there are only...">Fintype</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="Type u_2" title="Type u_2">R</span> : <span class="lean-sort" data-docs="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable
`&gt; 0` for each variable in the sequence. " title="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable">Type*</span><span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Semiring" data-signature="Semiring.{u} (Î± : Type u) : Type u" data-docs="A `Semiring` is a type with addition, multiplication, a `0` and a `1` where addition is
commutative and associative, multiplication is associative and left and right distributive over
addition, and `0` and `1` are additive and multiplicative identities. " title="Semiring.{u} (Î± : Type u) : Type u
A `Semiring` is a type with addition, multiplication, a `0` and a `1` where addition is...">Semiring</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span><span class="lean-bracket-1">]</span>
    <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Nontrivial" data-signature="Nontrivial.{u_3} (Î± : Type u_3) : Prop" data-docs="Predicate typeclass for expressing that a type is not reduced to a single element. In rings,
this is equivalent to `0 â‰  1`. In vector spaces, this is equivalent to positive dimension. " title="Nontrivial.{u_3} (Î± : Type u_3) : Prop
Predicate typeclass for expressing that a type is not reduced to a single element. In rings,...">Nontrivial</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span> : <span class="lean-const" data-name="Equiv.Perm" data-signature="Equiv.Perm.{u_1} (Î± : Sort u_1) : Sort (max 1 u_1)" data-docs="`Perm Î±` is the type of bijections from `Î±` to itself. " title="Equiv.Perm.{u_1} (Î± : Sort u_1) : Sort (max 1 u_1)
`Perm Î±` is the type of bijections from `Î±` to itself. ">Equiv.Perm</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span><span class="lean-bracket-1">)</span> :
    <span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span>.<span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">permMatrix</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span> = <span class="lean-expr" data-type="Matrix n n R" title="Matrix n n R">1</span> <span class="lean-operator">â†”</span> <span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span> = <span class="lean-expr" data-type="Equiv.Perm n" title="Equiv.Perm n">1</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="If the main goal&#x27;s target type is an inductive type, `constructor` solves it with
the first matching constructor, or else fails.
" title="If the main goal&#x27;s target type is an inductive type, `constructor` solves it with">constructor</span>
  <span class="lean-operator">Â·</span> <span class="lean-keyword" data-docs="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal&#x27;s target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`. It is equivalent to `intro _`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, given a type ascription, or matched against a pattern:
  ```lean
  -- ... âŠ¢ Î± Ã— Î² â†’ ...
  intro (a, b)
  -- ..., a : Î±, b : Î² âŠ¢ ...
  ```
* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side
  is a variable.
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
" title="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.">intro</span> <span class="lean-var" data-type="Equiv.Perm.permMatrix R Ïƒ = 1" title="Equiv.Perm.permMatrix R Ïƒ = 1">h</span>
    <span class="lean-keyword" data-docs="Applies extensionality lemmas that are registered with the `@[ext]` attribute.
* `ext pat*` applies extensionality theorems as much as possible,
  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.
  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.
* Without patterns,`ext` applies extensionality lemmas as much
  as possible but introduces anonymous hypotheses whenever needed.
* `ext pat* : n` applies ext theorems only up to depth `n`.

The `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.

Unused patterns will generate warning.
Patterns that don&#x27;t match the variables will typically result in the introduction of anonymous hypotheses.
" title="Applies extensionality lemmas that are registered with the `@[ext]` attribute.">ext</span> <span class="lean-var" data-type="n" title="n">x</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="Equiv.Perm.permMatrix R Ïƒ x (Ïƒ x) = 1 x (Ïƒ x)" title="Equiv.Perm.permMatrix R Ïƒ x (Ïƒ x) = 1 x (Ïƒ x)">hx</span> := <span class="lean-const" data-name="congrFun" data-signature="congrFun.{u, v} {Î± : Sort u} {Î² : Î± â†’ Sort v} {f g : (x : Î±) â†’ Î² x} (h : f = g) (a : Î±) : f a = g a" data-docs="Congruence in the function part of an application: If `f = g` then `f a = g a`. " title="congrFun.{u, v} {Î± : Sort u} {Î² : Î± â†’ Sort v} {f g : (x : Î±) â†’ Î² x} (h : f = g) (a : Î±) : f a = g a
Congruence in the function part of an application: If `f = g` then `f a = g a`. ">congrFun</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="congrFun" data-signature="congrFun.{u, v} {Î± : Sort u} {Î² : Î± â†’ Sort v} {f g : (x : Î±) â†’ Î² x} (h : f = g) (a : Î±) : f a = g a" data-docs="Congruence in the function part of an application: If `f = g` then `f a = g a`. " title="congrFun.{u, v} {Î± : Sort u} {Î² : Î± â†’ Sort v} {f g : (x : Î±) â†’ Î² x} (h : f = g) (a : Î±) : f a = g a
Congruence in the function part of an application: If `f = g` then `f a = g a`. ">congrFun</span> <span class="lean-var" data-type="Equiv.Perm.permMatrix R Ïƒ = 1" title="Equiv.Perm.permMatrix R Ïƒ = 1">h</span> <span class="lean-var" data-type="n" title="n">x</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span> <span class="lean-var" data-type="n" title="n">x</span><span class="lean-bracket-1">)</span>
    <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">Equiv.Perm.permMatrix</span>, <span class="lean-const" data-name="Equiv.toPEquiv_apply" data-signature="Equiv.toPEquiv_apply.{u_1, u_2} {Î± : Type u_1} {Î² : Type u_2} (f : Î± â‰ƒ Î²) (x : Î±) : f.toPEquiv x = some (f x)" title="Equiv.toPEquiv_apply.{u_1, u_2} {Î± : Type u_1} {Î² : Type u_2} (f : Î± â‰ƒ Î²) (x : Î±) : f.toPEquiv x = some (f x)">Equiv.toPEquiv_apply</span>, <span class="lean-const" data-name="PEquiv.toMatrix_apply" data-signature="PEquiv.toMatrix_apply.{u_3, u_4, u_5} {m : Type u_3} {n : Type u_4} {Î± : Type u_5} [DecidableEq n] [Zero Î±] [One Î±]
  (f : m â‰ƒ. n) (i : m) (j : n) : f.toMatrix i j = if j âˆˆ f i then 1 else 0" title="PEquiv.toMatrix_apply.{u_3, u_4, u_5} {m : Type u_3} {n : Type u_4} {Î± : Type u_5} [DecidableEq n] [Zero Î±] [One Î±]
  (f : m â‰ƒ. n) (i : m) (j : n) : f.toMatrix i j = if j âˆˆ f i then 1 else 0">PEquiv.toMatrix_apply</span>, <span class="lean-const" data-name="Matrix.one_apply" data-signature="Matrix.one_apply.{v, u_3} {n : Type u_3} {Î± : Type v} [DecidableEq n] [Zero Î±] [One Î±] {i j : n} :
  1 i j = if i = j then 1 else 0" title="Matrix.one_apply.{v, u_3} {n : Type u_3} {Î± : Type v} [DecidableEq n] [Zero Î±] [One Î±] {i j : n} :
  1 i j = if i = j then 1 else 0">Matrix.one_apply</span>,
      <span class="lean-const" data-name="Option.mem_def" data-signature="Option.mem_def.{u_1} {Î± : Type u_1} {a : Î±} {b : Option Î±} : a âˆˆ b â†” b = some a" title="Option.mem_def.{u_1} {Î± : Type u_1} {a : Î±} {b : Option Î±} : a âˆˆ b â†” b = some a">Option.mem_def</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`
* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="Equiv.Perm.permMatrix R Ïƒ x (Ïƒ x) = 1 x (Ïƒ x)" title="Equiv.Perm.permMatrix R Ïƒ x (Ïƒ x) = 1 x (Ïƒ x)">hx</span>
    <span class="lean-keyword" data-docs="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : Â¬ p` in the second branch.
" title="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `">by_cases</span> <span class="lean-var" data-type="Ïƒ x = x" title="Ïƒ x = x">hÏƒx</span> : <span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span> <span class="lean-var" data-type="n" title="n">x</span> = <span class="lean-var" data-type="n" title="n">x</span>
    <span class="lean-operator">Â·</span> <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-var" data-type="Ïƒ x = x" title="Ïƒ x = x">hÏƒx</span>
    <span class="lean-operator">Â·</span> <span class="lean-keyword" data-docs="`exfalso` converts a goal `âŠ¢ tgt` into `âŠ¢ False` by applying `False.elim`. " title="`exfalso` converts a goal `âŠ¢ tgt` into `âŠ¢ False` by applying `False.elim`. ">exfalso</span>
      <span class="lean-comment">-- hx says: if Ïƒ </span><span class="lean-bracket-1">(</span>Ïƒ x<span class="lean-bracket-1">)</span> = Ïƒ x then <span class="lean-number">1</span> else <span class="lean-number">0</span> = if x = Ïƒ x then <span class="lean-number">1</span> else <span class="lean-number">0</span>
      <span class="lean-comment">-- After simp, lhs simplifies using Ïƒ </span><span class="lean-bracket-1">(</span>Ïƒ x<span class="lean-bracket-1">)</span> = Ïƒ x <span class="lean-operator">â†”</span> Ïƒ x = x <span class="lean-bracket-1">(</span>by injectivity<span class="lean-bracket-1">)</span>
      <span class="lean-comment">-- which is true since Option.mem_def</span>
      <span class="lean-comment">-- rhs: x = Ïƒ x is false by hÏƒx</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="1 = if x = Ïƒ x then 1 else 0" title="1 = if x = Ïƒ x then 1 else 0">h1</span> : <span class="lean-bracket-1">(</span><span class="lean-expr" data-type="R" title="R">1</span> : <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span><span class="lean-bracket-1">)</span> = <span class="lean-keyword" data-docs="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a &quot;dependent if-then-else&quot; `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
" title="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to">if</span> <span class="lean-var" data-type="n" title="n">x</span> = <span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span> <span class="lean-var" data-type="n" title="n">x</span> <span class="lean-keyword" data-docs="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a &quot;dependent if-then-else&quot; `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
" title="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to">then</span> <span class="lean-expr" data-type="R" title="R">1</span> <span class="lean-keyword" data-docs="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a &quot;dependent if-then-else&quot; `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
" title="`if c then t else e` is notation for `ite c t e`, &quot;if-then-else&quot;, which decides to">else</span> <span class="lean-expr" data-type="R" title="R">0</span> := <span class="lean-var" data-type="(if True then 1 else 0) = if x = Ïƒ x then 1 else 0" title="(if True then 1 else 0) = if x = Ïƒ x then 1 else 0">hx</span>
      <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="if_neg" data-signature="if_neg.{u} {c : Prop} {h : Decidable c} (hnc : Â¬c) {Î± : Sort u} {t e : Î±} : (if c then t else e) = e" title="if_neg.{u} {c : Prop} {h : Decidable c} (hnc : Â¬c) {Î± : Sort u} {t e : Î±} : (if c then t else e) = e">if_neg</span> <span class="lean-bracket-2">(</span><span class="lean-const" data-name="ne_comm" data-signature="ne_comm.{u_1} {Î± : Sort u_1} {a b : Î±} : a â‰  b â†” b â‰  a" title="ne_comm.{u_1} {Î± : Sort u_1} {a b : Î±} : a â‰  b â†” b â‰  a">ne_comm</span>.<span class="lean-const" data-name="Iff.mpr" data-signature="Iff.mpr {a b : Prop} (self : a â†” b) : b â†’ a" data-docs="Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. " title="Iff.mpr {a b : Prop} (self : a â†” b) : b â†’ a
Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. ">mpr</span> <span class="lean-var" data-type="Â¬Ïƒ x = x" title="Â¬Ïƒ x = x">hÏƒx</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`
* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="1 = if x = Ïƒ x then 1 else 0" title="1 = if x = Ïƒ x then 1 else 0">h1</span>
      <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="one_ne_zero" data-signature="one_ne_zero.{u_2} {Î± : Type u_2} [Zero Î±] [One Î±] [NeZero 1] : 1 â‰  0" title="one_ne_zero.{u_2} {Î± : Type u_2} [Zero Î±] [One Î±] [NeZero 1] : 1 â‰  0">one_ne_zero</span> <span class="lean-var" data-type="1 = 0" title="1 = 0">h1</span>
  <span class="lean-operator">Â·</span> <span class="lean-keyword" data-docs="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal&#x27;s target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`. It is equivalent to `intro _`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, given a type ascription, or matched against a pattern:
  ```lean
  -- ... âŠ¢ Î± Ã— Î² â†’ ...
  intro (a, b)
  -- ..., a : Î±, b : Î² âŠ¢ ...
  ```
* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side
  is a variable.
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
" title="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.">intro</span> <span class="lean-var" data-type="Ïƒ = 1" title="Ïƒ = 1">h</span>; <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="Ïƒ = 1" title="Ïƒ = 1">h</span><span class="lean-bracket-1">]</span>; <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Crystallographic.Equiv.Perm.permMatrix_one" data-signature="Crystallographic.Equiv.Perm.permMatrix_one.{u_1, u_2} {n : Type u_1} [DecidableEq n] {R : Type u_2} [Zero R] [One R] :
  Equiv.Perm.permMatrix R 1 = 1" data-docs="The permutation matrix of the identity permutation is the identity matrix. " title="Crystallographic.Equiv.Perm.permMatrix_one.{u_1, u_2} {n : Type u_1} [DecidableEq n] {R : Type u_2} [Zero R] [One R] :
  Equiv.Perm.permMatrix R 1 = 1
The permutation matrix of the identity permutation is the identity matrix. ">permMatrix_one</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L105-L131" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:permMatrix-eq-one-iff');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:orderOf-permMatrix">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.12</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:orderOf-permMatrix">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000055"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Equiv.Perm.orderOf_permMatrix" class="lean_decl">Crystallographic.Equiv.Perm.orderOf_permMatrix</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       The order of \(P_\sigma \) equals the order of \(\sigma \) for a permutation matrix. </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000055">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p> Since \(P_{\sigma ^k} = P_\sigma ^k\) and \(P_\sigma = I \iff \sigma = \mathrm{id}\), the order of \(P_\sigma \) equals the order of \(\sigma \). The key is that the permutation matrix map preserves powers and is injective on the group of permutation matrices. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Crystallographic.Equiv.Perm.orderOf_permMatrix" data-signature="Crystallographic.Equiv.Perm.orderOf_permMatrix.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] [Nontrivial R] (Ïƒ : Equiv.Perm n) : orderOf (Equiv.Perm.permMatrix R Ïƒ) = orderOf Ïƒ" data-docs="Order of permutation matrix equals order of permutation. " title="Crystallographic.Equiv.Perm.orderOf_permMatrix.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] [Nontrivial R] (Ïƒ : Equiv.Perm n) : orderOf (Equiv.Perm.permMatrix R Ïƒ) = orderOf Ïƒ
Order of permutation matrix equals order of permutation. ">orderOf_permMatrix</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="Type u_1" title="Type u_1">n</span> : <span class="lean-sort" data-docs="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable
`&gt; 0` for each variable in the sequence. " title="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable">Type*</span><span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="DecidableEq" data-signature="DecidableEq.{u} (Î± : Sort u) : Sort (max 1 u)" data-docs="Propositional equality is `Decidable` for all elements of a type.

In other words, an instance of `DecidableEq Î±` is a means of deciding the proposition `a = b` is
for all `a b : Î±`.
" title="DecidableEq.{u} (Î± : Sort u) : Sort (max 1 u)
Propositional equality is `Decidable` for all elements of a type....">DecidableEq</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Fintype" data-signature="Fintype.{u_4} (Î± : Type u_4) : Type u_4" data-docs="`Fintype Î±` means that `Î±` is finite, i.e. there are only
finitely many distinct elements of type `Î±`. The evidence of this
is a finset `elems` (a list up to permutation without duplicates),
together with a proof that everything of type `Î±` is in the list. " title="Fintype.{u_4} (Î± : Type u_4) : Type u_4
`Fintype Î±` means that `Î±` is finite, i.e. there are only...">Fintype</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">{</span><span class="lean-var" data-type="Type u_2" title="Type u_2">R</span> : <span class="lean-sort" data-docs="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable
`&gt; 0` for each variable in the sequence. " title="The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable">Type*</span><span class="lean-bracket-1">}</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Semiring" data-signature="Semiring.{u} (Î± : Type u) : Type u" data-docs="A `Semiring` is a type with addition, multiplication, a `0` and a `1` where addition is
commutative and associative, multiplication is associative and left and right distributive over
addition, and `0` and `1` are additive and multiplicative identities. " title="Semiring.{u} (Î± : Type u) : Type u
A `Semiring` is a type with addition, multiplication, a `0` and a `1` where addition is...">Semiring</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span><span class="lean-bracket-1">]</span>
    <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Nontrivial" data-signature="Nontrivial.{u_3} (Î± : Type u_3) : Prop" data-docs="Predicate typeclass for expressing that a type is not reduced to a single element. In rings,
this is equivalent to `0 â‰  1`. In vector spaces, this is equivalent to positive dimension. " title="Nontrivial.{u_3} (Î± : Type u_3) : Prop
Predicate typeclass for expressing that a type is not reduced to a single element. In rings,...">Nontrivial</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span><span class="lean-bracket-1">]</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span> : <span class="lean-const" data-name="Equiv.Perm" data-signature="Equiv.Perm.{u_1} (Î± : Sort u_1) : Sort (max 1 u_1)" data-docs="`Perm Î±` is the type of bijections from `Î±` to itself. " title="Equiv.Perm.{u_1} (Î± : Sort u_1) : Sort (max 1 u_1)
`Perm Î±` is the type of bijections from `Î±` to itself. ">Equiv.Perm</span> <span class="lean-var" data-type="Type u_1" title="Type u_1">n</span><span class="lean-bracket-1">)</span> :
    <span class="lean-const" data-name="orderOf" data-signature="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : â„•" data-docs="`orderOf x` is the order of the element `x`, i.e. the `n â‰¥ 1`, s.t. `x ^ n = 1` if it exists.
Otherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. " title="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : â„•
`orderOf x` is the order of the element `x`, i.e. the `n â‰¥ 1`, s.t. `x ^ n = 1` if it exists....">orderOf</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span>.<span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">permMatrix</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span><span class="lean-bracket-1">)</span> = <span class="lean-const" data-name="orderOf" data-signature="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : â„•" data-docs="`orderOf x` is the order of the element `x`, i.e. the `n â‰¥ 1`, s.t. `x ^ n = 1` if it exists.
Otherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. " title="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : â„•
`orderOf x` is the order of the element `x`, i.e. the `n â‰¥ 1`, s.t. `x ^ n = 1` if it exists....">orderOf</span> <span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to
destructure hypotheses or expressions composed of inductive types like `h1 : a âˆ§ b âˆ§ c âˆ¨ d` or
`h2 : âˆƒ x y, trans_rel R x y`. Usual usage might be `rcases h1 with âŸ¨ha, hb, hcâŸ© | hd` or
`rcases h2 with âŸ¨x, y, _ | âŸ¨z, hxz, hzyâŸ©âŸ©` for these examples.

Each element of an `rcases` pattern is matched against a particular local hypothesis (most of which
are generated during the execution of `rcases` and represent individual elements destructured from
the input expression). An `rcases` pattern has the following grammar:

* A name like `x`, which names the active hypothesis as `x`.
* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the
  hypothesis).
* A hyphen `-`, which clears the active hypothesis and any dependents.
* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the
  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).
* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it
  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)
* A tuple pattern `âŸ¨p1, p2, p3âŸ©`, which matches a constructor with many arguments, or a series
  of nested conjunctions or existentials. For example if the active hypothesis is `a âˆ§ b âˆ§ c`,
  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`
  and so on.
* A `@` before a tuple pattern as in `@âŸ¨p1, p2, p3âŸ©` will bind all arguments in the constructor,
  while leaving the `@` off will only use the patterns on the explicit arguments.
* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,
  or a nested disjunction like `a âˆ¨ b âˆ¨ c`.

A pattern like `âŸ¨a, b, câŸ© | âŸ¨d, eâŸ©` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `âŸ¨âŸ¨aâŸ©, b | câŸ© | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `âŸ¨a, b, câŸ©` for splitting on
`âˆƒ x, âˆƒ y, p x`, then it will be treated as `âŸ¨a, âŸ¨b, câŸ©âŸ©`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an
assumption `h : e = PAT` will be added to the context.
" title="`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to">rcases</span> <span class="lean-const" data-name="Nat.eq_zero_or_pos" data-signature="Nat.eq_zero_or_pos (n : â„•) : n = 0 âˆ¨ n &gt; 0" title="Nat.eq_zero_or_pos (n : â„•) : n = 0 âˆ¨ n &gt; 0">Nat.eq_zero_or_pos</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="orderOf" data-signature="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : â„•" data-docs="`orderOf x` is the order of the element `x`, i.e. the `n â‰¥ 1`, s.t. `x ^ n = 1` if it exists.
Otherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. " title="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : â„•
`orderOf x` is the order of the element `x`, i.e. the `n â‰¥ 1`, s.t. `x ^ n = 1` if it exists....">orderOf</span> <span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span><span class="lean-bracket-1">)</span> <span class="lean-keyword">with</span> <span class="lean-var" data-type="orderOf Ïƒ = 0" title="orderOf Ïƒ = 0">hord</span> | <span class="lean-var" data-type="orderOf Ïƒ &gt; 0" title="orderOf Ïƒ &gt; 0">hord</span>
  <span class="lean-operator">Â·</span> <span class="lean-comment">-- Ïƒ has infinite order </span><span class="lean-bracket-1">(</span>orderOf Ïƒ = <span class="lean-number">0</span><span class="lean-bracket-1">)</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="orderOf Ïƒ = 0" title="orderOf Ïƒ = 0">hord</span>, <span class="lean-const" data-name="orderOf_eq_zero_iff&#x27;" data-signature="orderOf_eq_zero_iff&#x27;.{u_1} {G : Type u_1} [Monoid G] {x : G} : orderOf x = 0 â†” âˆ€ (n : â„•), 0 &lt; n â†’ x ^ n â‰  1" title="orderOf_eq_zero_iff&#x27;.{u_1} {G : Type u_1} [Monoid G] {x : G} : orderOf x = 0 â†” âˆ€ (n : â„•), 0 &lt; n â†’ x ^ n â‰  1">orderOf_eq_zero_iff&#x27;</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal&#x27;s target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`. It is equivalent to `intro _`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, given a type ascription, or matched against a pattern:
  ```lean
  -- ... âŠ¢ Î± Ã— Î² â†’ ...
  intro (a, b)
  -- ..., a : Î±, b : Î² âŠ¢ ...
  ```
* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side
  is a variable.
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
" title="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.">intro</span> <span class="lean-var" data-type="â„•" title="â„•">k</span> <span class="lean-var" data-type="0 &lt; k" title="0 &lt; k">hk</span> <span class="lean-var" data-type="Equiv.Perm.permMatrix R Ïƒ ^ k = 1" title="Equiv.Perm.permMatrix R Ïƒ ^ k = 1">heq</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="Equiv.Perm.permMatrix R (Ïƒ ^ k) = 1" title="Equiv.Perm.permMatrix R (Ïƒ ^ k) = 1">h1</span> : <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span> ^ <span class="lean-var" data-type="â„•" title="â„•">k</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">permMatrix</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span> = <span class="lean-expr" data-type="Matrix n n R" title="Matrix n n R">1</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Crystallographic.Equiv.Perm.permMatrix_pow" data-signature="Crystallographic.Equiv.Perm.permMatrix_pow.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] (Ïƒ : Equiv.Perm n) (k : â„•) : Equiv.Perm.permMatrix R (Ïƒ ^ k) = Equiv.Perm.permMatrix R Ïƒ ^ k" data-docs="Permutation matrices power correctly: (Ïƒ^k).permMatrix = (Ïƒ.permMatrix)^k " title="Crystallographic.Equiv.Perm.permMatrix_pow.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] (Ïƒ : Equiv.Perm n) (k : â„•) : Equiv.Perm.permMatrix R (Ïƒ ^ k) = Equiv.Perm.permMatrix R Ïƒ ^ k
Permutation matrices power correctly: (Ïƒ^k).permMatrix = (Ïƒ.permMatrix)^k ">permMatrix_pow</span><span class="lean-bracket-1">]</span>; <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-var" data-type="Equiv.Perm.permMatrix R Ïƒ ^ k = 1" title="Equiv.Perm.permMatrix R Ïƒ ^ k = 1">heq</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Crystallographic.Equiv.Perm.permMatrix_eq_one_iff" data-signature="Crystallographic.Equiv.Perm.permMatrix_eq_one_iff.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] [Nontrivial R] (Ïƒ : Equiv.Perm n) : Equiv.Perm.permMatrix R Ïƒ = 1 â†” Ïƒ = 1" data-docs="Permutation matrix is identity iff permutation is identity. " title="Crystallographic.Equiv.Perm.permMatrix_eq_one_iff.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] [Nontrivial R] (Ïƒ : Equiv.Perm n) : Equiv.Perm.permMatrix R Ïƒ = 1 â†” Ïƒ = 1
Permutation matrix is identity iff permutation is identity. ">permMatrix_eq_one_iff</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`
* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="Equiv.Perm.permMatrix R (Ïƒ ^ k) = 1" title="Equiv.Perm.permMatrix R (Ïƒ ^ k) = 1">h1</span>
    <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="orderOf_eq_zero_iff&#x27;" data-signature="orderOf_eq_zero_iff&#x27;.{u_1} {G : Type u_1} [Monoid G] {x : G} : orderOf x = 0 â†” âˆ€ (n : â„•), 0 &lt; n â†’ x ^ n â‰  1" title="orderOf_eq_zero_iff&#x27;.{u_1} {G : Type u_1} [Monoid G] {x : G} : orderOf x = 0 â†” âˆ€ (n : â„•), 0 &lt; n â†’ x ^ n â‰  1">orderOf_eq_zero_iff&#x27;</span>.<span class="lean-const" data-name="Iff.mp" data-signature="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b" data-docs="Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. " title="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b
Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. ">mp</span> <span class="lean-var" data-type="orderOf Ïƒ = 0" title="orderOf Ïƒ = 0">hord</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="â„•" title="â„•">k</span> <span class="lean-var" data-type="0 &lt; k" title="0 &lt; k">hk</span> <span class="lean-var" data-type="Ïƒ ^ k = 1" title="Ïƒ ^ k = 1">h1</span>
  <span class="lean-operator">Â·</span> <span class="lean-comment">-- Ïƒ has finite order</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="orderOf_eq_iff" data-signature="orderOf_eq_iff.{u_1} {G : Type u_1} [Monoid G] {x : G} {n : â„•} (h : 0 &lt; n) :
  orderOf x = n â†” x ^ n = 1 âˆ§ âˆ€ m &lt; n, 0 &lt; m â†’ x ^ m â‰  1" title="orderOf_eq_iff.{u_1} {G : Type u_1} [Monoid G] {x : G} {n : â„•} (h : 0 &lt; n) :
  orderOf x = n â†” x ^ n = 1 âˆ§ âˆ€ m &lt; n, 0 &lt; m â†’ x ^ m â‰  1">orderOf_eq_iff</span> <span class="lean-var" data-type="orderOf Ïƒ &gt; 0" title="orderOf Ïƒ &gt; 0">hord</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="If the main goal&#x27;s target type is an inductive type, `constructor` solves it with
the first matching constructor, or else fails.
" title="If the main goal&#x27;s target type is an inductive type, `constructor` solves it with">constructor</span>
    <span class="lean-operator">Â·</span> <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-operator">â†</span> <span class="lean-const" data-name="Crystallographic.Equiv.Perm.permMatrix_pow" data-signature="Crystallographic.Equiv.Perm.permMatrix_pow.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] (Ïƒ : Equiv.Perm n) (k : â„•) : Equiv.Perm.permMatrix R (Ïƒ ^ k) = Equiv.Perm.permMatrix R Ïƒ ^ k" data-docs="Permutation matrices power correctly: (Ïƒ^k).permMatrix = (Ïƒ.permMatrix)^k " title="Crystallographic.Equiv.Perm.permMatrix_pow.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] (Ïƒ : Equiv.Perm n) (k : â„•) : Equiv.Perm.permMatrix R (Ïƒ ^ k) = Equiv.Perm.permMatrix R Ïƒ ^ k
Permutation matrices power correctly: (Ïƒ^k).permMatrix = (Ïƒ.permMatrix)^k ">permMatrix_pow</span>, <span class="lean-const" data-name="pow_orderOf_eq_one" data-signature="pow_orderOf_eq_one.{u_1} {G : Type u_1} [Monoid G] (x : G) : x ^ orderOf x = 1" title="pow_orderOf_eq_one.{u_1} {G : Type u_1} [Monoid G] (x : G) : x ^ orderOf x = 1">pow_orderOf_eq_one</span><span class="lean-bracket-1">]</span>; <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Crystallographic.Equiv.Perm.permMatrix_one" data-signature="Crystallographic.Equiv.Perm.permMatrix_one.{u_1, u_2} {n : Type u_1} [DecidableEq n] {R : Type u_2} [Zero R] [One R] :
  Equiv.Perm.permMatrix R 1 = 1" data-docs="The permutation matrix of the identity permutation is the identity matrix. " title="Crystallographic.Equiv.Perm.permMatrix_one.{u_1, u_2} {n : Type u_1} [DecidableEq n] {R : Type u_2} [Zero R] [One R] :
  Equiv.Perm.permMatrix R 1 = 1
The permutation matrix of the identity permutation is the identity matrix. ">permMatrix_one</span>
    <span class="lean-operator">Â·</span> <span class="lean-keyword" data-docs="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal&#x27;s target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`. It is equivalent to `intro _`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, given a type ascription, or matched against a pattern:
  ```lean
  -- ... âŠ¢ Î± Ã— Î² â†’ ...
  intro (a, b)
  -- ..., a : Î±, b : Î² âŠ¢ ...
  ```
* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side
  is a variable.
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
" title="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.">intro</span> <span class="lean-var" data-type="â„•" title="â„•">k</span> <span class="lean-var" data-type="k &lt; orderOf Ïƒ" title="k &lt; orderOf Ïƒ">hk_lt</span> <span class="lean-var" data-type="0 &lt; k" title="0 &lt; k">hk_pos</span> <span class="lean-var" data-type="Equiv.Perm.permMatrix R Ïƒ ^ k = 1" title="Equiv.Perm.permMatrix R Ïƒ ^ k = 1">heq</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="Equiv.Perm.permMatrix R (Ïƒ ^ k) = 1" title="Equiv.Perm.permMatrix R (Ïƒ ^ k) = 1">hk&#x27;</span> : <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span> ^ <span class="lean-var" data-type="â„•" title="â„•">k</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">permMatrix</span> <span class="lean-var" data-type="Type u_2" title="Type u_2">R</span> = <span class="lean-expr" data-type="Matrix n n R" title="Matrix n n R">1</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Crystallographic.Equiv.Perm.permMatrix_pow" data-signature="Crystallographic.Equiv.Perm.permMatrix_pow.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] (Ïƒ : Equiv.Perm n) (k : â„•) : Equiv.Perm.permMatrix R (Ïƒ ^ k) = Equiv.Perm.permMatrix R Ïƒ ^ k" data-docs="Permutation matrices power correctly: (Ïƒ^k).permMatrix = (Ïƒ.permMatrix)^k " title="Crystallographic.Equiv.Perm.permMatrix_pow.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] (Ïƒ : Equiv.Perm n) (k : â„•) : Equiv.Perm.permMatrix R (Ïƒ ^ k) = Equiv.Perm.permMatrix R Ïƒ ^ k
Permutation matrices power correctly: (Ïƒ^k).permMatrix = (Ïƒ.permMatrix)^k ">permMatrix_pow</span><span class="lean-bracket-1">]</span>; <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-var" data-type="Equiv.Perm.permMatrix R Ïƒ ^ k = 1" title="Equiv.Perm.permMatrix R Ïƒ ^ k = 1">heq</span>
      <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Crystallographic.Equiv.Perm.permMatrix_eq_one_iff" data-signature="Crystallographic.Equiv.Perm.permMatrix_eq_one_iff.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] [Nontrivial R] (Ïƒ : Equiv.Perm n) : Equiv.Perm.permMatrix R Ïƒ = 1 â†” Ïƒ = 1" data-docs="Permutation matrix is identity iff permutation is identity. " title="Crystallographic.Equiv.Perm.permMatrix_eq_one_iff.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] [Nontrivial R] (Ïƒ : Equiv.Perm n) : Equiv.Perm.permMatrix R Ïƒ = 1 â†” Ïƒ = 1
Permutation matrix is identity iff permutation is identity. ">permMatrix_eq_one_iff</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`
* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="Equiv.Perm.permMatrix R (Ïƒ ^ k) = 1" title="Equiv.Perm.permMatrix R (Ïƒ ^ k) = 1">hk&#x27;</span>
      <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="orderOf Ïƒ âˆ£ k" title="orderOf Ïƒ âˆ£ k">hdvd</span> : <span class="lean-const" data-name="orderOf" data-signature="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : â„•" data-docs="`orderOf x` is the order of the element `x`, i.e. the `n â‰¥ 1`, s.t. `x ^ n = 1` if it exists.
Otherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. " title="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : â„•
`orderOf x` is the order of the element `x`, i.e. the `n â‰¥ 1`, s.t. `x ^ n = 1` if it exists....">orderOf</span> <span class="lean-var" data-type="Equiv.Perm n" title="Equiv.Perm n">Ïƒ</span> âˆ£ <span class="lean-var" data-type="â„•" title="â„•">k</span> := <span class="lean-const" data-name="orderOf_dvd_of_pow_eq_one" data-signature="orderOf_dvd_of_pow_eq_one.{u_1} {G : Type u_1} [Monoid G] {x : G} {n : â„•} (h : x ^ n = 1) : orderOf x âˆ£ n" title="orderOf_dvd_of_pow_eq_one.{u_1} {G : Type u_1} [Monoid G] {x : G} {n : â„•} (h : x ^ n = 1) : orderOf x âˆ£ n">orderOf_dvd_of_pow_eq_one</span> <span class="lean-var" data-type="Ïƒ ^ k = 1" title="Ïƒ ^ k = 1">hk&#x27;</span>
      <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Nat.not_lt" data-signature="Nat.not_lt {a b : â„•} : Â¬a &lt; b â†” b â‰¤ a" title="Nat.not_lt {a b : â„•} : Â¬a &lt; b â†” b â‰¤ a">Nat.not_lt</span>.<span class="lean-const" data-name="Iff.mpr" data-signature="Iff.mpr {a b : Prop} (self : a â†” b) : b â†’ a" data-docs="Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. " title="Iff.mpr {a b : Prop} (self : a â†” b) : b â†’ a
Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. ">mpr</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Nat.le_of_dvd" data-signature="Nat.le_of_dvd {m n : â„•} (h : 0 &lt; n) : m âˆ£ n â†’ m â‰¤ n" title="Nat.le_of_dvd {m n : â„•} (h : 0 &lt; n) : m âˆ£ n â†’ m â‰¤ n">Nat.le_of_dvd</span> <span class="lean-var" data-type="0 &lt; k" title="0 &lt; k">hk_pos</span> <span class="lean-var" data-type="orderOf Ïƒ âˆ£ k" title="orderOf Ïƒ âˆ£ k">hdvd</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="k &lt; orderOf Ïƒ" title="k &lt; orderOf Ïƒ">hk_lt</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L133-L157" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:orderOf-permMatrix');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:orderOf-finRotate">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.13</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:orderOf-finRotate">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000056"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Equiv.Perm.orderOf_finRotate" class="lean_decl">Crystallographic.Equiv.Perm.orderOf_finRotate</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       The order of \(\mathrm{finRotate}(n)\) equals \(n\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000056">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p>The \(\mathrm{finRotate}(n)\) permutation is an \(n\)-cycle with full support \(\mathrm{Fin}\  n\). By the cycle order theorem, the order of a cycle equals its length, which is \(n\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Crystallographic.Equiv.Perm.orderOf_finRotate" data-signature="Crystallographic.Equiv.Perm.orderOf_finRotate (n : â„•) (hn : 2 â‰¤ n) : orderOf (finRotate n) = n" data-docs="The finRotate permutation has order n for n at least 2. " title="Crystallographic.Equiv.Perm.orderOf_finRotate (n : â„•) (hn : 2 â‰¤ n) : orderOf (finRotate n) = n
The finRotate permutation has order n for n at least 2. ">orderOf_finRotate</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">n</span> : â„•<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="2 â‰¤ n" title="2 â‰¤ n">hn</span> : <span class="lean-expr" data-type="â„•" title="â„•">2</span> <span class="lean-operator">â‰¤</span> <span class="lean-var" data-type="â„•" title="â„•">n</span><span class="lean-bracket-1">)</span> : <span class="lean-const" data-name="orderOf" data-signature="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : â„•" data-docs="`orderOf x` is the order of the element `x`, i.e. the `n â‰¥ 1`, s.t. `x ^ n = 1` if it exists.
Otherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. " title="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : â„•
`orderOf x` is the order of the element `x`, i.e. the `n â‰¥ 1`, s.t. `x ^ n = 1` if it exists....">orderOf</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="finRotate" data-signature="finRotate (n : â„•) : Equiv.Perm (Fin n)" data-docs="Rotate `Fin n` one step to the right. " title="finRotate (n : â„•) : Equiv.Perm (Fin n)
Rotate `Fin n` one step to the right. ">finRotate</span> <span class="lean-var" data-type="â„•" title="â„•">n</span><span class="lean-bracket-1">)</span> = <span class="lean-var" data-type="â„•" title="â„•">n</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(finRotate n).IsCycle" title="(finRotate n).IsCycle">hcycle</span> := <span class="lean-const" data-name="isCycle_finRotate_of_le" data-signature="isCycle_finRotate_of_le {n : â„•} (h : 2 â‰¤ n) : (finRotate n).IsCycle" title="isCycle_finRotate_of_le {n : â„•} (h : 2 â‰¤ n) : (finRotate n).IsCycle">isCycle_finRotate_of_le</span> <span class="lean-var" data-type="2 â‰¤ n" title="2 â‰¤ n">hn</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="orderOf (finRotate n) = (finRotate n).support.card" title="orderOf (finRotate n) = (finRotate n).support.card">hord</span> := <span class="lean-const" data-name="Equiv.Perm.IsCycle.orderOf" data-signature="Equiv.Perm.IsCycle.orderOf.{u_2} {Î± : Type u_2} {f : Equiv.Perm Î±} [DecidableEq Î±] [Fintype Î±] (hf : f.IsCycle) :
  orderOf f = f.support.card" title="Equiv.Perm.IsCycle.orderOf.{u_2} {Î± : Type u_2} {f : Equiv.Perm Î±} [DecidableEq Î±] [Fintype Î±] (hf : f.IsCycle) :
  orderOf f = f.support.card">Equiv.Perm.IsCycle.orderOf</span> <span class="lean-var" data-type="(finRotate n).IsCycle" title="(finRotate n).IsCycle">hcycle</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="(finRotate n).support = Finset.univ" title="(finRotate n).support = Finset.univ">hsupp</span> := <span class="lean-const" data-name="support_finRotate_of_le" data-signature="support_finRotate_of_le {n : â„•} (h : 2 â‰¤ n) : (finRotate n).support = Finset.univ" title="support_finRotate_of_le {n : â„•} (h : 2 â‰¤ n) : (finRotate n).support = Finset.univ">support_finRotate_of_le</span> <span class="lean-var" data-type="2 â‰¤ n" title="2 â‰¤ n">hn</span>
  <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="orderOf (finRotate n) = (finRotate n).support.card" title="orderOf (finRotate n) = (finRotate n).support.card">hord</span>, <span class="lean-var" data-type="(finRotate n).support = Finset.univ" title="(finRotate n).support = Finset.univ">hsupp</span>, <span class="lean-const" data-name="Finset.card_univ" data-signature="Finset.card_univ.{u_1} {Î± : Type u_1} [Fintype Î±] : Finset.univ.card = Fintype.card Î±" title="Finset.card_univ.{u_1} {Î± : Type u_1} [Fintype Î±] : Finset.univ.card = Fintype.card Î±">Finset.card_univ</span>, <span class="lean-const" data-name="Fintype.card_fin" data-signature="Fintype.card_fin (n : â„•) : Fintype.card (Fin n) = n" title="Fintype.card_fin (n : â„•) : Fintype.card (Fin n) = n">Fintype.card_fin</span><span class="lean-bracket-1">]</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L159-L168" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:orderOf-finRotate');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:orderOf-permMatrix-finRotate">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.14</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:orderOf-permMatrix-finRotate">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000057"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0005.html#lem:orderOf-permMatrix">Theorem 5.0.12</a></li>
          
          <li><a href="sect0005.html#lem:orderOf-finRotate">Theorem 5.0.13</a></li>
          
          <li><a href="sect0005.html#lem:orderOf-finRotate">Theorem 5.0.13</a></li>
          
          <li><a href="sect0005.html#lem:orderOf-permMatrix">Theorem 5.0.12</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.Equiv.Perm.orderOf_permMatrix_finRotate" class="lean_decl">Crystallographic.Equiv.Perm.orderOf_permMatrix_finRotate</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>       The permutation matrix of \(\mathrm{finRotate}(n)\) has order \(n\) over \(\mathbb {Z}\).  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000057">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p> Combines the order-preservation property \(\mathrm{ord}(P_\sigma ) = \mathrm{ord}(\sigma )\) with \(\mathrm{ord}(\mathrm{finRotate}(n)) = n\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Crystallographic.Equiv.Perm.orderOf_permMatrix_finRotate" data-signature="Crystallographic.Equiv.Perm.orderOf_permMatrix_finRotate (n : â„•) (hn : 2 â‰¤ n) :
  orderOf (Equiv.Perm.permMatrix â„¤ (finRotate n)) = n" data-docs="finRotate permutation matrix has order n for n &gt;= 2. " title="Crystallographic.Equiv.Perm.orderOf_permMatrix_finRotate (n : â„•) (hn : 2 â‰¤ n) :
  orderOf (Equiv.Perm.permMatrix â„¤ (finRotate n)) = n
finRotate permutation matrix has order n for n &gt;= 2. ">orderOf_permMatrix_finRotate</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">n</span> : â„•<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="2 â‰¤ n" title="2 â‰¤ n">hn</span> : <span class="lean-expr" data-type="â„•" title="â„•">2</span> <span class="lean-operator">â‰¤</span> <span class="lean-var" data-type="â„•" title="â„•">n</span><span class="lean-bracket-1">)</span> :
    <span class="lean-const" data-name="orderOf" data-signature="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : â„•" data-docs="`orderOf x` is the order of the element `x`, i.e. the `n â‰¥ 1`, s.t. `x ^ n = 1` if it exists.
Otherwise, i.e. if `x` is of infinite order, then `orderOf x` is `0` by convention. " title="orderOf.{u_1} {G : Type u_1} [Monoid G] (x : G) : â„•
`orderOf x` is the order of the element `x`, i.e. the `n â‰¥ 1`, s.t. `x ^ n = 1` if it exists....">orderOf</span> <span class="lean-bracket-1">(</span><span class="lean-bracket-2">(</span><span class="lean-const" data-name="finRotate" data-signature="finRotate (n : â„•) : Equiv.Perm (Fin n)" data-docs="Rotate `Fin n` one step to the right. " title="finRotate (n : â„•) : Equiv.Perm (Fin n)
Rotate `Fin n` one step to the right. ">finRotate</span> <span class="lean-var" data-type="â„•" title="â„•">n</span><span class="lean-bracket-2">)</span>.<span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">permMatrix</span> â„¤<span class="lean-bracket-1">)</span> = <span class="lean-var" data-type="â„•" title="â„•">n</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Crystallographic.Equiv.Perm.orderOf_permMatrix" data-signature="Crystallographic.Equiv.Perm.orderOf_permMatrix.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] [Nontrivial R] (Ïƒ : Equiv.Perm n) : orderOf (Equiv.Perm.permMatrix R Ïƒ) = orderOf Ïƒ" data-docs="Order of permutation matrix equals order of permutation. " title="Crystallographic.Equiv.Perm.orderOf_permMatrix.{u_1, u_2} {n : Type u_1} [DecidableEq n] [Fintype n] {R : Type u_2}
  [Semiring R] [Nontrivial R] (Ïƒ : Equiv.Perm n) : orderOf (Equiv.Perm.permMatrix R Ïƒ) = orderOf Ïƒ
Order of permutation matrix equals order of permutation. ">orderOf_permMatrix</span>, <span class="lean-const" data-name="Crystallographic.Equiv.Perm.orderOf_finRotate" data-signature="Crystallographic.Equiv.Perm.orderOf_finRotate (n : â„•) (hn : 2 â‰¤ n) : orderOf (finRotate n) = n" data-docs="The finRotate permutation has order n for n at least 2. " title="Crystallographic.Equiv.Perm.orderOf_finRotate (n : â„•) (hn : 2 â‰¤ n) : orderOf (finRotate n) = n
The finRotate permutation has order n for n at least 2. ">orderOf_finRotate</span> <span class="lean-var" data-type="â„•" title="â„•">n</span> <span class="lean-var" data-type="2 â‰¤ n" title="2 â‰¤ n">hn</span><span class="lean-bracket-1">]</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L170-L178" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:orderOf-permMatrix-finRotate');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="lem:mem-integerMatrixOrders-self">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.15</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#lem:mem-integerMatrixOrders-self">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000058"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0003.html#integerMatrixOrders-def">Definition 3.0.1</a></li>
          
          <li><a href="sect0005.html#lem:orderOf-permMatrix-finRotate">Theorem 5.0.14</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.mem_integerMatrixOrders_self" class="lean_decl">Crystallographic.mem_integerMatrixOrders_self</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>        \(m \in \mathrm{Ord}_m\) for \(m \geq 2\) via permutation matrix. </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000058">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p> The permutation matrix \(P_{\mathrm{finRotate}(m)}\) is an \(m \times m\) integer matrix with order exactly \(m\), since \(\mathrm{finRotate}(m)\) has order \(m\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">lemma</span> <span class="lean-const lean-def" data-name="Crystallographic.mem_integerMatrixOrders_self" data-signature="Crystallographic.mem_integerMatrixOrders_self (n : â„•) (hn : 2 â‰¤ n) : n âˆˆ integerMatrixOrders n" data-docs="Order n is achievable by an n x n integer matrix for n at least 2. " title="Crystallographic.mem_integerMatrixOrders_self (n : â„•) (hn : 2 â‰¤ n) : n âˆˆ integerMatrixOrders n
Order n is achievable by an n x n integer matrix for n at least 2. ">mem_integerMatrixOrders_self</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">n</span> : â„•<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="2 â‰¤ n" title="2 â‰¤ n">hn</span> : <span class="lean-expr" data-type="â„•" title="â„•">2</span> <span class="lean-operator">â‰¤</span> <span class="lean-var" data-type="â„•" title="â„•">n</span><span class="lean-bracket-1">)</span> : <span class="lean-var" data-type="â„•" title="â„•">n</span> <span class="lean-operator">âˆˆ</span> <span class="lean-const" data-name="Crystallographic.integerMatrixOrders" data-signature="Crystallographic.integerMatrixOrders (N : â„•) : Set â„•" data-docs="The set of possible orders for NÃ—N integer matrices with finite order.
An integer `m` is in this set if there exists an NÃ—N integer matrix `A` such that
`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). " title="Crystallographic.integerMatrixOrders (N : â„•) : Set â„•
The set of possible orders for NÃ—N integer matrices with finite order....">integerMatrixOrders</span> <span class="lean-var" data-type="â„•" title="â„•">n</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-keyword" data-docs="`use eâ‚, eâ‚‚, â‹¯` is similar to `exists`, but unlike `exists` it is equivalent to applying the tactic
`refine âŸ¨eâ‚, eâ‚‚, â‹¯, ?_, â‹¯, ?_âŸ©` with any number of placeholders (rather than just one) and
then trying to close goals associated to the placeholders with a configurable discharger (rather
than just `try trivial`).

Examples:

```lean
example : âˆƒ x : Nat, x = x := by use 42

example : âˆƒ x : Nat, âˆƒ y : Nat, x = y := by use 42, 42

example : âˆƒ x : String Ã— String, x.1 = x.2 := by use (&quot;forty-two&quot;, &quot;forty-two&quot;)
```

`use! eâ‚, eâ‚‚, â‹¯` is similar but it applies constructors everywhere rather than just for
goals that correspond to the last argument of a constructor. This gives the effect that
nested constructors are being flattened out, with the supplied values being used along the
leaves and nodes of the tree of constructors.
With `use!` one can feed in each `42` one at a time:

```lean
example : âˆƒ p : Nat Ã— Nat, p.1 = p.2 := by use! 42, 42

example : âˆƒ p : Nat Ã— Nat, p.1 = p.2 := by use! (42, 42)
```

The second line makes use of the fact that `use!` tries refining with the argument before
applying a constructor. Also note that `use`/`use!` by default uses a tactic
called `use_discharger` to discharge goals, so `use! 42` will close the goal in this example since
`use_discharger` applies `rfl`, which as a consequence solves for the other `Nat` metavariable.

These tactics take an optional discharger to handle remaining explicit `Prop` constructor arguments.
By default it is `use (discharger := try with_reducible use_discharger) eâ‚, eâ‚‚, â‹¯`.
To turn off the discharger and keep all goals, use `(discharger := skip)`.
To allow &quot;heavy refls&quot;, use `(discharger := try use_discharger)`.
" title="`use eâ‚, eâ‚‚, â‹¯` is similar to `exists`, but unlike `exists` it is equivalent to applying the tactic">use</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="finRotate" data-signature="finRotate (n : â„•) : Equiv.Perm (Fin n)" data-docs="Rotate `Fin n` one step to the right. " title="finRotate (n : â„•) : Equiv.Perm (Fin n)
Rotate `Fin n` one step to the right. ">finRotate</span> <span class="lean-var" data-type="â„•" title="â„•">n</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="Equiv.Perm.permMatrix" data-signature="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R" data-docs="the permutation matrix associated with an `Equiv.Perm` " title="Equiv.Perm.permMatrix.{u_1, u_2} {n : Type u_1} (R : Type u_2) [DecidableEq n] (Ïƒ : Equiv.Perm n) [Zero R] [One R] :
  Matrix n n R
the permutation matrix associated with an `Equiv.Perm` ">permMatrix</span> â„¤
  <span class="lean-keyword" data-docs="If the main goal&#x27;s target type is an inductive type, `constructor` solves it with
the first matching constructor, or else fails.
" title="If the main goal&#x27;s target type is an inductive type, `constructor` solves it with">constructor</span>
  <span class="lean-operator">Â·</span> <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Crystallographic.Equiv.Perm.orderOf_permMatrix_finRotate" data-signature="Crystallographic.Equiv.Perm.orderOf_permMatrix_finRotate (n : â„•) (hn : 2 â‰¤ n) :
  orderOf (Equiv.Perm.permMatrix â„¤ (finRotate n)) = n" data-docs="finRotate permutation matrix has order n for n &gt;= 2. " title="Crystallographic.Equiv.Perm.orderOf_permMatrix_finRotate (n : â„•) (hn : 2 â‰¤ n) :
  orderOf (Equiv.Perm.permMatrix â„¤ (finRotate n)) = n
finRotate permutation matrix has order n for n &gt;= 2. ">Equiv.Perm.orderOf_permMatrix_finRotate</span> <span class="lean-var" data-type="â„•" title="â„•">n</span> <span class="lean-var" data-type="2 â‰¤ n" title="2 â‰¤ n">hn</span>
  <span class="lean-operator">Â·</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L182-L191" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('lem:mem-integerMatrixOrders-self');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:primePow-mem-integerMatrixOrders-psi">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.16</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#thm:primePow-mem-integerMatrixOrders-psi">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000059"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0002.html#psi-def">Definition 2.0.2</a></li>
          
          <li><a href="sect0003.html#integerMatrixOrders-def">Definition 3.0.1</a></li>
          
          <li><a href="sect0002.html#lem:psi-prime-pow">Theorem 2.0.1</a></li>
          
          <li><a href="sect0004.html#thm:mem-orders-totient">Theorem 4.0.7</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.primePow_mem_integerMatrixOrders_psi" class="lean_decl">Crystallographic.primePow_mem_integerMatrixOrders_psi</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>        For a prime power \(p^k\) with \(p\) odd or \(k \geq 2\), we have \(p^k \in \mathrm{Ord}_{\psi (p^k)}\). </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000059">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p> For these prime powers, \(\psi (p^k) = \varphi (p^k)\). The companion matrix of \(\Phi _{p^k}\) has dimension \(\varphi (p^k)\) and order exactly \(p^k\), so \(p^k \in \mathrm{Ord}_{\varphi (p^k)} = \mathrm{Ord}_{\psi (p^k)}\). </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">theorem</span> <span class="lean-const lean-def" data-name="Crystallographic.primePow_mem_integerMatrixOrders_psi" data-signature="Crystallographic.primePow_mem_integerMatrixOrders_psi (p k : â„•) (hp : Nat.Prime p) (hk : 0 &lt; k)
  (hpk : Â¬(p = 2 âˆ§ k = 1)) : p ^ k âˆˆ integerMatrixOrders (psi (p ^ k))" data-docs="For prime power with p odd or k at least 2, p^k is in integerMatrixOrders(psi(p^k)). " title="Crystallographic.primePow_mem_integerMatrixOrders_psi (p k : â„•) (hp : Nat.Prime p) (hk : 0 &lt; k)
  (hpk : Â¬(p = 2 âˆ§ k = 1)) : p ^ k âˆˆ integerMatrixOrders (psi (p ^ k))
For prime power with p odd or k at least 2, p^k is in integerMatrixOrders(psi(p^k)). ">primePow_mem_integerMatrixOrders_psi</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">p</span> <span class="lean-var" data-type="â„•" title="â„•">k</span> : â„•<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span> : <span class="lean-var" data-type="â„•" title="â„•">p</span>.<span class="lean-const" data-name="Nat.Prime" data-signature="Nat.Prime (p : â„•) : Prop" data-docs="`Nat.Prime p` means that `p` is a prime number, that is, a natural number
at least 2 whose only divisors are `p` and `1`.
The theorem `Nat.prime_def` witnesses this description of a prime number. " title="Nat.Prime (p : â„•) : Prop
`Nat.Prime p` means that `p` is a prime number, that is, a natural number...">Prime</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; k" title="0 &lt; k">hk</span> : <span class="lean-expr" data-type="â„•" title="â„•">0</span> &lt; <span class="lean-var" data-type="â„•" title="â„•">k</span><span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="Â¬(p = 2 âˆ§ k = 1)" title="Â¬(p = 2 âˆ§ k = 1)">hpk</span> : <span class="lean-operator">Â¬</span><span class="lean-bracket-2">(</span><span class="lean-var" data-type="â„•" title="â„•">p</span> = <span class="lean-expr" data-type="â„•" title="â„•">2</span> <span class="lean-operator">âˆ§</span> <span class="lean-var" data-type="â„•" title="â„•">k</span> = <span class="lean-expr" data-type="â„•" title="â„•">1</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span> :
    <span class="lean-var" data-type="â„•" title="â„•">p</span> ^ <span class="lean-var" data-type="â„•" title="â„•">k</span> <span class="lean-operator">âˆˆ</span> <span class="lean-const" data-name="Crystallographic.integerMatrixOrders" data-signature="Crystallographic.integerMatrixOrders (N : â„•) : Set â„•" data-docs="The set of possible orders for NÃ—N integer matrices with finite order.
An integer `m` is in this set if there exists an NÃ—N integer matrix `A` such that
`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). " title="Crystallographic.integerMatrixOrders (N : â„•) : Set â„•
The set of possible orders for NÃ—N integer matrices with finite order....">integerMatrixOrders</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.psi" data-signature="Crystallographic.psi (m : â„•) : â„•" data-docs="The psi function for crystallographic restriction.
psi(m) is the minimum dimension N such that an NÃ—N integer matrix can have order m.

Defined as the sum over prime power factors: if m = prod p_i^{k_i}, then
psi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) " title="Crystallographic.psi (m : â„•) : â„•
The psi function for crystallographic restriction....">psi</span> <span class="lean-bracket-2">(</span><span class="lean-var" data-type="â„•" title="â„•">p</span> ^ <span class="lean-var" data-type="â„•" title="â„•">k</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-comment">-- psi</span><span class="lean-bracket-1">(</span>p^k<span class="lean-bracket-1">)</span> = totient<span class="lean-bracket-1">(</span>p^k<span class="lean-bracket-1">)</span> for this case
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="psi (p ^ k) = (p ^ k).totient" title="psi (p ^ k) = (p ^ k).totient">hpsi_eq</span> : <span class="lean-const" data-name="Crystallographic.psi" data-signature="Crystallographic.psi (m : â„•) : â„•" data-docs="The psi function for crystallographic restriction.
psi(m) is the minimum dimension N such that an NÃ—N integer matrix can have order m.

Defined as the sum over prime power factors: if m = prod p_i^{k_i}, then
psi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) " title="Crystallographic.psi (m : â„•) : â„•
The psi function for crystallographic restriction....">psi</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">p</span> ^ <span class="lean-var" data-type="â„•" title="â„•">k</span><span class="lean-bracket-1">)</span> = <span class="lean-const" data-name="Nat.totient" data-signature="Nat.totient (n : â„•) : â„•" data-docs="Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are
coprime with `n`. " title="Nat.totient (n : â„•) : â„•
Euler&#x27;s totient function. This counts the number of naturals strictly less than `n` which are...">Nat.totient</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">p</span> ^ <span class="lean-var" data-type="â„•" title="â„•">k</span><span class="lean-bracket-1">)</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
    <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Crystallographic.psi_prime_pow" data-signature="Crystallographic.psi_prime_pow (p k : â„•) (hp : Nat.Prime p) (hk : 0 &lt; k) :
  psi (p ^ k) = if p = 2 âˆ§ k = 1 then 0 else (p ^ k).totient" data-docs="`psi` of a prime power p^k equals phi(p^k), except `psi 2 = 0` " title="Crystallographic.psi_prime_pow (p k : â„•) (hp : Nat.Prime p) (hk : 0 &lt; k) :
  psi (p ^ k) = if p = 2 âˆ§ k = 1 then 0 else (p ^ k).totient
`psi` of a prime power p^k equals phi(p^k), except `psi 2 = 0` ">psi_prime_pow</span> <span class="lean-var" data-type="â„•" title="â„•">p</span> <span class="lean-var" data-type="â„•" title="â„•">k</span> <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span> <span class="lean-var" data-type="0 &lt; k" title="0 &lt; k">hk</span><span class="lean-bracket-1">]</span>
    <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="Â¬(p = 2 âˆ§ k = 1)" title="Â¬(p = 2 âˆ§ k = 1)">hpk</span>, <span class="lean-const" data-name="ite_false" data-signature="ite_false.{u_1} {Î± : Sort u_1} (a b : Î±) : (if False then a else b) = b" title="ite_false.{u_1} {Î± : Sort u_1} (a b : Î±) : (if False then a else b) = b">ite_false</span><span class="lean-bracket-1">]</span>
  <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="psi (p ^ k) = (p ^ k).totient" title="psi (p ^ k) = (p ^ k).totient">hpsi_eq</span><span class="lean-bracket-1">]</span>
  <span class="lean-comment">-- Use companion matrix lemma</span>
  <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="2 â‰¤ p ^ k" title="2 â‰¤ p ^ k">hpk_ge2</span> : <span class="lean-expr" data-type="â„•" title="â„•">2</span> <span class="lean-operator">â‰¤</span> <span class="lean-var" data-type="â„•" title="â„•">p</span> ^ <span class="lean-var" data-type="â„•" title="â„•">k</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="2 â‰¤ p" title="2 â‰¤ p">hp_ge2</span> : <span class="lean-expr" data-type="â„•" title="â„•">2</span> <span class="lean-operator">â‰¤</span> <span class="lean-var" data-type="â„•" title="â„•">p</span> := <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span>.<span class="lean-const" data-name="Nat.Prime.two_le" data-signature="Nat.Prime.two_le {p : â„•} : Nat.Prime p â†’ 2 â‰¤ p" title="Nat.Prime.two_le {p : â„•} : Nat.Prime p â†’ 2 â‰¤ p">two_le</span>
    <span class="lean-keyword" data-docs="Step-wise reasoning over transitive relations.
```
calc
  a = b := pab
  b = c := pbc
  ...
  y = z := pyz
```
proves `a = z` from the given step-wise proofs. `=` can be replaced with any
relation implementing the typeclass `Trans`. Instead of repeating the right-
hand sides, subsequent left-hand sides can be replaced with `_`.
```
calc
  a = b := pab
  _ = c := pbc
  ...
  _ = z := pyz
```
It is also possible to write the *first* relation as `&lt;lhs&gt;\n  _ = &lt;rhs&gt; :=
&lt;proof&gt;`. This is useful for aligning relation symbols, especially on longer:
identifiers:
```
calc abc
  _ = bce := pabce
  _ = cef := pbcef
  ...
  _ = xyz := pwxyz
```

`calc` works as a term, as a tactic or as a `conv` tactic.

See [Theorem Proving in Lean 4][tpil4] for more information.

[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs
" title="Step-wise reasoning over transitive relations.">calc</span> <span class="lean-var" data-type="â„•" title="â„•">p</span> ^ <span class="lean-var" data-type="â„•" title="â„•">k</span> <span class="lean-operator">â‰¥</span> <span class="lean-var" data-type="â„•" title="â„•">p</span> ^ <span class="lean-expr" data-type="â„•" title="â„•">1</span> := <span class="lean-const" data-name="Nat.pow_le_pow_right" data-signature="Nat.pow_le_pow_right {n : â„•} (hx : n &gt; 0) {i j : â„•} : i â‰¤ j â†’ n ^ i â‰¤ n ^ j" title="Nat.pow_le_pow_right {n : â„•} (hx : n &gt; 0) {i j : â„•} : i â‰¤ j â†’ n ^ i â‰¤ n ^ j">Nat.pow_le_pow_right</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Nat.le_of_lt" data-signature="Nat.le_of_lt {n m : â„•} : n &lt; m â†’ n â‰¤ m" title="Nat.le_of_lt {n m : â„•} : n &lt; m â†’ n â‰¤ m">Nat.le_of_lt</span> <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span>.<span class="lean-const" data-name="Nat.Prime.one_lt" data-signature="Nat.Prime.one_lt {p : â„•} : Nat.Prime p â†’ 1 &lt; p" title="Nat.Prime.one_lt {p : â„•} : Nat.Prime p â†’ 1 &lt; p">one_lt</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="0 &lt; k" title="0 &lt; k">hk</span>
      _ = <span class="lean-var" data-type="â„•" title="â„•">p</span> := <span class="lean-const" data-name="pow_one" data-signature="pow_one.{u_2} {M : Type u_2} [Monoid M] (a : M) : a ^ 1 = a" title="pow_one.{u_2} {M : Type u_2} [Monoid M] (a : M) : a ^ 1 = a">pow_one</span> <span class="lean-var" data-type="â„•" title="â„•">p</span>
      _ <span class="lean-operator">â‰¥</span> <span class="lean-expr" data-type="â„•" title="â„•">2</span> := <span class="lean-var" data-type="2 â‰¤ p" title="2 â‰¤ p">hp_ge2</span>
  <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Crystallographic.mem_integerMatrixOrders_totient" data-signature="Crystallographic.mem_integerMatrixOrders_totient (m : â„•) (hm : 2 â‰¤ m) : m âˆˆ integerMatrixOrders m.totient" title="Crystallographic.mem_integerMatrixOrders_totient (m : â„•) (hm : 2 â‰¤ m) : m âˆˆ integerMatrixOrders m.totient">mem_integerMatrixOrders_totient</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">p</span> ^ <span class="lean-var" data-type="â„•" title="â„•">k</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="2 â‰¤ p ^ k" title="2 â‰¤ p ^ k">hpk_ge2</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L195-L215" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:primePow-mem-integerMatrixOrders-psi');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:mem-integerMatrixOrders-psi">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.17</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#thm:mem-integerMatrixOrders-psi">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000060"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0005.html#thm:primePow-mem-integerMatrixOrders-psi">Theorem 5.0.16</a></li>
          
          <li><a href="sect0002.html#psi-def">Definition 2.0.2</a></li>
          
          <li><a href="sect0003.html#lem:one-mem-orders">Theorem 3.0.1</a></li>
          
          <li><a href="sect0006.html#lem:orderOf-neg-of-odd-order">Theorem A.0.7</a></li>
          
          <li><a href="sect0002.html#psiPrimePow-def">Definition 2.0.1</a></li>
          
          <li><a href="sect0003.html#lem:mul-mem-orders-coprime">Theorem 3.0.10</a></li>
          
          <li><a href="sect0005.html#thm:primePow-mem-integerMatrixOrders-psi">Theorem 5.0.16</a></li>
          
          <li><a href="sect0002.html#lem:factorization-split-lt">Theorem 2.0.6</a></li>
          
          <li><a href="sect0002.html#lem:psi-coprime-add">Theorem 2.0.3</a></li>
          
          <li><a href="sect0003.html#lem:one-mem-orders">Theorem 3.0.1</a></li>
          
          <li><a href="sect0002.html#lem:psi-pos-of-odd">Theorem 2.0.7</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.mem_integerMatrixOrders_psi" class="lean_decl">Crystallographic.mem_integerMatrixOrders_psi</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>        For \(m \geq 1\) with \(m \neq 2\), we have \(m \in \mathrm{Ord}_{\psi (m)}\). The construction achieves order \(m\) using exactly \(\psi (m)\) dimensions via block diagonal matrices of cyclotomic companion matrices.  </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000060">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p> By strong induction on \(m\). For \(m = 1\), the identity achieves order 1 in dimension \(\psi (1) = 0\). For prime powers \(p^k\) (excluding \(2^1\)), the companion matrix of \(\Phi _{p^k}\) has order \(p^k\) in dimension \(\varphi (p^k) = \psi (p^k)\). For composite \(m = p^e \cdot m'\) with coprime factors, we use block diagonal of matrices achieving orders \(p^e\) and \(m'\) from the induction hypothesis, with dimension \(\psi (p^e) + \psi (m') = \psi (m)\) by additivity of \(\psi \) on coprime factors. For \(m = 2 \cdot m'\) with \(m'\) odd, negating the order-\(m'\) matrix doubles the order without changing dimension. </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">theorem</span> <span class="lean-const lean-def" data-name="Crystallographic.mem_integerMatrixOrders_psi" data-signature="Crystallographic.mem_integerMatrixOrders_psi (m : â„•) (hm : 0 &lt; m) (hm2 : m â‰  2) : m âˆˆ integerMatrixOrders (psi m)" data-docs="Every `m &gt;= 1` with `m â‰  2` belongs to `integerMatrixOrders (psi m)`.

The proof uses strong induction on `m`:
- `m = 1`: `psi 1 = 0`, use identity matrix
- `m = 2`: EXCLUDED - `psi 2 = 0` but `2 âˆ‰ integerMatrixOrders 0`
- `m = p^k` prime power (p â‰  2 or k â‰  1): use companion matrix
- `m` composite: factor as `p^e * m&#x27;` with coprime parts, apply IH and block diagonal

Note: For `m = 2`, `psi 2 = 0` means no additional dimension is needed, but there is
no 0x0 integer matrix with order 2. The crystallographic restriction theorem
handles `m = 2` separately using the hypothesis `hNm : m = 1 âˆ¨ 0 &lt; N`.

This theorem is used to complete the backward direction of the crystallographic
restriction theorem: if `psi m â‰¤ N`, then `m âˆˆ integerMatrixOrders N`. " title="Crystallographic.mem_integerMatrixOrders_psi (m : â„•) (hm : 0 &lt; m) (hm2 : m â‰  2) : m âˆˆ integerMatrixOrders (psi m)
Every `m &gt;= 1` with `m â‰  2` belongs to `integerMatrixOrders (psi m)`....">mem_integerMatrixOrders_psi</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">m</span> : â„•<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span> : <span class="lean-expr" data-type="â„•" title="â„•">0</span> &lt; <span class="lean-var" data-type="â„•" title="â„•">m</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="m â‰  2" title="m â‰  2">hm2</span> : <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-operator">â‰ </span> <span class="lean-expr" data-type="â„•" title="â„•">2</span><span class="lean-bracket-1">)</span> :
    <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-operator">âˆˆ</span> <span class="lean-const" data-name="Crystallographic.integerMatrixOrders" data-signature="Crystallographic.integerMatrixOrders (N : â„•) : Set â„•" data-docs="The set of possible orders for NÃ—N integer matrices with finite order.
An integer `m` is in this set if there exists an NÃ—N integer matrix `A` such that
`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). " title="Crystallographic.integerMatrixOrders (N : â„•) : Set â„•
The set of possible orders for NÃ—N integer matrices with finite order....">integerMatrixOrders</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.psi" data-signature="Crystallographic.psi (m : â„•) : â„•" data-docs="The psi function for crystallographic restriction.
psi(m) is the minimum dimension N such that an NÃ—N integer matrix can have order m.

Defined as the sum over prime power factors: if m = prod p_i^{k_i}, then
psi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) " title="Crystallographic.psi (m : â„•) : â„•
The psi function for crystallographic restriction....">psi</span> <span class="lean-var" data-type="â„•" title="â„•">m</span><span class="lean-bracket-1">)</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-comment">-- Use strong induction on m</span>
  <span class="lean-keyword" data-docs="Assuming `x` is a variable in the local context with an inductive type,
`induction x` applies induction on `x` to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on `x`,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,
`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,
and one goal with hypotheses `h : P (Nat.succ a)` and `ihâ‚ : P a â†’ Q a` and target `Q (Nat.succ a)`.
Here the names `a` and `ihâ‚` are chosen automatically and are not accessible.
You can use `with` to provide the variables names for each constructor.
- `induction e`, where `e` is an expression instead of a variable,
  generalizes `e` in the goal, and then performs induction on the resulting variable.
- `induction e using r` allows the user to specify the principle of induction that should be used.
  Here `r` should be a term whose result type must be of the form `C t`,
  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables
- `induction e generalizing zâ‚ ... zâ‚™`, where `zâ‚ ... zâ‚™` are variables in the local context,
  generalizes over `zâ‚ ... zâ‚™` before applying the induction but then introduces them in each goal.
  In other words, the net effect is that each inductive hypothesis is generalized.
- Given `x : Nat`, `induction x with | zero =&gt; tacâ‚ | succ x&#x27; ih =&gt; tacâ‚‚`
  uses tactic `tacâ‚` for the `zero` case, and `tacâ‚‚` for the `succ` case.
" title="Assuming `x` is a variable in the local context with an inductive type,">induction</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-keyword">using</span> <span class="lean-const" data-name="Nat.strong_induction_on" data-signature="Nat.strong_induction_on {p : â„• â†’ Prop} (n : â„•) (h : âˆ€ (n : â„•), (âˆ€ m &lt; n, p m) â†’ p n) : p n" title="Nat.strong_induction_on {p : â„• â†’ Prop} (n : â„•) (h : âˆ€ (n : â„•), (âˆ€ m &lt; n, p m) â†’ p n) : p n">Nat.strong_induction_on</span> <span class="lean-keyword" data-docs="After `with`, there is an optional tactic that runs on all branches, and
then a list of alternatives.
" title="After `with`, there is an optional tactic that runs on all branches, and">with</span>
  | _ <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-var" data-type="âˆ€ m_1 &lt; m, 0 &lt; m_1 â†’ m_1 â‰  2 â†’ m_1 âˆˆ integerMatrixOrders (psi m_1)" title="âˆ€ m_1 &lt; m, 0 &lt; m_1 â†’ m_1 â‰  2 â†’ m_1 âˆˆ integerMatrixOrders (psi m_1)">IH</span> =&gt;
  <span class="lean-comment">-- Case: m = <span class="lean-number">1</span></span>
  <span class="lean-keyword" data-docs="`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to
destructure hypotheses or expressions composed of inductive types like `h1 : a âˆ§ b âˆ§ c âˆ¨ d` or
`h2 : âˆƒ x y, trans_rel R x y`. Usual usage might be `rcases h1 with âŸ¨ha, hb, hcâŸ© | hd` or
`rcases h2 with âŸ¨x, y, _ | âŸ¨z, hxz, hzyâŸ©âŸ©` for these examples.

Each element of an `rcases` pattern is matched against a particular local hypothesis (most of which
are generated during the execution of `rcases` and represent individual elements destructured from
the input expression). An `rcases` pattern has the following grammar:

* A name like `x`, which names the active hypothesis as `x`.
* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the
  hypothesis).
* A hyphen `-`, which clears the active hypothesis and any dependents.
* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the
  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).
* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it
  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)
* A tuple pattern `âŸ¨p1, p2, p3âŸ©`, which matches a constructor with many arguments, or a series
  of nested conjunctions or existentials. For example if the active hypothesis is `a âˆ§ b âˆ§ c`,
  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`
  and so on.
* A `@` before a tuple pattern as in `@âŸ¨p1, p2, p3âŸ©` will bind all arguments in the constructor,
  while leaving the `@` off will only use the patterns on the explicit arguments.
* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,
  or a nested disjunction like `a âˆ¨ b âˆ¨ c`.

A pattern like `âŸ¨a, b, câŸ© | âŸ¨d, eâŸ©` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `âŸ¨âŸ¨aâŸ©, b | câŸ© | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `âŸ¨a, b, câŸ©` for splitting on
`âˆƒ x, âˆƒ y, p x`, then it will be treated as `âŸ¨a, âŸ¨b, câŸ©âŸ©`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an
assumption `h : e = PAT` will be added to the context.
" title="`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to">rcases</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Nat.one_le_iff_ne_zero" data-signature="Nat.one_le_iff_ne_zero {n : â„•} : 1 â‰¤ n â†” n â‰  0" title="Nat.one_le_iff_ne_zero {n : â„•} : 1 â‰¤ n â†” n â‰  0">Nat.one_le_iff_ne_zero</span>.<span class="lean-const" data-name="Iff.mpr" data-signature="Iff.mpr {a b : Prop} (self : a â†” b) : b â†’ a" data-docs="Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. " title="Iff.mpr {a b : Prop} (self : a â†” b) : b â†’ a
Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. ">mpr</span> <span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span>.<span class="lean-const" data-name="LT.lt.ne&#x27;" data-signature="LT.lt.ne&#x27;.{u_1} {Î± : Type u_1} [Preorder Î±] {a b : Î±} (h : b &lt; a) : a â‰  b" title="LT.lt.ne&#x27;.{u_1} {Î± : Type u_1} [Preorder Î±] {a b : Î±} (h : b &lt; a) : a â‰  b">ne&#x27;</span><span class="lean-bracket-1">)</span>.<span class="lean-const" data-name="LE.le.eq_or_lt&#x27;" data-signature="LE.le.eq_or_lt&#x27;.{u_2} {Î± : Type u_2} [PartialOrder Î±] {a b : Î±} (h : b â‰¤ a) : a = b âˆ¨ b &lt; a" title="LE.le.eq_or_lt&#x27;.{u_2} {Î± : Type u_2} [PartialOrder Î±] {a b : Î±} (h : b â‰¤ a) : a = b âˆ¨ b &lt; a">eq_or_lt&#x27;</span> <span class="lean-keyword">with</span> <span class="lean-var" data-type="m = 1" title="m = 1">rfl</span> | <span class="lean-var" data-type="1 &lt; m" title="1 &lt; m">hm_gt1</span>
  <span class="lean-operator">Â·</span> <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Crystallographic.psi_one" data-signature="Crystallographic.psi_one : psi 1 = 0" data-docs="`psi 1 = 0`: The identity matrix has order 1 in any dimension. " title="Crystallographic.psi_one : psi 1 = 0
`psi 1 = 0`: The identity matrix has order 1 in any dimension. ">psi_one</span><span class="lean-bracket-1">]</span>; <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Crystallographic.one_mem_integerMatrixOrders" data-signature="Crystallographic.one_mem_integerMatrixOrders (N : â„•) : 1 âˆˆ integerMatrixOrders N" data-docs="The identity matrix has order 1, so 1 âˆˆ integerMatrixOrders N for any N. " title="Crystallographic.one_mem_integerMatrixOrders (N : â„•) : 1 âˆˆ integerMatrixOrders N
The identity matrix has order 1, so 1 âˆˆ integerMatrixOrders N for any N. ">one_mem_integerMatrixOrders</span> <span class="lean-expr" data-type="â„•" title="â„•">0</span>
  <span class="lean-operator">Â·</span> <span class="lean-comment">-- Case: m &gt; <span class="lean-number">1</span>, i.e., m &gt;= <span class="lean-number">2</span></span>
    <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="2 &lt; m" title="2 &lt; m">hm_gt2</span> : <span class="lean-expr" data-type="â„•" title="â„•">2</span> &lt; <span class="lean-var" data-type="â„•" title="â„•">m</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span>
    <span class="lean-comment">-- Check if m is a prime power</span>
    <span class="lean-keyword" data-docs="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : Â¬ p` in the second branch.
" title="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `">by_cases</span> <span class="lean-var" data-type="IsPrimePow m" title="IsPrimePow m">hpow</span> : <span class="lean-const" data-name="IsPrimePow" data-signature="IsPrimePow.{u_1} {R : Type u_1} [CommMonoidWithZero R] (n : R) : Prop" data-docs="`n` is a prime power if there is a prime `p` and a positive natural `k` such that `n` can be
written as `p^k`. " title="IsPrimePow.{u_1} {R : Type u_1} [CommMonoidWithZero R] (n : R) : Prop
`n` is a prime power if there is a prime `p` and a positive natural `k` such that `n` can be...">IsPrimePow</span> <span class="lean-var" data-type="â„•" title="â„•">m</span>
    <span class="lean-operator">Â·</span> <span class="lean-comment">-- m is a prime power p^k</span>
      <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="isPrimePow_nat_iff" data-signature="isPrimePow_nat_iff (n : â„•) : IsPrimePow n â†” âˆƒ p k, Nat.Prime p âˆ§ 0 &lt; k âˆ§ p ^ k = n" title="isPrimePow_nat_iff (n : â„•) : IsPrimePow n â†” âˆƒ p k, Nat.Prime p âˆ§ 0 &lt; k âˆ§ p ^ k = n">isPrimePow_nat_iff</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`
* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="IsPrimePow m" title="IsPrimePow m">hpow</span>
      <span class="lean-keyword" data-docs="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for
a description of supported patterns.

```lean
obtain âŸ¨pattâŸ© : type := proof
```
is equivalent to
```lean
have h : type := proof
rcases h with âŸ¨pattâŸ©
```

If `âŸ¨pattâŸ©` is omitted, `rcases` will try to infer the pattern.

If `type` is omitted, `:= proof` is required.
" title="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for">obtain</span> <span class="lean-bracket-1">âŸ¨</span><span class="lean-var" data-type="â„•" title="â„•">p</span>, <span class="lean-var" data-type="â„•" title="â„•">k</span>, <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span>, <span class="lean-var" data-type="0 &lt; k" title="0 &lt; k">hk</span>, <span class="lean-var" data-type="p ^ k = m" title="p ^ k = m">hpk</span><span class="lean-bracket-1">âŸ©</span> := <span class="lean-var" data-type="âˆƒ p k, Nat.Prime p âˆ§ 0 &lt; k âˆ§ p ^ k = m" title="âˆƒ p k, Nat.Prime p âˆ§ 0 &lt; k âˆ§ p ^ k = m">hpow</span>
      <span class="lean-keyword" data-docs="`subst x...` substitutes each hypothesis `x` with a definition found in the local context,
then eliminates the hypothesis.
- If `x` is a local definition, then its definition is used.
- Otherwise, if there is a hypothesis of the form `x = e` or `e = x`,
  then `e` is used for the definition of `x`.

If `h : a = b`, then `subst h` may be used if either `a` or `b` unfolds to a local hypothesis.
This is similar to the `cases h` tactic.

See also: `subst_vars` for substituting all local hypotheses that have a defining equation.
" title="`subst x...` substitutes each hypothesis `x` with a definition found in the local context,">subst</span> <span class="lean-var" data-type="p ^ k = m" title="p ^ k = m">hpk</span>
      <span class="lean-keyword" data-docs="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : Â¬ p` in the second branch.
" title="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `">by_cases</span> <span class="lean-var" data-type="p = 2 âˆ§ k = 1" title="p = 2 âˆ§ k = 1">h21</span> : <span class="lean-var" data-type="â„•" title="â„•">p</span> = <span class="lean-expr" data-type="â„•" title="â„•">2</span> <span class="lean-operator">âˆ§</span> <span class="lean-var" data-type="â„•" title="â„•">k</span> = <span class="lean-expr" data-type="â„•" title="â„•">1</span>
      <span class="lean-operator">Â·</span> <span class="lean-keyword" data-docs="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for
a description of supported patterns.

```lean
obtain âŸ¨pattâŸ© : type := proof
```
is equivalent to
```lean
have h : type := proof
rcases h with âŸ¨pattâŸ©
```

If `âŸ¨pattâŸ©` is omitted, `rcases` will try to infer the pattern.

If `type` is omitted, `:= proof` is required.
" title="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for">obtain</span> <span class="lean-bracket-1">âŸ¨</span><span class="lean-var" data-type="p = 2" title="p = 2">rfl</span>, <span class="lean-var" data-type="k = 1" title="k = 1">rfl</span><span class="lean-bracket-1">âŸ©</span> := <span class="lean-var" data-type="p = 2 âˆ§ k = 1" title="p = 2 âˆ§ k = 1">h21</span>; <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="pow_one" data-signature="pow_one.{u_2} {M : Type u_2} [Monoid M] (a : M) : a ^ 1 = a" title="pow_one.{u_2} {M : Type u_2} [Monoid M] (a : M) : a ^ 1 = a">pow_one</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`
* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="2 &lt; 2 ^ 1" title="2 &lt; 2 ^ 1">hm_gt2</span>; <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span>
      <span class="lean-operator">Â·</span> <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Crystallographic.primePow_mem_integerMatrixOrders_psi" data-signature="Crystallographic.primePow_mem_integerMatrixOrders_psi (p k : â„•) (hp : Nat.Prime p) (hk : 0 &lt; k)
  (hpk : Â¬(p = 2 âˆ§ k = 1)) : p ^ k âˆˆ integerMatrixOrders (psi (p ^ k))" data-docs="For prime power with p odd or k at least 2, p^k is in integerMatrixOrders(psi(p^k)). " title="Crystallographic.primePow_mem_integerMatrixOrders_psi (p k : â„•) (hp : Nat.Prime p) (hk : 0 &lt; k)
  (hpk : Â¬(p = 2 âˆ§ k = 1)) : p ^ k âˆˆ integerMatrixOrders (psi (p ^ k))
For prime power with p odd or k at least 2, p^k is in integerMatrixOrders(psi(p^k)). ">primePow_mem_integerMatrixOrders_psi</span> <span class="lean-var" data-type="â„•" title="â„•">p</span> <span class="lean-var" data-type="â„•" title="â„•">k</span> <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span> <span class="lean-var" data-type="0 &lt; k" title="0 &lt; k">hk</span> <span class="lean-var" data-type="Â¬(p = 2 âˆ§ k = 1)" title="Â¬(p = 2 âˆ§ k = 1)">h21</span>
    <span class="lean-operator">Â·</span> <span class="lean-comment">-- m is not a prime power: use factorization_split_lt</span>
      <span class="lean-keyword" data-docs="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for
a description of supported patterns.

```lean
obtain âŸ¨pattâŸ© : type := proof
```
is equivalent to
```lean
have h : type := proof
rcases h with âŸ¨pattâŸ©
```

If `âŸ¨pattâŸ©` is omitted, `rcases` will try to infer the pattern.

If `type` is omitted, `:= proof` is required.
" title="The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for">obtain</span> <span class="lean-bracket-1">âŸ¨</span><span class="lean-var" data-type="â„•" title="â„•">p</span>, <span class="lean-var" data-type="â„•" title="â„•">e</span>, <span class="lean-var" data-type="â„•" title="â„•">m&#x27;</span>, <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span>, <span class="lean-var" data-type="0 &lt; e" title="0 &lt; e">he_pos</span>, <span class="lean-var" data-type="p ^ e * m&#x27; = m" title="p ^ e * m&#x27; = m">hm_eq</span>, <span class="lean-var" data-type="(p ^ e).Coprime m&#x27;" title="(p ^ e).Coprime m&#x27;">hcop</span>, _, <span class="lean-var" data-type="m&#x27; &lt; m" title="m&#x27; &lt; m">hm&#x27;_lt</span>, _<span class="lean-bracket-1">âŸ©</span> :=
        <span class="lean-const" data-name="Crystallographic.factorization_split_lt" data-signature="Crystallographic.factorization_split_lt {m : â„•} (hm : 2 &lt; m) (h_not_pp : Â¬IsPrimePow m) :
  âˆƒ p e m&#x27;, Nat.Prime p âˆ§ 0 &lt; e âˆ§ p ^ e * m&#x27; = m âˆ§ (p ^ e).Coprime m&#x27; âˆ§ 1 &lt; m&#x27; âˆ§ m&#x27; &lt; m âˆ§ p ^ e &lt; m" title="Crystallographic.factorization_split_lt {m : â„•} (hm : 2 &lt; m) (h_not_pp : Â¬IsPrimePow m) :
  âˆƒ p e m&#x27;, Nat.Prime p âˆ§ 0 &lt; e âˆ§ p ^ e * m&#x27; = m âˆ§ (p ^ e).Coprime m&#x27; âˆ§ 1 &lt; m&#x27; âˆ§ m&#x27; &lt; m âˆ§ p ^ e &lt; m">factorization_split_lt</span> <span class="lean-bracket-1">(</span><span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span> : <span class="lean-number">2</span> &lt; m<span class="lean-bracket-1">)</span> <span class="lean-var" data-type="Â¬IsPrimePow m" title="Â¬IsPrimePow m">hpow</span>
      <span class="lean-keyword" data-docs="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : Â¬ p` in the second branch.
" title="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `">by_cases</span> <span class="lean-var" data-type="p = 2 âˆ§ e = 1" title="p = 2 âˆ§ e = 1">h_pe_is_2</span> : <span class="lean-var" data-type="â„•" title="â„•">p</span> = <span class="lean-expr" data-type="â„•" title="â„•">2</span> <span class="lean-operator">âˆ§</span> <span class="lean-var" data-type="â„•" title="â„•">e</span> = <span class="lean-expr" data-type="â„•" title="â„•">1</span>
      <span class="lean-operator">Â·</span> <span class="lean-comment">-- p^e = <span class="lean-number">2</span>, so m = <span class="lean-number">2</span> * m&#x27; with m&#x27; odd</span>
        <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="Nat.Coprime 2 m&#x27;" title="Nat.Coprime 2 m&#x27;">hcop&#x27;</span> : <span class="lean-const" data-name="Nat.Coprime" data-signature="Nat.Coprime (m n : â„•) : Prop" data-docs="`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. " title="Nat.Coprime (m n : â„•) : Prop
`m` and `n` are coprime, or relatively prime, if their `gcd` is 1. ">Nat.Coprime</span> <span class="lean-expr" data-type="â„•" title="â„•">2</span> <span class="lean-var" data-type="â„•" title="â„•">m&#x27;</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-var" data-type="p = 2 âˆ§ e = 1" title="p = 2 âˆ§ e = 1">h_pe_is_2</span>.<span class="lean-number">1</span>, <span class="lean-var" data-type="p = 2 âˆ§ e = 1" title="p = 2 âˆ§ e = 1">h_pe_is_2</span>.<span class="lean-number">2</span>, <span class="lean-const" data-name="pow_one" data-signature="pow_one.{u_2} {M : Type u_2} [Monoid M] (a : M) : a ^ 1 = a" title="pow_one.{u_2} {M : Type u_2} [Monoid M] (a : M) : a ^ 1 = a">pow_one</span><span class="lean-bracket-1">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`
* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="(p ^ e).Coprime m&#x27;" title="(p ^ e).Coprime m&#x27;">hcop</span> <span class="lean-operator">âŠ¢</span>; <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-var" data-type="Nat.Coprime 2 m&#x27;" title="Nat.Coprime 2 m&#x27;">hcop</span>
        <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-bracket-1">âŸ¨</span><span class="lean-var" data-type="Odd m&#x27;" title="Odd m&#x27;">hm&#x27;_odd</span>, <span class="lean-var" data-type="m&#x27; â‰  2" title="m&#x27; â‰  2">hm&#x27;_ne_2</span>, <span class="lean-var" data-type="3 â‰¤ m&#x27;" title="3 â‰¤ m&#x27;">hm&#x27;_ge3</span><span class="lean-bracket-1">âŸ©</span> := <span class="lean-const" data-name="_private.0.Crystallographic.odd_ne_two_ge_three_of_coprime_two" data-signature="Crystallographic.odd_ne_two_ge_three_of_coprime_two {m&#x27; : â„•} (hcop : Nat.Coprime 2 m&#x27;) (hm&#x27;_ge2 : 2 â‰¤ m&#x27;) :
  Odd m&#x27; âˆ§ m&#x27; â‰  2 âˆ§ 3 â‰¤ m&#x27;" data-docs="Derives oddness, non-equality to 2, and lower bound from coprimality to 2. " title="Crystallographic.odd_ne_two_ge_three_of_coprime_two {m&#x27; : â„•} (hcop : Nat.Coprime 2 m&#x27;) (hm&#x27;_ge2 : 2 â‰¤ m&#x27;) :
  Odd m&#x27; âˆ§ m&#x27; â‰  2 âˆ§ 3 â‰¤ m&#x27;
Derives oddness, non-equality to 2, and lower bound from coprimality to 2. ">odd_ne_two_ge_three_of_coprime_two</span> <span class="lean-var" data-type="Nat.Coprime 2 m&#x27;" title="Nat.Coprime 2 m&#x27;">hcop&#x27;</span> <span class="lean-bracket-1">(</span><span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span><span class="lean-bracket-1">)</span>
        <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-keyword">show</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> = <span class="lean-expr" data-type="â„•" title="â„•">2</span> * <span class="lean-var" data-type="â„•" title="â„•">m&#x27;</span> <span class="lean-keyword">by</span> <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-2">[</span><span class="lean-var" data-type="p = 2 âˆ§ e = 1" title="p = 2 âˆ§ e = 1">h_pe_is_2</span>.<span class="lean-number">1</span>, <span class="lean-var" data-type="p = 2 âˆ§ e = 1" title="p = 2 âˆ§ e = 1">h_pe_is_2</span>.<span class="lean-number">2</span>, <span class="lean-const" data-name="pow_one" data-signature="pow_one.{u_2} {M : Type u_2} [Monoid M] (a : M) : a ^ 1 = a" title="pow_one.{u_2} {M : Type u_2} [Monoid M] (a : M) : a ^ 1 = a">pow_one</span><span class="lean-bracket-2">]</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`
* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="p ^ e * m&#x27; = m" title="p ^ e * m&#x27; = m">hm_eq</span>; <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span><span class="lean-bracket-1">]</span>
        <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="_private.0.Crystallographic.mem_integerMatrixOrders_psi_2_times_odd" data-signature="Crystallographic.mem_integerMatrixOrders_psi_2_times_odd (m&#x27; : â„•) (hm&#x27;_pos : 0 &lt; m&#x27;) (hm&#x27;_odd : Odd m&#x27;)
  (hm&#x27;_ge3 : 3 â‰¤ m&#x27;) (IH_m&#x27; : m&#x27; âˆˆ integerMatrixOrders (psi m&#x27;)) : 2 * m&#x27; âˆˆ integerMatrixOrders (psi (2 * m&#x27;))" data-docs="Shows `2 * m&#x27; âˆˆ integerMatrixOrders (psi (2 * m&#x27;))` for odd `m&#x27; &gt;= 3`.
Uses the fact that negating an odd-order matrix doubles its order without changing dimension. " title="Crystallographic.mem_integerMatrixOrders_psi_2_times_odd (m&#x27; : â„•) (hm&#x27;_pos : 0 &lt; m&#x27;) (hm&#x27;_odd : Odd m&#x27;)
  (hm&#x27;_ge3 : 3 â‰¤ m&#x27;) (IH_m&#x27; : m&#x27; âˆˆ integerMatrixOrders (psi m&#x27;)) : 2 * m&#x27; âˆˆ integerMatrixOrders (psi (2 * m&#x27;))
Shows `2 * m&#x27; âˆˆ integerMatrixOrders (psi (2 * m&#x27;))` for odd `m&#x27; &gt;= 3`....">mem_integerMatrixOrders_psi_2_times_odd</span> <span class="lean-var" data-type="â„•" title="â„•">m&#x27;</span> <span class="lean-bracket-1">(</span><span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="Odd m&#x27;" title="Odd m&#x27;">hm&#x27;_odd</span> <span class="lean-var" data-type="3 â‰¤ m&#x27;" title="3 â‰¤ m&#x27;">hm&#x27;_ge3</span>
          <span class="lean-bracket-1">(</span><span class="lean-var" data-type="âˆ€ m_1 &lt; m, 0 &lt; m_1 â†’ m_1 â‰  2 â†’ m_1 âˆˆ integerMatrixOrders (psi m_1)" title="âˆ€ m_1 &lt; m, 0 &lt; m_1 â†’ m_1 â‰  2 â†’ m_1 âˆˆ integerMatrixOrders (psi m_1)">IH</span> <span class="lean-var" data-type="â„•" title="â„•">m&#x27;</span> <span class="lean-var" data-type="m&#x27; &lt; m" title="m&#x27; &lt; m">hm&#x27;_lt</span> <span class="lean-bracket-2">(</span><span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span><span class="lean-bracket-2">)</span> <span class="lean-var" data-type="m&#x27; â‰  2" title="m&#x27; â‰  2">hm&#x27;_ne_2</span><span class="lean-bracket-1">)</span>
      <span class="lean-operator">Â·</span> <span class="lean-keyword" data-docs="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : Â¬ p` in the second branch.
" title="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `">by_cases</span> <span class="lean-var" data-type="m&#x27; = 2" title="m&#x27; = 2">hm&#x27;_eq_2</span> : <span class="lean-var" data-type="â„•" title="â„•">m&#x27;</span> = <span class="lean-expr" data-type="â„•" title="â„•">2</span>
        <span class="lean-operator">Â·</span> <span class="lean-comment">-- m&#x27; = <span class="lean-number">2</span>, so m = p^e * <span class="lean-number">2</span> with p^e odd</span>
          <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-bracket-1">âŸ¨</span><span class="lean-var" data-type="Odd (p ^ e)" title="Odd (p ^ e)">hpe_odd</span>, <span class="lean-var" data-type="3 â‰¤ p ^ e" title="3 â‰¤ p ^ e">hpe_ge3</span><span class="lean-bracket-1">âŸ©</span> := <span class="lean-const" data-name="_private.0.Crystallographic.primePow_odd_ge_three_of_coprime_two" data-signature="Crystallographic.primePow_odd_ge_three_of_coprime_two {p e : â„•} (hp : Nat.Prime p) (he_pos : 0 &lt; e)
  (hcop : (p ^ e).Coprime 2) : Odd (p ^ e) âˆ§ 3 â‰¤ p ^ e" data-docs="Derives that a prime power coprime to 2 is odd and at least 3. " title="Crystallographic.primePow_odd_ge_three_of_coprime_two {p e : â„•} (hp : Nat.Prime p) (he_pos : 0 &lt; e)
  (hcop : (p ^ e).Coprime 2) : Odd (p ^ e) âˆ§ 3 â‰¤ p ^ e
Derives that a prime power coprime to 2 is odd and at least 3. ">primePow_odd_ge_three_of_coprime_two</span> <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span> <span class="lean-var" data-type="0 &lt; e" title="0 &lt; e">he_pos</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="m&#x27; = 2" title="m&#x27; = 2">hm&#x27;_eq_2</span> â–¸ <span class="lean-var" data-type="(p ^ e).Coprime m&#x27;" title="(p ^ e).Coprime m&#x27;">hcop</span><span class="lean-bracket-1">)</span>
          <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-operator">â†</span> <span class="lean-var" data-type="p ^ e * m&#x27; = m" title="p ^ e * m&#x27; = m">hm_eq</span>, <span class="lean-var" data-type="m&#x27; = 2" title="m&#x27; = 2">hm&#x27;_eq_2</span><span class="lean-bracket-1">]</span>
          <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="_private.0.Crystallographic.mem_integerMatrixOrders_psi_odd_times_2" data-signature="Crystallographic.mem_integerMatrixOrders_psi_odd_times_2 (k : â„•) (hk_pos : 0 &lt; k) (hk_odd : Odd k) (hk_ge3 : 3 â‰¤ k)
  (IH_k : k âˆˆ integerMatrixOrders (psi k)) : k * 2 âˆˆ integerMatrixOrders (psi (k * 2))" data-docs="Shows `k * 2 âˆˆ integerMatrixOrders (psi (k * 2))` for odd `k &gt;= 3`.
Symmetric version of `mem_integerMatrixOrders_psi_2_times_odd` with factor of 2 on the right. " title="Crystallographic.mem_integerMatrixOrders_psi_odd_times_2 (k : â„•) (hk_pos : 0 &lt; k) (hk_odd : Odd k) (hk_ge3 : 3 â‰¤ k)
  (IH_k : k âˆˆ integerMatrixOrders (psi k)) : k * 2 âˆˆ integerMatrixOrders (psi (k * 2))
Shows `k * 2 âˆˆ integerMatrixOrders (psi (k * 2))` for odd `k &gt;= 3`....">mem_integerMatrixOrders_psi_odd_times_2</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">p</span> ^ <span class="lean-var" data-type="â„•" title="â„•">e</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Nat.pow_pos" data-signature="Nat.pow_pos {a n : â„•} (h : 0 &lt; a) : 0 &lt; a ^ n" title="Nat.pow_pos {a n : â„•} (h : 0 &lt; a) : 0 &lt; a ^ n">Nat.pow_pos</span> <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span>.<span class="lean-const" data-name="Nat.Prime.pos" data-signature="Nat.Prime.pos {p : â„•} (pp : Nat.Prime p) : 0 &lt; p" title="Nat.Prime.pos {p : â„•} (pp : Nat.Prime p) : 0 &lt; p">pos</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="Odd (p ^ e)" title="Odd (p ^ e)">hpe_odd</span> <span class="lean-var" data-type="3 â‰¤ p ^ e" title="3 â‰¤ p ^ e">hpe_ge3</span>
            <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.primePow_mem_integerMatrixOrders_psi" data-signature="Crystallographic.primePow_mem_integerMatrixOrders_psi (p k : â„•) (hp : Nat.Prime p) (hk : 0 &lt; k)
  (hpk : Â¬(p = 2 âˆ§ k = 1)) : p ^ k âˆˆ integerMatrixOrders (psi (p ^ k))" data-docs="For prime power with p odd or k at least 2, p^k is in integerMatrixOrders(psi(p^k)). " title="Crystallographic.primePow_mem_integerMatrixOrders_psi (p k : â„•) (hp : Nat.Prime p) (hk : 0 &lt; k)
  (hpk : Â¬(p = 2 âˆ§ k = 1)) : p ^ k âˆˆ integerMatrixOrders (psi (p ^ k))
For prime power with p odd or k at least 2, p^k is in integerMatrixOrders(psi(p^k)). ">primePow_mem_integerMatrixOrders_psi</span> <span class="lean-var" data-type="â„•" title="â„•">p</span> <span class="lean-var" data-type="â„•" title="â„•">e</span> <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span> <span class="lean-var" data-type="0 &lt; e" title="0 &lt; e">he_pos</span> <span class="lean-var" data-type="Â¬(p = 2 âˆ§ e = 1)" title="Â¬(p = 2 âˆ§ e = 1)">h_pe_is_2</span><span class="lean-bracket-1">)</span>
        <span class="lean-operator">Â·</span> <span class="lean-comment">-- Neither is <span class="lean-number">2</span>, use block diagonal construction</span>
          <span class="lean-keyword" data-docs="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.
" title="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.">rw</span> <span class="lean-bracket-1">[</span><span class="lean-operator">â†</span> <span class="lean-var" data-type="p ^ e * m&#x27; = m" title="p ^ e * m&#x27; = m">hm_eq</span><span class="lean-bracket-1">]</span>
          <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="_private.0.Crystallographic.mem_integerMatrixOrders_psi_composite" data-signature="Crystallographic.mem_integerMatrixOrders_psi_composite (p e m&#x27; : â„•) (hp : Nat.Prime p) (hm&#x27;_pos : 0 &lt; m&#x27;)
  (hcop : (p ^ e).Coprime m&#x27;) (IH_pe : p ^ e âˆˆ integerMatrixOrders (psi (p ^ e)))
  (IH_m&#x27; : m&#x27; âˆˆ integerMatrixOrders (psi m&#x27;)) : p ^ e * m&#x27; âˆˆ integerMatrixOrders (psi (p ^ e * m&#x27;))" data-docs="Shows `p^e * m&#x27; âˆˆ integerMatrixOrders (psi (p^e * m&#x27;))` via block diagonal construction.
Combines IH results for coprime factors using additivity of psi. " title="Crystallographic.mem_integerMatrixOrders_psi_composite (p e m&#x27; : â„•) (hp : Nat.Prime p) (hm&#x27;_pos : 0 &lt; m&#x27;)
  (hcop : (p ^ e).Coprime m&#x27;) (IH_pe : p ^ e âˆˆ integerMatrixOrders (psi (p ^ e)))
  (IH_m&#x27; : m&#x27; âˆˆ integerMatrixOrders (psi m&#x27;)) : p ^ e * m&#x27; âˆˆ integerMatrixOrders (psi (p ^ e * m&#x27;))
Shows `p^e * m&#x27; âˆˆ integerMatrixOrders (psi (p^e * m&#x27;))` via block diagonal construction....">mem_integerMatrixOrders_psi_composite</span> <span class="lean-var" data-type="â„•" title="â„•">p</span> <span class="lean-var" data-type="â„•" title="â„•">e</span> <span class="lean-var" data-type="â„•" title="â„•">m&#x27;</span> <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span> <span class="lean-bracket-1">(</span><span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="(p ^ e).Coprime m&#x27;" title="(p ^ e).Coprime m&#x27;">hcop</span>
            <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.primePow_mem_integerMatrixOrders_psi" data-signature="Crystallographic.primePow_mem_integerMatrixOrders_psi (p k : â„•) (hp : Nat.Prime p) (hk : 0 &lt; k)
  (hpk : Â¬(p = 2 âˆ§ k = 1)) : p ^ k âˆˆ integerMatrixOrders (psi (p ^ k))" data-docs="For prime power with p odd or k at least 2, p^k is in integerMatrixOrders(psi(p^k)). " title="Crystallographic.primePow_mem_integerMatrixOrders_psi (p k : â„•) (hp : Nat.Prime p) (hk : 0 &lt; k)
  (hpk : Â¬(p = 2 âˆ§ k = 1)) : p ^ k âˆˆ integerMatrixOrders (psi (p ^ k))
For prime power with p odd or k at least 2, p^k is in integerMatrixOrders(psi(p^k)). ">primePow_mem_integerMatrixOrders_psi</span> <span class="lean-var" data-type="â„•" title="â„•">p</span> <span class="lean-var" data-type="â„•" title="â„•">e</span> <span class="lean-var" data-type="Nat.Prime p" title="Nat.Prime p">hp</span> <span class="lean-var" data-type="0 &lt; e" title="0 &lt; e">he_pos</span> <span class="lean-var" data-type="Â¬(p = 2 âˆ§ e = 1)" title="Â¬(p = 2 âˆ§ e = 1)">h_pe_is_2</span><span class="lean-bracket-1">)</span>
            <span class="lean-bracket-1">(</span><span class="lean-var" data-type="âˆ€ m_1 &lt; m, 0 &lt; m_1 â†’ m_1 â‰  2 â†’ m_1 âˆˆ integerMatrixOrders (psi m_1)" title="âˆ€ m_1 &lt; m, 0 &lt; m_1 â†’ m_1 â‰  2 â†’ m_1 âˆˆ integerMatrixOrders (psi m_1)">IH</span> <span class="lean-var" data-type="â„•" title="â„•">m&#x27;</span> <span class="lean-var" data-type="m&#x27; &lt; m" title="m&#x27; &lt; m">hm&#x27;_lt</span> <span class="lean-bracket-2">(</span><span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span><span class="lean-bracket-2">)</span> <span class="lean-var" data-type="Â¬m&#x27; = 2" title="Â¬m&#x27; = 2">hm&#x27;_eq_2</span><span class="lean-bracket-1">)</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L295-L360" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:mem-integerMatrixOrders-psi');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:backward-direction">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.18</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#thm:backward-direction">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000061"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0003.html#integerMatrixOrders-def">Definition 3.0.1</a></li>
          
          <li><a href="sect0002.html#psi-def">Definition 2.0.2</a></li>
          
          <li><a href="sect0004.html#companion-def">Definition 4.0.1</a></li>
          
          <li><a href="sect0004.html#thm:companion-charpoly">Theorem 4.0.1</a></li>
          
          <li><a href="sect0004.html#thm:companion-cycl-order">Theorem 4.0.5</a></li>
          
          <li><a href="sect0004.html#thm:mem-orders-totient">Theorem 4.0.7</a></li>
          
          <li><a href="sect0002.html#psiPrimePow-def">Definition 2.0.1</a></li>
          
          <li><a href="sect0003.html#lem:orders-mono">Theorem 3.0.3</a></li>
          
          <li><a href="sect0002.html#lem:psi-prime-pow">Theorem 2.0.1</a></li>
          
          <li><a href="sect0004.html#thm:companion-cycl-mem">Theorem 4.0.6</a></li>
          
          <li><a href="sect0005.html#thm:mem-integerMatrixOrders-psi">Theorem 5.0.17</a></li>
          
          <li><a href="sect0005.html#lem:mem-integerMatrixOrders-self">Theorem 5.0.15</a></li>
          
          <li><a href="sect0002.html#lem:psi-coprime-add">Theorem 2.0.3</a></li>
          
          <li><a href="sect0004.html#thm:mem-orders-totient">Theorem 4.0.7</a></li>
          
          <li><a href="sect0003.html#lem:one-mem-orders">Theorem 3.0.1</a></li>
          
          <li><a href="sect0003.html#lem:two-mem-orders">Theorem 3.0.2</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.mem_integerMatrixOrders_of_psi_le" class="lean_decl">Crystallographic.mem_integerMatrixOrders_of_psi_le</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>        <b class="bfseries">Backward Direction:</b> If \(\psi (m) \leq N\), then \(m \in \mathrm{Ord}_N\). </p>
<p><b class="bfseries">Mathematical context:</b> The companion matrix of a monic polynomial \(p(X)\) has \(p(X)\) as both its characteristic and minimal polynomial. For the cyclotomic polynomial \(\Phi _m\), the companion matrix \(C_m\) satisfies \(\Phi _m(C_m) = 0\), so \(C_m^m = I\), and since \(\Phi _m\) is minimal (irreducible over \(\mathbb {Q}\) and dividing \(X^m - 1\) but not \(X^k - 1\) for \(k {\lt} m\)), we get \(\mathrm{ord}(C_m) = m\). The key optimization in the \(\psi \) function is that \(\psi (2) = 0\): order 2 is achieved by \(-I\) in any dimension, so we do not need to â€œpayâ€ \(\varphi (2) = 1\) for the factor of 2. </p>
<p><b class="bfseries">Proof by explicit construction:</b> </p>
<ol class="enumerate">
  <li><p>For \(m = 1\): Use the identity matrix (any dimension). </p>
</li>
  <li><p>For \(m = 2\): Use \(-I\) (dimension \(\geq 1\)), achieving order 2 without adding to \(\psi \). </p>
</li>
  <li><p>For odd prime power \(p^k\): The companion matrix of \(\Phi _{p^k}\) has size \(\varphi (p^k)\). </p>
</li>
  <li><p>For \(2^k\) with \(k \geq 2\): The companion matrix of \(\Phi _{2^k}\) has size \(\varphi (2^k) = 2^{k-1}\). </p>
</li>
  <li><p>For \(m = 2m'\) with \(m'\) odd: If \(A\) has order \(m'\), then \(-A\) has order \(2m'\) (same dimension). </p>
</li>
  <li><p>For general \(m = \prod p_i^{k_i}\): Block diagonal of companion matrices for \(p_i^{k_i}\) with \(p_i \neq 2\) or \(k_i \geq 2\). The orders combine via \(\mathrm{lcm}\) (which equals the product for coprime factors), giving total order \(m\) in dimension \(\psi (m)\). </p>
</li>
  <li><p>Pad with identity blocks to reach size \(N \times N\) (padding does not change order). </p>
</li>
</ol>
<p>  - </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000061">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p> We construct a matrix of order \(m\) in dimension \(\psi (m)\) by taking block diagonals of companion matrices for cyclotomic polynomials \(\Phi _{p^k}\) of each prime power factor. The companion matrix \(C(\Phi _{p^k})\) has order exactly \(p^k\) and size \(\varphi (p^k)\). Block diagonal matrices have order equal to the lcm of block orders, which equals \(m\) for coprime factors. Identity padding extends to dimension \(N \geq \psi (m)\). - </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">theorem</span> <span class="lean-const lean-def" data-name="Crystallographic.mem_integerMatrixOrders_of_psi_le" data-signature="Crystallographic.mem_integerMatrixOrders_of_psi_le (N m : â„•) (hm : 0 &lt; m) (hpsi : psi m â‰¤ N) (hNm : m = 1 âˆ¨ 0 &lt; N) :
  m âˆˆ integerMatrixOrders N" data-docs="If psi(m) &lt;= N, then there exists an N x N integer matrix with order m.

This is the backward direction of the crystallographic restriction theorem.
The construction uses companion matrices of cyclotomic polynomials.

**Construction outline:**
1. For m = 1: use identity matrix (psi(1) = 0)
2. For m = 2: use -I (psi(2) = 0)
3. For prime power p^k with p odd or k &gt;= 2:
   - Use companion matrix of Phi_{p^k} (cyclotomic polynomial)
   - This has size phi(p^k) x phi(p^k) = psi(p^k) and order p^k
4. For general m = prod p_i^{k_i}:
   - Take block diagonal of companion matrices for each prime power factor
   - Total size is sum of phi(p_i^{k_i}) = psi(m)
5. Pad with identity blocks to reach size N x N
" title="Crystallographic.mem_integerMatrixOrders_of_psi_le (N m : â„•) (hm : 0 &lt; m) (hpsi : psi m â‰¤ N) (hNm : m = 1 âˆ¨ 0 &lt; N) :
  m âˆˆ integerMatrixOrders N
If psi(m) &lt;= N, then there exists an N x N integer matrix with order m....">mem_integerMatrixOrders_of_psi_le</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">N</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> : â„•<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span> : <span class="lean-expr" data-type="â„•" title="â„•">0</span> &lt; <span class="lean-var" data-type="â„•" title="â„•">m</span><span class="lean-bracket-1">)</span>
    <span class="lean-bracket-1">(</span><span class="lean-var" data-type="psi m â‰¤ N" title="psi m â‰¤ N">hpsi</span> : <span class="lean-const" data-name="Crystallographic.psi" data-signature="Crystallographic.psi (m : â„•) : â„•" data-docs="The psi function for crystallographic restriction.
psi(m) is the minimum dimension N such that an NÃ—N integer matrix can have order m.

Defined as the sum over prime power factors: if m = prod p_i^{k_i}, then
psi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) " title="Crystallographic.psi (m : â„•) : â„•
The psi function for crystallographic restriction....">psi</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-operator">â‰¤</span> <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="m = 1 âˆ¨ 0 &lt; N" title="m = 1 âˆ¨ 0 &lt; N">hNm</span> : <span class="lean-var" data-type="â„•" title="â„•">m</span> = <span class="lean-expr" data-type="â„•" title="â„•">1</span> <span class="lean-operator">âˆ¨</span> <span class="lean-expr" data-type="â„•" title="â„•">0</span> &lt; <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-1">)</span> :
    <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-operator">âˆˆ</span> <span class="lean-const" data-name="Crystallographic.integerMatrixOrders" data-signature="Crystallographic.integerMatrixOrders (N : â„•) : Set â„•" data-docs="The set of possible orders for NÃ—N integer matrices with finite order.
An integer `m` is in this set if there exists an NÃ—N integer matrix `A` such that
`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). " title="Crystallographic.integerMatrixOrders (N : â„•) : Set â„•
The set of possible orders for NÃ—N integer matrices with finite order....">integerMatrixOrders</span> <span class="lean-var" data-type="â„•" title="â„•">N</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span></code><code class="lean-proof-body">
  <span class="lean-comment">-- Handle base cases m = <span class="lean-number">1</span>, <span class="lean-number">2</span></span>
  <span class="lean-keyword" data-docs="`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to
destructure hypotheses or expressions composed of inductive types like `h1 : a âˆ§ b âˆ§ c âˆ¨ d` or
`h2 : âˆƒ x y, trans_rel R x y`. Usual usage might be `rcases h1 with âŸ¨ha, hb, hcâŸ© | hd` or
`rcases h2 with âŸ¨x, y, _ | âŸ¨z, hxz, hzyâŸ©âŸ©` for these examples.

Each element of an `rcases` pattern is matched against a particular local hypothesis (most of which
are generated during the execution of `rcases` and represent individual elements destructured from
the input expression). An `rcases` pattern has the following grammar:

* A name like `x`, which names the active hypothesis as `x`.
* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the
  hypothesis).
* A hyphen `-`, which clears the active hypothesis and any dependents.
* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the
  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).
* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it
  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)
* A tuple pattern `âŸ¨p1, p2, p3âŸ©`, which matches a constructor with many arguments, or a series
  of nested conjunctions or existentials. For example if the active hypothesis is `a âˆ§ b âˆ§ c`,
  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`
  and so on.
* A `@` before a tuple pattern as in `@âŸ¨p1, p2, p3âŸ©` will bind all arguments in the constructor,
  while leaving the `@` off will only use the patterns on the explicit arguments.
* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,
  or a nested disjunction like `a âˆ¨ b âˆ¨ c`.

A pattern like `âŸ¨a, b, câŸ© | âŸ¨d, eâŸ©` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `âŸ¨âŸ¨aâŸ©, b | câŸ© | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `âŸ¨a, b, câŸ©` for splitting on
`âˆƒ x, âˆƒ y, p x`, then it will be treated as `âŸ¨a, âŸ¨b, câŸ©âŸ©`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an
assumption `h : e = PAT` will be added to the context.
" title="`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to">rcases</span> <span class="lean-const" data-name="Nat.lt_trichotomy" data-signature="Nat.lt_trichotomy (a b : â„•) : a &lt; b âˆ¨ a = b âˆ¨ b &lt; a" title="Nat.lt_trichotomy (a b : â„•) : a &lt; b âˆ¨ a = b âˆ¨ b &lt; a">Nat.lt_trichotomy</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-expr" data-type="â„•" title="â„•">2</span> <span class="lean-keyword">with</span> <span class="lean-var" data-type="m &lt; 2" title="m &lt; 2">hm_lt2</span> | <span class="lean-var" data-type="m = 2" title="m = 2">rfl</span> | <span class="lean-var" data-type="2 &lt; m" title="2 &lt; m">hm_gt2</span>
  <span class="lean-operator">Â·</span> <span class="lean-comment">-- m &lt; <span class="lean-number">2</span> and <span class="lean-number">0</span> &lt; m, so m = <span class="lean-number">1</span></span>
    <span class="lean-keyword" data-docs="`interval_cases n` searches for upper and lower bounds on a variable `n`,
and if bounds are found,
splits into separate cases for each possible value of `n`.

As an example, in
```
example (n : â„•) (wâ‚ : n â‰¥ 3) (wâ‚‚ : n &lt; 5) : n = 3 âˆ¨ n = 4 := by
  interval_cases n
  all_goals simp
```
after `interval_cases n`, the goals are `3 = 3 âˆ¨ 3 = 4` and `4 = 3 âˆ¨ 4 = 4`.

You can also explicitly specify a lower and upper bound to use,
as `interval_cases using hl, hu`.
The hypotheses should be in the form `hl : a â‰¤ n` and `hu : n &lt; b`,
in which case `interval_cases` calls `fin_cases` on the resulting fact `n âˆˆ Set.Ico a b`.

You can specify a name `h` for the new hypothesis,
as `interval_cases h : n` or `interval_cases h : n using hl, hu`.
" title="`interval_cases n` searches for upper and lower bounds on a variable `n`,">interval_cases</span> <span class="lean-var" data-type="â„•" title="â„•">m</span>
    <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Crystallographic.one_mem_integerMatrixOrders" data-signature="Crystallographic.one_mem_integerMatrixOrders (N : â„•) : 1 âˆˆ integerMatrixOrders N" data-docs="The identity matrix has order 1, so 1 âˆˆ integerMatrixOrders N for any N. " title="Crystallographic.one_mem_integerMatrixOrders (N : â„•) : 1 âˆˆ integerMatrixOrders N
The identity matrix has order 1, so 1 âˆˆ integerMatrixOrders N for any N. ">one_mem_integerMatrixOrders</span> <span class="lean-var" data-type="â„•" title="â„•">N</span>
  <span class="lean-operator">Â·</span> <span class="lean-comment">-- m = <span class="lean-number">2</span>: use -I, need N &gt; <span class="lean-number">0</span></span>
    <span class="lean-keyword" data-docs="Assuming `x` is a variable in the local context with an inductive type,
`cases x` splits the main goal, producing one goal for each constructor of the
inductive type, in which the target is replaced by a general instance of that constructor.
If the type of an element in the local context depends on `x`,
that element is reverted and reintroduced afterward,
so that the case split affects that hypothesis as well.
`cases` detects unreachable cases and closes them automatically.

For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,
`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,
and one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.
Here the name `a` is chosen automatically and is not accessible.
You can use `with` to provide the variables names for each constructor.
- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,
  and then cases on the resulting variable.
- Given `as : List Î±`, `cases as with | nil =&gt; tacâ‚ | cons a as&#x27; =&gt; tacâ‚‚`,
  uses tactic `tacâ‚` for the `nil` case, and `tacâ‚‚` for the `cons` case,
  and `a` and `as&#x27;` are used as names for the new variables introduced.
- `cases h : e`, where `e` is a variable or an expression,
  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each goal,
  where `...` is the constructor instance for that particular case.
" title="Assuming `x` is a variable in the local context with an inductive type,">cases</span> <span class="lean-var" data-type="2 = 1 âˆ¨ 0 &lt; N" title="2 = 1 âˆ¨ 0 &lt; N">hNm</span> <span class="lean-keyword" data-docs="After `with`, there is an optional tactic that runs on all branches, and
then a list of alternatives.
" title="After `with`, there is an optional tactic that runs on all branches, and">with</span>
    | <span class="lean-const" data-name="Or.inl" data-signature="Or.inl {a b : Prop} (h : a) : a âˆ¨ b" data-docs="`Or.inl` is &quot;left injection&quot; into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. " title="Or.inl {a b : Prop} (h : a) : a âˆ¨ b
`Or.inl` is &quot;left injection&quot; into an `Or`. If `h : a` then `Or.inl h : a âˆ¨ b`. ">inl</span> <span class="lean-var" data-type="2 = 1" title="2 = 1">h</span> =&gt; <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span>
    | <span class="lean-const" data-name="Or.inr" data-signature="Or.inr {a b : Prop} (h : b) : a âˆ¨ b" data-docs="`Or.inr` is &quot;right injection&quot; into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. " title="Or.inr {a b : Prop} (h : b) : a âˆ¨ b
`Or.inr` is &quot;right injection&quot; into an `Or`. If `h : b` then `Or.inr h : a âˆ¨ b`. ">inr</span> <span class="lean-var" data-type="0 &lt; N" title="0 &lt; N">hN_pos</span> =&gt;
      <span class="lean-keyword" data-docs="`haveI` behaves like `have`, but inlines the value instead of producing a `have` term. " title="`haveI` behaves like `have`, but inlines the value instead of producing a `have` term. ">haveI</span> : <span class="lean-const" data-name="NeZero" data-signature="NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop" data-docs="A type-class version of `n â‰  0`.  " title="NeZero.{u_1} {R : Type u_1} [Zero R] (n : R) : Prop
A type-class version of `n â‰  0`.  ">NeZero</span> <span class="lean-var" data-type="â„•" title="â„•">N</span> := <span class="lean-const" data-signature="NeZero.mk.{u_1} {R : Type u_1} [Zero R] {n : R} (out : n â‰  0) : NeZero n" title="NeZero.mk.{u_1} {R : Type u_1} [Zero R] {n : R} (out : n â‰  0) : NeZero n">âŸ¨</span><span class="lean-const" data-name="Nat.pos_iff_ne_zero" data-signature="Nat.pos_iff_ne_zero {n : â„•} : 0 &lt; n â†” n â‰  0" title="Nat.pos_iff_ne_zero {n : â„•} : 0 &lt; n â†” n â‰  0">Nat.pos_iff_ne_zero</span>.<span class="lean-const" data-name="Iff.mp" data-signature="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b" data-docs="Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. " title="Iff.mp {a b : Prop} (self : a â†” b) : a â†’ b
Modus ponens for if and only if. If `a â†” b` and `a`, then `b`. ">mp</span> <span class="lean-var" data-type="0 &lt; N" title="0 &lt; N">hN_pos</span><span class="lean-const" data-signature="NeZero.mk.{u_1} {R : Type u_1} [Zero R] {n : R} (out : n â‰  0) : NeZero n" title="NeZero.mk.{u_1} {R : Type u_1} [Zero R] {n : R} (out : n â‰  0) : NeZero n">âŸ©</span>
      <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Crystallographic.two_mem_integerMatrixOrders" data-signature="Crystallographic.two_mem_integerMatrixOrders (N : â„•) [NeZero N] : 2 âˆˆ integerMatrixOrders N" data-docs="For N â‰¥ 1, the negation of the identity matrix has order 2. " title="Crystallographic.two_mem_integerMatrixOrders (N : â„•) [NeZero N] : 2 âˆˆ integerMatrixOrders N
For N â‰¥ 1, the negation of the identity matrix has order 2. ">two_mem_integerMatrixOrders</span> <span class="lean-var" data-type="â„•" title="â„•">N</span>
  <span class="lean-operator">Â·</span> <span class="lean-comment">-- m &gt; <span class="lean-number">2</span>, i.e., m &gt;= <span class="lean-number">3</span></span>
    <span class="lean-comment">-- If m <span class="lean-operator">â‰¤</span> N, use permutation matrix directly</span>
    <span class="lean-keyword" data-docs="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : Â¬ p` in the second branch.
" title="`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `">by_cases</span> <span class="lean-var" data-type="m â‰¤ N" title="m â‰¤ N">hle</span> : <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-operator">â‰¤</span> <span class="lean-var" data-type="â„•" title="â„•">N</span>
    <span class="lean-operator">Â·</span> <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="Crystallographic.integerMatrixOrders_mono" data-signature="Crystallographic.integerMatrixOrders_mono {M N : â„•} (hMN : M â‰¤ N) : integerMatrixOrders M âŠ† integerMatrixOrders N" data-docs="Monotonicity: if M &lt;= N, then any order achievable for M x M matrices is also achievable
for N x N matrices.

The construction pads the M x M matrix with an identity block in the lower-right corner. " title="Crystallographic.integerMatrixOrders_mono {M N : â„•} (hMN : M â‰¤ N) : integerMatrixOrders M âŠ† integerMatrixOrders N
Monotonicity: if M &lt;= N, then any order achievable for M x M matrices is also achievable...">integerMatrixOrders_mono</span> <span class="lean-var" data-type="m â‰¤ N" title="m â‰¤ N">hle</span> <span class="lean-bracket-1">(</span><span class="lean-const" data-name="Crystallographic.mem_integerMatrixOrders_self" data-signature="Crystallographic.mem_integerMatrixOrders_self (n : â„•) (hn : 2 â‰¤ n) : n âˆˆ integerMatrixOrders n" data-docs="Order n is achievable by an n x n integer matrix for n at least 2. " title="Crystallographic.mem_integerMatrixOrders_self (n : â„•) (hn : 2 â‰¤ n) : n âˆˆ integerMatrixOrders n
Order n is achievable by an n x n integer matrix for n at least 2. ">mem_integerMatrixOrders_self</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-bracket-2">(</span><span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span><span class="lean-bracket-2">)</span><span class="lean-bracket-1">)</span>
    <span class="lean-operator">Â·</span> <span class="lean-comment">-- m &gt; N: need companion matrices</span>
      <span class="lean-keyword" data-docs="Push negations into the conclusion or a hypothesis.
For instance, a hypothesis `h : Â¬ âˆ€ x, âˆƒ y, x â‰¤ y` will be transformed by `push_neg at h` into
`h : âˆƒ x, âˆ€ y, y &lt; x`. Binder names are preserved.

`push_neg` is a special case of the more general `push` tactic, namely `push Not`.
The `push` tactic can be extended using the `@[push]` attribute. `push` has special-casing
built in for `push Not`, so that it can preserve binder names, and so that `Â¬ (p âˆ§ q)` can be
transformed to either `p â†’ Â¬ q` (default) or `Â¬ p âˆ¨ Â¬ q` (`push_neg +distrib`).

Tactics that introduce a negation usually have a version that automatically calls `push_neg` on
that negation. These include `by_cases!`, `contrapose!` and `by_contra!`.

Another example: given a hypothesis
```lean
h : Â¬ âˆ€ Îµ &gt; 0, âˆƒ Î´ &gt; 0, âˆ€ x, |x - xâ‚€| â‰¤ Î´ â†’ |f x - yâ‚€| â‰¤ Îµ
```
writing `push_neg at h` will turn `h` into
```lean
h : âˆƒ Îµ &gt; 0, âˆ€ Î´ &gt; 0, âˆƒ x, |x - xâ‚€| â‰¤ Î´ âˆ§ Îµ &lt; |f x - yâ‚€|
```
Note that binder names are preserved by this tactic, contrary to what would happen with `simp`
using the relevant lemmas. One can use this tactic at the goal using `push_neg`,
at every hypothesis and the goal using `push_neg at *` or at selected hypotheses and the goal
using say `push_neg at h h&#x27; âŠ¢`, as usual.
" title="Push negations into the conclusion or a hypothesis.">push_neg</span> <span class="lean-keyword" data-docs="Location specifications are used by many tactics that can operate on either the
hypotheses or the goal. It can have one of the forms:
* &#x27;empty&#x27; is not actually present in this syntax, but most tactics use
  `(location)?` matchers. It means to target the goal only.
* `at hâ‚ ... hâ‚™`: target the hypotheses `hâ‚`, ..., `hâ‚™`
* `at hâ‚ hâ‚‚ âŠ¢`: target the hypotheses `hâ‚` and `hâ‚‚`, and the goal
* `at *`: target all hypotheses and the goal
" title="Location specifications are used by many tactics that can operate on either the">at</span> <span class="lean-var" data-type="Â¬m â‰¤ N" title="Â¬m â‰¤ N">hle</span>
      <span class="lean-comment">-- Case split on m</span>
      <span class="lean-keyword" data-docs="`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to
destructure hypotheses or expressions composed of inductive types like `h1 : a âˆ§ b âˆ§ c âˆ¨ d` or
`h2 : âˆƒ x y, trans_rel R x y`. Usual usage might be `rcases h1 with âŸ¨ha, hb, hcâŸ© | hd` or
`rcases h2 with âŸ¨x, y, _ | âŸ¨z, hxz, hzyâŸ©âŸ©` for these examples.

Each element of an `rcases` pattern is matched against a particular local hypothesis (most of which
are generated during the execution of `rcases` and represent individual elements destructured from
the input expression). An `rcases` pattern has the following grammar:

* A name like `x`, which names the active hypothesis as `x`.
* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the
  hypothesis).
* A hyphen `-`, which clears the active hypothesis and any dependents.
* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the
  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).
* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it
  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)
* A tuple pattern `âŸ¨p1, p2, p3âŸ©`, which matches a constructor with many arguments, or a series
  of nested conjunctions or existentials. For example if the active hypothesis is `a âˆ§ b âˆ§ c`,
  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`
  and so on.
* A `@` before a tuple pattern as in `@âŸ¨p1, p2, p3âŸ©` will bind all arguments in the constructor,
  while leaving the `@` off will only use the patterns on the explicit arguments.
* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,
  or a nested disjunction like `a âˆ¨ b âˆ¨ c`.

A pattern like `âŸ¨a, b, câŸ© | âŸ¨d, eâŸ©` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `âŸ¨âŸ¨aâŸ©, b | câŸ© | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `âŸ¨a, b, câŸ©` for splitting on
`âˆƒ x, âˆƒ y, p x`, then it will be treated as `âŸ¨a, âŸ¨b, câŸ©âŸ©`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an
assumption `h : e = PAT` will be added to the context.
" title="`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to">rcases</span> <span class="lean-const" data-name="Nat.lt_trichotomy" data-signature="Nat.lt_trichotomy (a b : â„•) : a &lt; b âˆ¨ a = b âˆ¨ b &lt; a" title="Nat.lt_trichotomy (a b : â„•) : a &lt; b âˆ¨ a = b âˆ¨ b &lt; a">Nat.lt_trichotomy</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-expr" data-type="â„•" title="â„•">5</span> <span class="lean-keyword">with</span> <span class="lean-var" data-type="m &lt; 5" title="m &lt; 5">hm_lt5</span> | <span class="lean-var" data-type="m = 5" title="m = 5">rfl</span> | <span class="lean-var" data-type="5 &lt; m" title="5 &lt; m">hm_gt5</span>
      <span class="lean-operator">Â·</span> <span class="lean-comment">-- m <span class="lean-operator">âˆˆ</span> </span><span class="lean-bracket-1">{</span><span class="lean-number">3</span>, <span class="lean-number">4</span><span class="lean-bracket-1">}</span>: use small case helper
        <span class="lean-keyword" data-docs="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.

* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p âˆ§ q âˆ§ r`, `have âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := h` produces the
  hypotheses `hâ‚ : p`, `hâ‚‚ : q`, and `hâ‚ƒ : r`.
* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,
  which adds the equation `h : e = pat` to the local context.

The tactic supports all the same syntax variants and options as the `have` term.

## Properties and relations

* It is not possible to unfold a variable introduced using `have`, since the definition&#x27;s value is forgotten.
  The `let` tactic introduces definitions that can be unfolded.
* The `have h : t := e` is like doing `let h : t := e; clear_value h`.
* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.
* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,
  which may be important for performance reasons.
    Consider using the equivalent `let +nondep` to indicate the intent.

" title="The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main g">have</span> <span class="lean-var" data-type="m âˆˆ {3, 4, 6}" title="m âˆˆ {3, 4, 6}">hm34</span> : <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-operator">âˆˆ</span> <span class="lean-bracket-1">(</span><span class="lean-bracket-2">{</span><span class="lean-expr" data-type="â„•" title="â„•">3</span>, <span class="lean-expr" data-type="â„•" title="â„•">4</span>, <span class="lean-expr" data-type="â„•" title="â„•">6</span><span class="lean-bracket-2">}</span> : <span class="lean-const" data-name="Finset" data-signature="Finset.{u_4} (Î± : Type u_4) : Type u_4" data-docs="`Finset Î±` is the type of finite sets of elements of `Î±`. It is implemented
as a multiset (a list up to permutation) which has no duplicate elements. " title="Finset.{u_4} (Î± : Type u_4) : Type u_4
`Finset Î±` is the type of finite sets of elements of `Î±`. It is implemented...">Finset</span> â„•<span class="lean-bracket-1">)</span> := <span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span>
          <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span> <span class="lean-keyword">only</span> <span class="lean-bracket-1">[</span><span class="lean-const" data-name="Finset.mem_insert" data-signature="Finset.mem_insert.{u_1} {Î± : Type u_1} [DecidableEq Î±] {s : Finset Î±} {a b : Î±} : a âˆˆ insert b s â†” a = b âˆ¨ a âˆˆ s" title="Finset.mem_insert.{u_1} {Î± : Type u_1} [DecidableEq Î±] {s : Finset Î±} {a b : Î±} : a âˆˆ insert b s â†” a = b âˆ¨ a âˆˆ s">Finset.mem_insert</span>, <span class="lean-const" data-name="Finset.mem_singleton" data-signature="Finset.mem_singleton.{u_1} {Î± : Type u_1} {a b : Î±} : b âˆˆ {a} â†” b = a" title="Finset.mem_singleton.{u_1} {Î± : Type u_1} {a b : Î±} : b âˆˆ {a} â†” b = a">Finset.mem_singleton</span><span class="lean-bracket-1">]</span>
          <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span>
        <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="_private.0.Crystallographic.mem_integerMatrixOrders_small" data-signature="Crystallographic.mem_integerMatrixOrders_small (m N : â„•) (hm : m âˆˆ {3, 4, 6}) (hpsi : psi m â‰¤ N) :
  m âˆˆ integerMatrixOrders N" data-docs="Helper for small cases: if m âˆˆ {3, 4, 6} and psi(m) â‰¤ N, then m âˆˆ integerMatrixOrders N. " title="Crystallographic.mem_integerMatrixOrders_small (m N : â„•) (hm : m âˆˆ {3, 4, 6}) (hpsi : psi m â‰¤ N) :
  m âˆˆ integerMatrixOrders N
Helper for small cases: if m âˆˆ {3, 4, 6} and psi(m) â‰¤ N, then m âˆˆ integerMatrixOrders N. ">mem_integerMatrixOrders_small</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-var" data-type="â„•" title="â„•">N</span> <span class="lean-var" data-type="m âˆˆ {3, 4, 6}" title="m âˆˆ {3, 4, 6}">hm34</span> <span class="lean-var" data-type="psi m â‰¤ N" title="psi m â‰¤ N">hpsi</span>
      <span class="lean-operator">Â·</span> <span class="lean-comment">-- m = <span class="lean-number">5</span></span>
        <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="_private.0.Crystallographic.mem_integerMatrixOrders_five" data-signature="Crystallographic.mem_integerMatrixOrders_five (N : â„•) (hpsi : psi 5 â‰¤ N) : 5 âˆˆ integerMatrixOrders N" data-docs="Helper for m = 5: psi(5) = 4, so if 4 â‰¤ N, then 5 âˆˆ integerMatrixOrders N. " title="Crystallographic.mem_integerMatrixOrders_five (N : â„•) (hpsi : psi 5 â‰¤ N) : 5 âˆˆ integerMatrixOrders N
Helper for m = 5: psi(5) = 4, so if 4 â‰¤ N, then 5 âˆˆ integerMatrixOrders N. ">mem_integerMatrixOrders_five</span> <span class="lean-var" data-type="â„•" title="â„•">N</span> <span class="lean-var" data-type="psi 5 â‰¤ N" title="psi 5 â‰¤ N">hpsi</span>
      <span class="lean-operator">Â·</span> <span class="lean-comment">-- m &gt; <span class="lean-number">5</span></span>
        <span class="lean-keyword" data-docs="`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to
destructure hypotheses or expressions composed of inductive types like `h1 : a âˆ§ b âˆ§ c âˆ¨ d` or
`h2 : âˆƒ x y, trans_rel R x y`. Usual usage might be `rcases h1 with âŸ¨ha, hb, hcâŸ© | hd` or
`rcases h2 with âŸ¨x, y, _ | âŸ¨z, hxz, hzyâŸ©âŸ©` for these examples.

Each element of an `rcases` pattern is matched against a particular local hypothesis (most of which
are generated during the execution of `rcases` and represent individual elements destructured from
the input expression). An `rcases` pattern has the following grammar:

* A name like `x`, which names the active hypothesis as `x`.
* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the
  hypothesis).
* A hyphen `-`, which clears the active hypothesis and any dependents.
* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the
  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).
* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it
  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)
* A tuple pattern `âŸ¨p1, p2, p3âŸ©`, which matches a constructor with many arguments, or a series
  of nested conjunctions or existentials. For example if the active hypothesis is `a âˆ§ b âˆ§ c`,
  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`
  and so on.
* A `@` before a tuple pattern as in `@âŸ¨p1, p2, p3âŸ©` will bind all arguments in the constructor,
  while leaving the `@` off will only use the patterns on the explicit arguments.
* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,
  or a nested disjunction like `a âˆ¨ b âˆ¨ c`.

A pattern like `âŸ¨a, b, câŸ© | âŸ¨d, eâŸ©` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `âŸ¨âŸ¨aâŸ©, b | câŸ© | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `âŸ¨a, b, câŸ©` for splitting on
`âˆƒ x, âˆƒ y, p x`, then it will be treated as `âŸ¨a, âŸ¨b, câŸ©âŸ©`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an
assumption `h : e = PAT` will be added to the context.
" title="`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to">rcases</span> <span class="lean-const" data-name="Nat.lt_trichotomy" data-signature="Nat.lt_trichotomy (a b : â„•) : a &lt; b âˆ¨ a = b âˆ¨ b &lt; a" title="Nat.lt_trichotomy (a b : â„•) : a &lt; b âˆ¨ a = b âˆ¨ b &lt; a">Nat.lt_trichotomy</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-expr" data-type="â„•" title="â„•">6</span> <span class="lean-keyword">with</span> <span class="lean-var" data-type="m &lt; 6" title="m &lt; 6">hm_lt6</span> | <span class="lean-var" data-type="m = 6" title="m = 6">rfl</span> | <span class="lean-var" data-type="6 &lt; m" title="6 &lt; m">hm_gt6</span>
        <span class="lean-operator">Â·</span> <span class="lean-keyword" data-docs="The `omega` tactic, for resolving integer and natural linear arithmetic problems.

It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.

We handle hypotheses of the form `x = y`, `x &lt; y`, `x â‰¤ y`, and `k âˆ£ x` for `x y` in `Nat` or `Int`
(and `k` a literal), along with negations of these statements.

We decompose the sides of the inequalities as linear combinations of atoms.

If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables
and the relevant inequalities.

On the first pass, we do not perform case splits on natural subtraction.
If `omega` fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.

The options
```
omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
```
can be used to:
* `splitDisjunctions`: split any disjunctions found in the context,
  if the problem is not otherwise solvable.
* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a â‰¤ b` if necessary.
* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 â‰¤ a` if necessary.
* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a âˆ¨ min a b = b`
Currently, all of these are on by default.
" title="The `omega` tactic, for resolving integer and natural linear arithmetic problems.">omega</span> <span class="lean-comment">-- impossible: <span class="lean-number">5</span> &lt; m &lt; <span class="lean-number">6</span></span>
        <span class="lean-operator">Â·</span> <span class="lean-comment">-- m = <span class="lean-number">6</span></span>
          <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="_private.0.Crystallographic.mem_integerMatrixOrders_small" data-signature="Crystallographic.mem_integerMatrixOrders_small (m N : â„•) (hm : m âˆˆ {3, 4, 6}) (hpsi : psi m â‰¤ N) :
  m âˆˆ integerMatrixOrders N" data-docs="Helper for small cases: if m âˆˆ {3, 4, 6} and psi(m) â‰¤ N, then m âˆˆ integerMatrixOrders N. " title="Crystallographic.mem_integerMatrixOrders_small (m N : â„•) (hm : m âˆˆ {3, 4, 6}) (hpsi : psi m â‰¤ N) :
  m âˆˆ integerMatrixOrders N
Helper for small cases: if m âˆˆ {3, 4, 6} and psi(m) â‰¤ N, then m âˆˆ integerMatrixOrders N. ">mem_integerMatrixOrders_small</span> <span class="lean-expr" data-type="â„•" title="â„•">6</span> <span class="lean-var" data-type="â„•" title="â„•">N</span> <span class="lean-bracket-1">(</span><span class="lean-keyword" data-docs="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. " title="`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ">by</span> <span class="lean-keyword" data-docs="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [hâ‚, hâ‚‚, ..., hâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions.-
- If an `háµ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated
  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [hâ‚, hâ‚‚, ..., hâ‚™]` is like `simp [hâ‚, hâ‚‚, ..., hâ‚™]` but does not use `[simp]` lemmas.
- `simp [-idâ‚, ..., -idâ‚™]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idáµ¢`.
- `simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. If
  the target or another hypothesis depends on `háµ¢`, a new simplified hypothesis
  `háµ¢` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
" title="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or">simp</span><span class="lean-bracket-1">)</span> <span class="lean-var" data-type="psi 6 â‰¤ N" title="psi 6 â‰¤ N">hpsi</span>
        <span class="lean-operator">Â·</span> <span class="lean-comment">-- m &gt; <span class="lean-number">6</span>: general case</span>
          <span class="lean-keyword" data-docs="`exact e` closes the main goal if its target type matches that of `e`.
" title="`exact e` closes the main goal if its target type matches that of `e`.">exact</span> <span class="lean-const" data-name="_private.0.Crystallographic.mem_integerMatrixOrders_of_psi_le_large" data-signature="Crystallographic.mem_integerMatrixOrders_of_psi_le_large (m N : â„•) (hm : 6 &lt; m) (hpsi : psi m â‰¤ N) :
  m âˆˆ integerMatrixOrders N" data-docs="Helper for m &gt; 6: general case using companion matrices or psi construction. " title="Crystallographic.mem_integerMatrixOrders_of_psi_le_large (m N : â„•) (hm : 6 &lt; m) (hpsi : psi m â‰¤ N) :
  m âˆˆ integerMatrixOrders N
Helper for m &gt; 6: general case using companion matrices or psi construction. ">mem_integerMatrixOrders_of_psi_le_large</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-var" data-type="â„•" title="â„•">N</span> <span class="lean-var" data-type="6 &lt; m" title="6 &lt; m">hm_gt6</span> <span class="lean-var" data-type="psi m â‰¤ N" title="psi m â‰¤ N">hpsi</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/CrystallographicRestriction/Backward.lean#L404-L485" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:backward-direction');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>


<div class="theorem_thmwrapper sbs-container theorem-style-definition" id="thm:main-theorem">
  <div class="sbs-latex-column">
    <div class="theorem_thmheading">
      <span class="theorem_thmcaption">
      Theorem
      </span>
      <span class="theorem_thmlabel">5.0.19</span>
      <div class="thm_header_extras">

    
    âœ“
          </div>
      <div class="thm_header_hidden_extras">

    <a class="icon proof" href="sect0005.html#thm:main-theorem">#</a>
    
    <a class="icon proof" href="sect0005.html#a0000000062"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="sect0002.html#psi-def">Definition 2.0.2</a></li>
          
          <li><a href="sect0003.html#integerMatrixOrders-def">Definition 3.0.1</a></li>
          
          <li><a href="sect0005.html#thm:backward-direction">Theorem 5.0.18</a></li>
          
          <li><a href="sect0005.html#thm:forward-direction">Theorem 5.0.7</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">Lâˆƒâˆ€N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://e-vergo.github.io/General_Crystallographic_Restriction/docs/find/#doc/Crystallographic.crystallographic_restriction" class="lean_decl">Crystallographic.crystallographic_restriction</a></li>
          
        </ul>
    
      </div>
    </div>

    
          </div>
    </div>
    <div class="theorem_thmcontent">
    <p>        <b class="bfseries">The Crystallographic Restriction Theorem:</b> An \(N \times N\) integer matrix can have finite order \(m\) if and only if \(\psi (m) \leq N\). </p>
<p>Equivalently: \(m \in \mathrm{Ord}_N \iff \psi (m) \leq N\). </p>
<p>This theorem completely characterizes which rotation orders are achievable by integer matrices in each dimension. The function \(\psi \) is defined as: \(\psi (1) = \psi (2) = 0\), and for other \(m\), \(\psi (m) = \sum _{p^k \|  m, p \neq 2 \text{ or } k \geq 2} \varphi (p^k)\). </p>
<p><b class="bfseries">Forward direction:</b> If \(A \in \mathbb {Z}^{N \times N}\) has order \(m\), the minimal polynomial of \(A\) over \(\mathbb {Q}\) divides \(X^m - 1\) and must include cyclotomic factors \(\Phi _d\) for divisors \(d\) whose lcm equals \(m\). The sum of \(\varphi (d)\) over these divisors is at least \(\psi (m)\), and this sum bounds the degree of the minimal polynomial, which is at most \(N\). </p>
<p><b class="bfseries">Backward direction:</b> For each prime power \(p^k\) (with \(p \neq 2\) or \(k \geq 2\)), the companion matrix of \(\Phi _{p^k}\) has size \(\varphi (p^k)\) and order \(p^k\). For general \(m\), block diagonal combinations of these companion matrices achieve order \(m\) in dimension \(\psi (m)\). - </p>

    </div>
    <div class="proof_wrapper proof_inline" id="a0000000062">
      <div class="proof_heading">
        <span class="proof_caption">
        Proof
        </span>
        <span class="expand-proof">â–¶</span>
      </div>
      <div class="proof_content">
      <p> The proof combines the forward and backward directions. The forward direction shows that eigenvalue constraints force \(\psi (m) \leq N\). The backward direction constructs explicit matrices achieving each order using companion matrices of cyclotomic polynomials. - </p>

      </div>
    </div>
  </div>
  <div class="sbs-lean-column">
    <pre class="lean-code"><code class="lean-signature"><span class="lean-keyword">theorem</span> <span class="lean-const lean-def" data-name="Crystallographic.crystallographic_restriction" data-signature="Crystallographic.crystallographic_restriction (N m : â„•) (hm : 0 &lt; m) (hNm : m = 1 âˆ¨ 0 &lt; N) :
  m âˆˆ integerMatrixOrders N â†” psi m â‰¤ N" data-docs="**The Crystallographic Restriction Theorem:**
An NÃ—N integer matrix can have finite order m if and only if psi(m) â‰¤ N.

This characterizes exactly which rotation orders are possible in N-dimensional
crystallographic groups. " title="Crystallographic.crystallographic_restriction (N m : â„•) (hm : 0 &lt; m) (hNm : m = 1 âˆ¨ 0 &lt; N) :
  m âˆˆ integerMatrixOrders N â†” psi m â‰¤ N
**The Crystallographic Restriction Theorem:**...">crystallographic_restriction</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="â„•" title="â„•">N</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> : â„•<span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span> : <span class="lean-expr" data-type="â„•" title="â„•">0</span> &lt; <span class="lean-var" data-type="â„•" title="â„•">m</span><span class="lean-bracket-1">)</span> <span class="lean-bracket-1">(</span><span class="lean-var" data-type="m = 1 âˆ¨ 0 &lt; N" title="m = 1 âˆ¨ 0 &lt; N">hNm</span> : <span class="lean-var" data-type="â„•" title="â„•">m</span> = <span class="lean-expr" data-type="â„•" title="â„•">1</span> <span class="lean-operator">âˆ¨</span> <span class="lean-expr" data-type="â„•" title="â„•">0</span> &lt; <span class="lean-var" data-type="â„•" title="â„•">N</span><span class="lean-bracket-1">)</span> :
    <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-operator">âˆˆ</span> <span class="lean-const" data-name="Crystallographic.integerMatrixOrders" data-signature="Crystallographic.integerMatrixOrders (N : â„•) : Set â„•" data-docs="The set of possible orders for NÃ—N integer matrices with finite order.
An integer `m` is in this set if there exists an NÃ—N integer matrix `A` such that
`orderOf A = m` and `m &gt; 0` (equivalently, `A` has finite order). " title="Crystallographic.integerMatrixOrders (N : â„•) : Set â„•
The set of possible orders for NÃ—N integer matrices with finite order....">integerMatrixOrders</span> <span class="lean-var" data-type="â„•" title="â„•">N</span> <span class="lean-operator">â†”</span> <span class="lean-const" data-name="Crystallographic.psi" data-signature="Crystallographic.psi (m : â„•) : â„•" data-docs="The psi function for crystallographic restriction.
psi(m) is the minimum dimension N such that an NÃ—N integer matrix can have order m.

Defined as the sum over prime power factors: if m = prod p_i^{k_i}, then
psi(m) = sum_i (if p_i = 2 and k_i = 1 then 0 else phi(p_i^{k_i})) " title="Crystallographic.psi (m : â„•) : â„•
The psi function for crystallographic restriction....">psi</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-operator">â‰¤</span> <span class="lean-var" data-type="â„•" title="â„•">N</span> :=</code><code class="lean-proof-body">
  <span class="lean-bracket-1">âŸ¨</span><span class="lean-const" data-name="Crystallographic.psi_le_of_mem_integerMatrixOrders" data-signature="Crystallographic.psi_le_of_mem_integerMatrixOrders (N m : â„•) (hm : 0 &lt; m) (hord : m âˆˆ integerMatrixOrders N) : psi m â‰¤ N" data-docs="If an N x N integer matrix has finite order m, then psi(m) &lt;= N.

This is the forward direction of the crystallographic restriction theorem.
The proof uses eigenvalue theory: primitive m-th roots of unity must appear
as eigenvalues, and their algebraic degree constrains the matrix dimension.

**Proof outline:**
1. An integer matrix A with A^m = 1 has minimal polynomial dividing X^m - 1
2. If orderOf A = m, then the minimal polynomial is lcm of cyclotomic polynomials
   Î¦_d for some divisors d of m with lcm(d) = m
3. The primitive m-th roots have minimal polynomial Phi_m (the cyclotomic polynomial)
4. These eigenvalues require dimension &gt;= phi(d) for each d in the set
5. By sum_totient_ge_psi_of_lcm_eq, the sum of Ï†(d) &gt;= psi(m)
6. Therefore psi(m) &lt;= deg(minpoly) &lt;= deg(charpoly) = N
" title="Crystallographic.psi_le_of_mem_integerMatrixOrders (N m : â„•) (hm : 0 &lt; m) (hord : m âˆˆ integerMatrixOrders N) : psi m â‰¤ N
If an N x N integer matrix has finite order m, then psi(m) &lt;= N....">psi_le_of_mem_integerMatrixOrders</span> <span class="lean-var" data-type="â„•" title="â„•">N</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span>,
   <span class="lean-keyword">fun</span> <span class="lean-var" data-type="psi m â‰¤ N" title="psi m â‰¤ N">hpsi</span> =&gt; <span class="lean-const" data-name="Crystallographic.mem_integerMatrixOrders_of_psi_le" data-signature="Crystallographic.mem_integerMatrixOrders_of_psi_le (N m : â„•) (hm : 0 &lt; m) (hpsi : psi m â‰¤ N) (hNm : m = 1 âˆ¨ 0 &lt; N) :
  m âˆˆ integerMatrixOrders N" data-docs="If psi(m) &lt;= N, then there exists an N x N integer matrix with order m.

This is the backward direction of the crystallographic restriction theorem.
The construction uses companion matrices of cyclotomic polynomials.

**Construction outline:**
1. For m = 1: use identity matrix (psi(1) = 0)
2. For m = 2: use -I (psi(2) = 0)
3. For prime power p^k with p odd or k &gt;= 2:
   - Use companion matrix of Phi_{p^k} (cyclotomic polynomial)
   - This has size phi(p^k) x phi(p^k) = psi(p^k) and order p^k
4. For general m = prod p_i^{k_i}:
   - Take block diagonal of companion matrices for each prime power factor
   - Total size is sum of phi(p_i^{k_i}) = psi(m)
5. Pad with identity blocks to reach size N x N
" title="Crystallographic.mem_integerMatrixOrders_of_psi_le (N m : â„•) (hm : 0 &lt; m) (hpsi : psi m â‰¤ N) (hNm : m = 1 âˆ¨ 0 &lt; N) :
  m âˆˆ integerMatrixOrders N
If psi(m) &lt;= N, then there exists an N x N integer matrix with order m....">mem_integerMatrixOrders_of_psi_le</span> <span class="lean-var" data-type="â„•" title="â„•">N</span> <span class="lean-var" data-type="â„•" title="â„•">m</span> <span class="lean-var" data-type="0 &lt; m" title="0 &lt; m">hm</span> <span class="lean-var" data-type="psi m â‰¤ N" title="psi m â‰¤ N">hpsi</span> <span class="lean-var" data-type="m = 1 âˆ¨ 0 &lt; N" title="m = 1 âˆ¨ 0 &lt; N">hNm</span><span class="lean-bracket-1">âŸ©</span></code></pre>
    <a href="https://github.com/e-vergo/General_Crystallographic_Restriction/blob/main/Crystallographic/Main/MainTheorem.lean#L42-L75" class="lean-github-hover" target="_blank" title="View on GitHub"><svg  class="icon icon-github "><use xlink:href="symbol-defs.svg#icon-github"></use></svg>
</a>
  </div>
</div>
<script>
(function() {
  var container = document.getElementById('thm:main-theorem');
  if (!container) return;
  var proofHeading = container.querySelector('.proof_heading');
  var leanProofBody = container.querySelector('.lean-proof-body');
  if (!proofHeading || !leanProofBody) return;

  proofHeading.addEventListener('click', function() {
    // Read icon state after plastex.js has toggled it
    setTimeout(function() {
      var icon = container.querySelector('.expand-proof');
      var isExpanded = icon && icon.textContent.trim() === 'â–¼';
      // Toggle expanded class for smooth CSS animation
      if (isExpanded) {
        leanProofBody.classList.add('expanded');
      } else {
        leanProofBody.classList.remove('expanded');
      }
    }, 50);
  });
})();
</script>




</div> <!--main-text -->
</div> <!-- content-wrapper -->
</div> <!-- content -->
</div> <!-- wrapper -->

<nav class="prev_up_next">
  <svg  id="showmore-minus" class="icon icon-eye-minus showmore"><use xlink:href="symbol-defs.svg#icon-eye-minus"></use></svg>

  <svg  id="showmore-plus" class="icon icon-eye-plus showmore"><use xlink:href="symbol-defs.svg#icon-eye-plus"></use></svg>

  <a href="sect0004.html" title="Companion Matrices"><svg  class="icon icon-arrow-left "><use xlink:href="symbol-defs.svg#icon-arrow-left"></use></svg>
</a>
  <a href="index.html" title="Crystallographic Restriction Theorem"><svg  class="icon icon-arrow-up "><use xlink:href="symbol-defs.svg#icon-arrow-up"></use></svg>
</a>
  <a href="sect0006.html" title="Appendix"><svg  class="icon icon-arrow-right "><use xlink:href="symbol-defs.svg#icon-arrow-right"></use></svg>
</a>
</nav>

<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/plastex.js"></script>
<script type="text/javascript" src="js/svgxuse.js"></script>
<script type="text/javascript" src="js/js.cookie.min.js"></script>
<script type="text/javascript" src="js/showmore.js"></script>
</body>
</html>